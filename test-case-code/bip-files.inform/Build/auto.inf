!% $ZCODE_LESS_DICT_DATA=1;
!% $OMIT_UNUSED_ROUTINES=1;
!% -s
!% $ALLOC_CHUNK_SIZE=32000
!% $MAX_ARRAYS=10000
!% $MAX_CLASSES=200
!% $MAX_VERBS=255
!% $MAX_LABELS=200000
!% $MAX_ZCODE_SIZE=1000000
!% $MAX_STATIC_DATA=500000
!% $MAX_NUM_STATIC_STRINGS=500000
!% $MAX_PROP_TABLE_SIZE=200000
!% $MAX_INDIV_PROP_TABLE_SIZE=20000
!% $MAX_STACK_SIZE=65536
!% $MAX_SYMBOLS=20000
!% $MAX_EXPRESSION_NODES=256
!% $MAX_LOCAL_VARIABLES=256
Constant Grammar__Version 2;
Global debug_flag;
Global or_tmp_var;
Attribute absent;
Attribute animate;
Attribute clothing;
Attribute concealed;
Attribute container;
Attribute door;
Attribute edible;
Attribute enterable;
Attribute light;
Attribute lockable;
Attribute locked;
Attribute moved;
Attribute on;
Attribute open;
Attribute openable;
Attribute scenery;
Attribute static;
Attribute supporter;
Attribute switchable;
Attribute talkable;
Attribute transparent;
Attribute visited;
Attribute worn;
Attribute male;
Attribute female;
Attribute neuter;
Attribute pluralname;
Attribute ambigpluralname;
Attribute proper;
Attribute remove_proper;
Attribute privately_named;
Attribute mentioned;
Attribute pushable;
Attribute mark_as_room;
Attribute mark_as_thing;
Attribute workflag;
Attribute workflag2;
Property add_to_scope;
Property article;
Property capacity;
Property component_child;
Property component_parent;
Property component_sibling;
Property description;
Property door_dir;
Property door_to;
Property found_in;
Property initial;
Property list_together;
Property map_region;
Property parse_name;
Property plural;
Property regional_found_in;
Property room_index;
Property short_name;
Property saved_short_name;
Property vector;
Property with_key;
Property KD_Count;
Property IK1_Count;
Property IK2_Count;
Property IK4_Count;
Property IK5_Count;
Property IK6_Count;
Property IK8_Count;
Property IK3_Count;
Property IK1_link;
Property IK2_link;
Property IK5_link;
Property IK6_link;
Property IK8_link;
Property articles;
Property grammar;
Property inside_description;
Property short_name_indef;
Global unicode_gestalt_ok = 0;
Global formal_rv = 0;
Global formal_par0 = 0;
Global formal_par1 = 0;
Global formal_par2 = 0;
Global formal_par3 = 0;
Global formal_par4 = 0;
Global formal_par5 = 0;
Global formal_par6 = 0;
Global formal_par7 = 0;
Global unicode_temp = 0;
Global I7SFRAME = 0;
Global TEXT_TY_RE_Err = 0;
Global prior_named_noun = 0;
Global prior_named_list = 0;
Global prior_named_list_gender = 0;
Global story_tense = 1;
Global story_viewpoint = 2;
Global say__p = 1;
Global say__pc = 0;
Global say__pc_save = 0;
Global say__n = 0;
Global say__comp = 0;
Global los_rv = 0;
Global parameter_object = 0;
Global parameter_value = 0;
Global property_to_be_totalled = 0;
Global property_loop_sign = 0;
Global suppress_scope_loops = 0;
Global temporary_value = 0;
Global clr_fg = 1;
Global clr_bg = 1;
Global clr_fgstatus = 1;
Global clr_bgstatus = 1;
Global clr_on = 0;
Global statuswin_current = 0;
Global suppress_text_substitution = 0;
Global deadflag = 0;
Global statuswin_cursize = 0;
Global statuswin_size = 1;
Global debug_rules = 0;
Global debug_rule_nesting = 0;
Global reason_the_action_failed = 0;
Global indef_mode = 0;
Global standard_interpreter = 0;
Global gg_mainwin = 0;
Global gg_statuswin = 0;
Global gg_quotewin = 0;
Global gg_scriptfref = 0;
Global gg_scriptstr = 0;
Global gg_savestr = 0;
Global gg_commandstr = 0;
Global gg_command_reading = 0;
Global gg_foregroundchan = 0;
Global gg_backgroundchan = 0;
Global I7S_Tab = 0;
Global I7S_Col = 0;
Global I7S_Dir = 0;
Global I7S_Swap = 0;
Global I7S_Comp = 0;
Global MStack_Top = 0;
Global MStack_Frame_Extent = 0;
Global process_rulebook_count = 0;
Global debugging_rules = 0;
Global RawBufferAddress = TEXT_TY_Buffers;
Global RawBufferSize = TEXT_TY_BufferSize;
Global TEXT_TY_CastPrimitiveNesting = 0;
Global TEXT_TY_RE_Trace = 0;
Global TEXT_TY_RE_RewindCount = 0;
Global LIST_OF_TY_Sort_cf = 0;
Global caps_mode = 0;
Global short_name_case = 0;
Global activities_sp = 0;
Global inhibit_flag = 0;
Global saved_debug_rules = 0;
Array Global_Vars --> 0
  (I_english_language_U1) ! -->1 = V1_language_of_play (V1_language_of_play)
;
Constant subterfuge_1 = absent;
Constant subterfuge_2 = animate;
Constant subterfuge_3 = clothing;
Constant subterfuge_4 = concealed;
Constant subterfuge_5 = container;
Constant subterfuge_6 = door;
Constant subterfuge_7 = edible;
Constant subterfuge_8 = enterable;
Constant subterfuge_9 = light;
Constant subterfuge_10 = lockable;
Constant subterfuge_11 = locked;
Constant subterfuge_12 = moved;
Constant subterfuge_13 = on;
Constant subterfuge_14 = open;
Constant subterfuge_15 = openable;
Constant subterfuge_16 = scenery;
Constant subterfuge_17 = static;
Constant subterfuge_18 = supporter;
Constant subterfuge_19 = switchable;
Constant subterfuge_20 = talkable;
Constant subterfuge_21 = transparent;
Constant subterfuge_22 = visited;
Constant subterfuge_23 = worn;
Constant subterfuge_24 = male;
Constant subterfuge_25 = female;
Constant subterfuge_26 = neuter;
Constant subterfuge_27 = pluralname;
Constant subterfuge_28 = ambigpluralname;
Constant subterfuge_29 = proper;
Constant subterfuge_30 = remove_proper;
Constant subterfuge_31 = privately_named;
Constant subterfuge_32 = mentioned;
Constant subterfuge_33 = pushable;
Constant subterfuge_34 = mark_as_room;
Constant subterfuge_35 = mark_as_thing;
Constant subterfuge_36 = workflag;
Constant subterfuge_37 = workflag2;
Constant subterfuge_38 = add_to_scope;
Constant subterfuge_39 = article;
Constant subterfuge_40 = capacity;
Constant subterfuge_41 = component_child;
Constant subterfuge_42 = component_parent;
Constant subterfuge_43 = component_sibling;
Constant subterfuge_44 = description;
Constant subterfuge_45 = door_dir;
Constant subterfuge_46 = door_to;
Constant subterfuge_47 = found_in;
Constant subterfuge_48 = initial;
Constant subterfuge_49 = list_together;
Constant subterfuge_50 = map_region;
Constant subterfuge_51 = parse_name;
Constant subterfuge_52 = plural;
Constant subterfuge_53 = regional_found_in;
Constant subterfuge_54 = room_index;
Constant subterfuge_55 = short_name;
Constant subterfuge_56 = saved_short_name;
Constant subterfuge_57 = vector;
Constant subterfuge_58 = with_key;
Constant subterfuge_59 = KD_Count;
Constant subterfuge_60 = IK1_Count;
Constant subterfuge_61 = IK2_Count;
Constant subterfuge_62 = IK4_Count;
Constant subterfuge_63 = IK5_Count;
Constant subterfuge_64 = IK6_Count;
Constant subterfuge_65 = IK8_Count;
Constant subterfuge_66 = IK3_Count;
Constant subterfuge_67 = IK1_link;
Constant subterfuge_68 = IK2_link;
Constant subterfuge_69 = IK5_link;
Constant subterfuge_70 = IK6_link;
Constant subterfuge_71 = IK8_link;
Constant subterfuge_72 = articles;
Constant subterfuge_73 = grammar;
Constant subterfuge_74 = inside_description;
Constant subterfuge_75 = short_name_indef;
Constant subterfuge_76 = P_variable_initial_value;
Constant subterfuge_77 = P_specification;
Constant subterfuge_78 = P_indefinite_appearance_text;
Constant subterfuge_79 = P_adaptive_text_viewpoint;
Constant subterfuge_80 = P_text_file;
Constant subterfuge_81 = P_heading;
Constant I_english_language_U1 = 1;
Constant I_french_language_U1 = 2;
Constant I_german_language_U1 = 3;
Constant I_italian_language_U1 = 4;
Constant I_spanish_language_U1 = 5;
Constant I_swedish_language_U1 = 6;
Constant I_present_tense_U1 = 1;
Constant I_past_tense_U1 = 2;
Constant I_perfect_tense_U1 = 3;
Constant I_past_perfect_tense_U1 = 4;
Constant I_future_tense_U1 = 5;
Constant I_first_person_singular_U1 = 1;
Constant I_second_person_singular_U1 = 2;
Constant I_third_person_singular_U1 = 3;
Constant I_first_person_plural_U1 = 4;
Constant I_second_person_plural_U1 = 5;
Constant I_third_person_plural_U1 = 6;
Constant I_nominative_U1 = 1;
Constant I_accusative_U1 = 2;
Constant I_neuter_gender_U1 = 1;
Constant I_masculine_gender_U1 = 2;
Constant I_feminine_gender_U1 = 3;
Constant I_notebook_U1 = 1;
Constant I_file_of_observations_U1 = 1;
Constant CV_POS = -1;
Constant CV_NEG = -2;
Constant CV_MODAL = -3;
Constant CV_MEANING = -4;
Constant REPARSE_CODE = 1073741824;
Constant VERB_DIRECTIVE_META = 1;
Constant VERB_DIRECTIVE_NOUN_FILTER = 1;
Constant VERB_DIRECTIVE_SCOPE_FILTER = 1;
Constant VERB_DIRECTIVE_REVERSE = 1;
Constant VERB_DIRECTIVE_SLASH = 1;
Constant VERB_DIRECTIVE_DIVIDER = 1;
Constant VERB_DIRECTIVE_RESULT = 2;
Constant VERB_DIRECTIVE_SPECIAL = 3;
Constant VERB_DIRECTIVE_NUMBER = 4;
Constant VERB_DIRECTIVE_NOUN = 5;
Constant VERB_DIRECTIVE_MULTI = 6;
Constant VERB_DIRECTIVE_MULTIINSIDE = 7;
Constant VERB_DIRECTIVE_MULTIHELD = 8;
Constant VERB_DIRECTIVE_HELD = 9;
Constant VERB_DIRECTIVE_CREATURE = 10;
Constant VERB_DIRECTIVE_TOPIC = 11;
Constant VERB_DIRECTIVE_MULTIEXCEPT = 12;
#ifndef DICT_WORD_SIZE;
Constant DICT_WORD_SIZE = 9;
#endif;
Constant PLAYER_OBJECT_INIS = 0;
Constant START_OBJECT_INIS = 1;
Constant START_ROOM_INIS = 2;
Constant START_TIME_INIS = 3;
Constant DynamicMemoryAllocation = 8192;
Constant Computed_Constant_Value_0_U1 = 1024;
Constant Computed_Constant_Value_1_U1 = 3;
Constant MAX_FIGURE_THUMBNAILS_IN_INDEX = 50;
Constant DONE_INIS = 4;
Constant RELS_SYMMETRIC = 32768;
Constant RELS_EQUIVALENCE = 16384;
Constant RELS_X_UNIQUE = 8192;
Constant RELS_Y_UNIQUE = 4096;
Constant RELS_TEST = 2048;
Constant RELS_ASSERT_TRUE = 1024;
Constant RELS_ASSERT_FALSE = 512;
Constant RELS_SHOW = 256;
Constant RELS_ROUTE_FIND = 128;
Constant RELS_ROUTE_FIND_COUNT = 64;
Constant RELS_LOOKUP_ANY = 8;
Constant RELS_LOOKUP_ALL_X = 4;
Constant RELS_LOOKUP_ALL_Y = 2;
Constant RELS_LIST = 1;
Constant TTF_sum = 3584;
Constant REL_BLOCK_HEADER = 101515264;
Constant relation_id_U1 = 9;
Constant relation_id_U2 = 10;
Constant relation_id_U3 = 11;
Constant relation_id_U4 = 12;
Constant relation_id_U5 = 13;
Constant relation_id_U6 = 14;
Constant relation_id_U7 = 15;
Constant relation_id_U8 = 16;
Constant relation_id_U9 = 17;
Constant relation_id_U10 = 18;
Constant relation_id_U11 = 19;
Constant relation_id_U12 = 20;
Constant relation_id_U13 = 21;
Constant relation_id_U14 = 22;
Constant relation_id_U15 = 23;
Constant relation_id_U16 = 24;
Constant relation_id_U17 = 25;
Constant relation_id_U18 = 26;
Constant relation_id_U19 = 27;
Constant relation_id_U20 = 28;
Constant relation_id_U21 = 29;
Constant relation_id_U22 = 30;
Constant relation_id_U23 = 31;
Constant relation_id_U24 = 32;
Constant relation_id_U25 = 33;
Constant relation_id_U26 = 34;
Constant relation_id_U27 = 35;
Constant relation_id_U28 = 36;
Constant relation_id_U29 = 37;
Constant relation_id_U30 = 38;
Constant relation_id_U31 = 39;
Constant relation_id_U32 = 40;
Constant relation_id_U33 = 41;
Constant relation_id_U34 = 42;
Constant kind_ref_U1 = 561;
Constant OBJECT_TY = 8;
Constant ICOUNT_OBJECT = 0;
#ifndef cap_short_name;
Constant cap_short_name = A_short_name;
#endif;
Constant kind_ref_U2 = 561;
Constant NUMBER_TY = 9;
Constant call_U15 = DecimalNumber;
Constant kind_ref_U3 = 561;
Constant REAL_NUMBER_TY = 10;
Constant call_U17 = REAL_NUMBER_TY_Say;
Constant kind_ref_U4 = 561;
Constant TRUTH_STATE_TY = 11;
Constant kind_ref_U5 = 561;
Constant TEXT_TY = 12;
Constant kind_ref_U6 = 561;
Constant SNIPPET_TY = 13;
Constant kind_ref_U7 = 561;
Constant UNICODE_CHARACTER_TY = 14;
Constant kind_ref_U8 = 561;
Constant USE_OPTION_TY = 15;
Constant kind_ref_U9 = 561;
Constant RESPONSE_TY = 16;
Constant kind_ref_U10 = 561;
Constant VERB_TY = 17;
Constant kind_ref_U11 = 561;
Constant TABLE_TY = 18;
Constant kind_ref_U12 = 561;
Constant EQUATION_TY = 19;
Constant kind_ref_U13 = 561;
Constant RULEBOOK_OUTCOME_TY = 20;
Constant kind_ref_U14 = 561;
Constant EXTERNAL_FILE_TY = 21;
Constant ICOUNT_EXTERNAL_FILE = 1;
Constant kind_ref_U15 = 561;
Constant VALUE_TY = 22;
Constant kind_ref_U16 = 561;
Constant STORED_VALUE_TY = 23;
Constant kind_ref_U17 = 561;
Constant SAYABLE_VALUE_TY = 24;
Constant kind_ref_U18 = 561;
Constant UNDERSTANDABLE_VALUE_TY = 25;
Constant kind_ref_U19 = 561;
Constant ARITHMETIC_VALUE_TY = 26;
Constant kind_ref_U20 = 561;
Constant REAL_ARITHMETIC_VALUE_TY = 27;
Constant kind_ref_U21 = 561;
Constant ENUMERATED_VALUE_TY = 28;
Constant kind_ref_U22 = 561;
Constant POINTER_VALUE_TY = 29;
Constant kind_ref_U23 = 561;
Constant PHRASE_TY = 30;
Constant kind_ref_U24 = 561;
Constant VARIABLE_TY = 31;
Constant kind_ref_U25 = 561;
Constant RELATION_TY = 32;
Constant kind_ref_U26 = 561;
Constant RULE_TY = 33;
Constant kind_ref_U27 = 561;
Constant RULEBOOK_TY = 34;
Constant kind_ref_U28 = 561;
Constant ACTIVITY_TY = 35;
Constant kind_ref_U29 = 561;
Constant LIST_OF_TY = 36;
Constant kind_ref_U30 = 561;
Constant DESCRIPTION_OF_TY = 37;
Constant kind_ref_U31 = 561;
Constant PROPERTY_TY = 38;
Constant kind_ref_U32 = 561;
Constant TABLE_COLUMN_TY = 39;
Constant kind_ref_U33 = 561;
Constant COMBINATION_TY = 40;
Constant kind_ref_U34 = 561;
Constant NIL_TY = 41;
Constant kind_ref_U35 = 561;
Constant UNKNOWN_TY = 42;
Constant kind_ref_U36 = 561;
Constant VOID_TY = 43;
Constant kind_ref_U37 = 561;
Constant TUPLE_ENTRY_TY = 44;
Constant property_id_U1 = 12;
Constant property_id_U2 = 13;
Constant CCOUNT_ACTION_NAME = 0;
Constant AD_RECORDS = 0;
Constant NO_PAST_TENSE_CONDS = 0;
Constant NO_PAST_TENSE_ACTIONS = 0;
Constant BASE_KIND_HWM = 45;
Constant RUCKSACK_CLASS = 0;
Constant NO_EXTERNAL_FILES = 1;
Constant CCOUNT_PROPERTY = 89;
Constant CCOUNT_BINARY_PREDICATE = 43;
Constant NUMBER_RULEBOOKS_CREATED = 11;
Constant NO_RESPONSES = 0;
Constant RANKING_TABLE = 0;
Constant NO_USE_OPTIONS = 17;
#ifndef WORDSIZE;
Constant WORDSIZE = 4;
#endif;
Constant NULL = -1;
Constant WORD_HIGHBIT = -2147483648;
Constant WORD_NEXTTOHIGHBIT = 1073741824;
Constant IMPROBABLE_VALUE = -559034863;
Constant MAX_POSITIVE_NUMBER = 2147483647;
Constant MIN_NEGATIVE_NUMBER = -2147483648;
#ifndef TARGET_GLULX;
Constant TARGET_GLULX = 1;
#endif;
#ifndef DEBUG;
Constant DEBUG = 1;
#endif;
Constant use_option_id_U1 = 0;
Constant use_option_id_U2 = 1;
Constant use_option_id_U3 = 2;
Constant use_option_id_U4 = 3;
Constant use_option_id_U5 = 4;
Constant use_option_id_U6 = 5;
Constant use_option_id_U7 = 6;
Constant use_option_id_U8 = 7;
Constant use_option_id_U9 = 8;
Constant use_option_id_U10 = 9;
Constant use_option_id_U11 = 10;
Constant use_option_id_U12 = 11;
Constant use_option_id_U13 = 12;
Constant use_option_id_U14 = 13;
Constant use_option_id_U15 = 14;
Constant use_option_id_U16 = 15;
Constant use_option_id_U17 = 16;
Constant property_id_U3 = 0;
Constant property_id_U4 = 1;
Constant property_id_U5 = 2;
Constant property_id_U6 = 3;
Constant property_id_U7 = 4;
Constant property_id_U8 = 5;
Constant property_id_U9 = 6;
Constant property_id_U10 = 7;
Constant property_id_U11 = 8;
Constant call_U105 = EMPTY_RULEBOOK;
Constant rulebook_id_U1 = 0;
Constant call_U106 = EMPTY_RULEBOOK;
Constant rulebook_id_U2 = 1;
Constant call_U107 = EMPTY_RULEBOOK;
Constant rulebook_id_U3 = 2;
Constant rulebook_id_U4 = 3;
Constant call_U109 = EMPTY_RULEBOOK;
Constant rulebook_id_U5 = 4;
Constant activity_id_U1 = 0;
Constant var_id_U1 = 10000;
Constant call_U110 = EMPTY_RULEBOOK;
Constant rulebook_id_U6 = 5;
Constant rulebook_id_U7 = 6;
Constant call_U112 = EMPTY_RULEBOOK;
Constant rulebook_id_U8 = 7;
Constant activity_id_U2 = 1;
Constant var_id_U2 = 10001;
Constant call_U113 = EMPTY_RULEBOOK;
Constant rulebook_id_U9 = 8;
Constant rulebook_id_U10 = 9;
Constant call_U115 = EMPTY_RULEBOOK;
Constant rulebook_id_U11 = 10;
Constant activity_id_U3 = 2;
Constant var_id_U3 = 10002;
Constant kind_ref_U38 = 561;
Constant WEAK_ID_39 = 2;
Constant ICOUNT_NATURAL_LANGUAGE = 6;
Constant extension_id_U1 = 1;
Constant anchor_U1 = 1105;
Constant anchor_U2 = 1105;
Constant anchor_U3 = 1105;
Constant relation_id_U35 = 0;
Constant relation_id_U36 = 1;
Constant relation_id_U37 = 2;
Constant relation_id_U38 = 3;
Constant relation_id_U39 = 4;
Constant relation_id_U40 = 5;
Constant kind_ref_U39 = 561;
Constant WEAK_ID_40 = 3;
Constant ICOUNT_GRAMMATICAL_TENSE = 5;
Constant kind_ref_U40 = 561;
Constant WEAK_ID_41 = 4;
Constant ICOUNT_NARRATIVE_VIEWPOINT = 6;
Constant kind_ref_U41 = 561;
Constant WEAK_ID_42 = 5;
Constant ICOUNT_GRAMMATICAL_CASE = 2;
Constant kind_ref_U42 = 561;
Constant WEAK_ID_43 = 6;
Constant ICOUNT_GRAMMATICAL_GENDER = 3;
Constant property_id_U12 = 9;
Constant extension_id_U2 = 2;
Constant relation_id_U41 = 6;
Constant kind_ref_U43 = 561;
Constant WEAK_ID_44 = 7;
Constant ICOUNT_JOTTER = 1;
Constant property_id_U13 = 10;
Constant property_id_U14 = 11;
Constant relation_id_U42 = 7;
Constant relation_id_U43 = 8;
Constant KIT_CONFIGURATION_BITMAP = 0;
Constant KIT_CONFIGURATION_LOOKMODE = 2;
Constant MAX_FRAME_SIZE_NEEDED = 0;
Constant RNG_SEED_AT_START_OF_PLAY = 0;
Constant id_U1 = 561;
Constant id_U2 = 561;
Constant id_U3 = 561;
Constant id_U4 = 561;
Constant id_U5 = 561;
Constant id_U6 = 561;
Constant id_U7 = 561;
Constant id_U8 = 561;
Constant id_U9 = 561;
Constant id_U10 = 561;
Constant id_U11 = 561;
Constant id_U12 = 561;
Constant id_U13 = 561;
Constant id_U14 = 561;
Constant id_U15 = 561;
Constant id_U16 = 561;
Constant id_U17 = 561;
Constant id_U18 = 561;
Constant id_U19 = 561;
Constant id_U20 = 561;
Constant id_U21 = 561;
Constant id_U22 = 561;
Constant id_U23 = 561;
Constant id_U24 = 561;
Constant id_U25 = 561;
Constant id_U26 = 561;
Constant id_U27 = 561;
Constant id_U28 = 561;
Constant id_U29 = 561;
Constant id_U30 = 561;
Constant id_U31 = 561;
Constant id_U32 = 561;
Constant id_U33 = 561;
Constant id_U34 = 561;
Constant id_U35 = 561;
Constant id_U36 = 561;
Constant id_U37 = 561;
Constant id_U38 = 561;
Constant id_U39 = 561;
Constant id_U40 = 561;
Constant id_U41 = 561;
Constant id_U42 = 561;
Constant id_U43 = 561;
Constant id_U44 = 561;
Constant id_U45 = 561;
Constant id_U46 = 561;
Constant id_U47 = 561;
Constant id_U48 = 561;
Constant id_U49 = 561;
Constant id_U50 = 561;
Constant id_U51 = 561;
Constant id_U52 = 561;
Constant id_U53 = 561;
Constant id_U54 = 561;
Constant id_U55 = 561;
Constant id_U56 = 561;
Constant id_U57 = 561;
Constant id_U58 = 561;
Constant id_U59 = 561;
Constant id_U60 = 561;
Constant id_U61 = 561;
Constant id_U62 = 561;
Constant id_U63 = 561;
Constant id_U64 = 561;
Constant id_U65 = 561;
Constant id_U66 = 561;
Constant id_U67 = 561;
Constant id_U68 = 561;
Constant id_U69 = 561;
Constant id_U70 = 561;
Constant id_U71 = 561;
Constant MEMORY_HEAP_SIZE = 32768;
Constant BASICINFORMKIT = 1;
Constant HDR_MAGICNUMBER = 0;
Constant HDR_GLULXVERSION = 4;
Constant HDR_RAMSTART = 8;
Constant HDR_EXTSTART = 12;
Constant HDR_ENDMEM = 16;
Constant HDR_STACKSIZE = 20;
Constant HDR_STARTFUNC = 24;
Constant HDR_DECODINGTBL = 28;
Constant HDR_CHECKSUM = 32;
Constant ROM_INFO = 36;
Constant ROM_MEMORYLAYOUT = 40;
Constant ROM_INFORMVERSION = 44;
Constant ROM_COMPVERSION = 48;
Constant ROM_GAMERELEASE = 52;
Constant ROM_GAMESERIAL = 54;
Constant NORMAL_VMSTY = 0;
Constant HEADER_VMSTY = 3;
Constant SUBHEADER_VMSTY = 4;
Constant ALERT_VMSTY = 5;
Constant NOTE_VMSTY = 6;
Constant BLOCKQUOTE_VMSTY = 7;
Constant INPUT_VMSTY = 8;
Constant CLR_DEFAULT = 1;
Constant CLR_BLACK = 2;
Constant CLR_RED = 3;
Constant CLR_GREEN = 4;
Constant CLR_YELLOW = 5;
Constant CLR_BLUE = 6;
Constant CLR_MAGENTA = 7;
Constant CLR_PURPLE = 7;
Constant CLR_CYAN = 8;
Constant CLR_AZURE = 8;
Constant CLR_WHITE = 9;
Constant WIN_ALL = 0;
Constant WIN_STATUS = 1;
Constant WIN_MAIN = 2;
Constant PARA_COMPLETED = 1;
Constant PARA_PROMPTSKIP = 2;
Constant PARA_SUPPRESSPROMPTSKIP = 4;
Constant PARA_NORULEBOOKBREAKS = 8;
Constant PARA_CONTENTEXPECTED = 16;
Constant POSSESS_PK = 256;
Constant DEFART_PK = 257;
Constant INDEFART_PK = 258;
Constant LIGHTED_PK = 259;
Constant UNLIGHTED_PK = 260;
Constant RTP_BACKDROP = 1;
Constant RTP_EXITDOOR = 2;
Constant RTP_NOEXIT = 3;
Constant RTP_CANTCHANGE = 4;
Constant RTP_IMPREL = 5;
Constant RTP_RULESTACK = 6;
Constant RTP_TOOMANYRULEBOOKS = 7;
Constant RTP_TOOMANYEVENTS = 8;
Constant RTP_BADPROPERTY = 9;
Constant RTP_UNPROVIDED = 10;
Constant RTP_UNSET = 11;
Constant RTP_TOOMANYACTS = 12;
Constant RTP_CANTABANDON = 13;
Constant RTP_CANTEND = 14;
Constant RTP_CANTMOVENOTHING = 15;
Constant RTP_CANTREMOVENOTHING = 16;
Constant RTP_DIVZERO = 17;
Constant RTP_BADVALUEPROPERTY = 18;
Constant RTP_NOTBACKDROP = 19;
Constant RTP_TABLE_NOCOL = 20;
Constant RTP_TABLE_NOCORR = 21;
Constant RTP_TABLE_NOROW = 22;
Constant RTP_TABLE_NOENTRY = 23;
Constant RTP_TABLE_NOTABLE = 24;
Constant RTP_TABLE_NOMOREBLANKS = 25;
Constant RTP_TABLE_NOROWS = 26;
Constant RTP_TABLE_CANTSORT = 27;
Constant RTP_NOTINAROOM = 28;
Constant RTP_BADTOPIC = 29;
Constant RTP_ROUTELESS = 30;
Constant RTP_PROPOFNOTHING = 31;
Constant RTP_DECIDEONWRONGKIND = 32;
Constant RTP_DECIDEONNOTHING = 33;
Constant RTP_TABLE_CANTSAVE = 34;
Constant RTP_TABLE_WONTFIT = 35;
Constant RTP_TABLE_BADFILE = 36;
Constant RTP_LOWLEVELERROR = 37;
Constant RTP_DONTIGNORETURNSEQUENCE = 38;
Constant RTP_SAYINVALIDSNIPPET = 39;
Constant RTP_SPLICEINVALIDSNIPPET = 40;
Constant RTP_INCLUDEINVALIDSNIPPET = 41;
Constant RTP_LISTWRITERMEMORY = 42;
Constant RTP_CANTREMOVEPLAYER = 43;
Constant RTP_CANTREMOVEDOORS = 44;
Constant RTP_CANTCHANGEOFFSTAGE = 45;
Constant RTP_MSTACKMEMORY = 46;
Constant RTP_TYPECHECK = 47;
Constant RTP_FILEIOERROR = 48;
Constant RTP_HEAPERROR = 49;
Constant RTP_LISTRANGEERROR = 50;
Constant RTP_REGEXPSYNTAXERROR = 51;
Constant RTP_NOGLULXUNICODE = 52;
Constant RTP_BACKDROPONLY = 53;
Constant RTP_NOTTHING = 54;
Constant RTP_SCENEHASNTSTARTED = 55;
Constant RTP_SCENEHASNTENDED = 56;
Constant RTP_NEGATIVEROOT = 57;
Constant RTP_TABLE_CANTRUNTHROUGH = 58;
Constant RTP_CANTITERATE = 59;
Constant RTP_WRONGASSIGNEDKIND = 60;
Constant RTP_CANTBEOFFSTAGE = 61;
Constant RTP_RELKINDVIOLATION = 62;
Constant RTP_CANTMAKEPART = 63;
Constant RTP_TEXTTOKENTOOHARD = 64;
Constant RTP_TABLE_NOTABLE2 = 65;
Constant RTP_RELATIONCHANGEIMPOSSIBLE = 66;
Constant RTP_RELMINIMAL = 67;
Constant RTP_LISTSIZENEGATIVE = 68;
Constant RTP_REGIONSNOTADJACENT = 69;
Constant STARTING_VIRTUAL_MACHINE_ACT = 0;
Constant PRINTING_THE_NAME_ACT = 1;
Constant PRINTING_THE_PLURAL_NAME_ACT = 2;
Constant PRINTING_RESPONSE_ACT = 3;
Constant PRINTING_A_NUMBER_OF_ACT = 4;
Constant PRINTING_ROOM_DESC_DETAILS_ACT = 5;
Constant PRINTING_INVENTORY_DETAILS_ACT = 6;
Constant LISTING_CONTENTS_ACT = 7;
Constant GROUPING_TOGETHER_ACT = 8;
Constant WRITING_A_PARAGRAPH_ABOUT_ACT = 9;
Constant LISTING_NONDESCRIPT_ITEMS_ACT = 10;
Constant PRINTING_NAME_OF_DARK_ROOM_ACT = 11;
Constant PRINTING_DESC_OF_DARK_ROOM_ACT = 12;
Constant PRINTING_NEWS_OF_DARKNESS_ACT = 13;
Constant PRINTING_NEWS_OF_LIGHT_ACT = 14;
Constant REFUSAL_TO_ACT_IN_DARK_ACT = 15;
Constant CONSTRUCTING_STATUS_LINE_ACT = 16;
Constant PRINTING_BANNER_TEXT_ACT = 17;
Constant READING_A_COMMAND_ACT = 18;
Constant DECIDING_SCOPE_ACT = 19;
Constant DECIDING_CONCEALED_POSSESS_ACT = 20;
Constant DECIDING_WHETHER_ALL_INC_ACT = 21;
Constant CLARIFYING_PARSERS_CHOICE_ACT = 22;
Constant ASKING_WHICH_DO_YOU_MEAN_ACT = 23;
Constant PRINTING_A_PARSER_ERROR_ACT = 24;
Constant SUPPLYING_A_MISSING_NOUN_ACT = 25;
Constant SUPPLYING_A_MISSING_SECOND_ACT = 26;
Constant IMPLICITLY_TAKING_ACT = 27;
Constant AMUSING_A_VICTORIOUS_PLAYER_ACT = 28;
Constant PRINTING_PLAYERS_OBITUARY_ACT = 29;
Constant DEALING_WITH_FINAL_QUESTION_ACT = 30;
Constant PRINTING_LOCALE_DESCRIPTION_ACT = 31;
Constant CHOOSING_NOTABLE_LOCALE_OBJ_ACT = 32;
Constant PRINTING_LOCALE_PARAGRAPH_ACT = 33;
Constant STARTUP_RB = 0;
Constant SHUTDOWN_RB = 1;
Constant TURN_SEQUENCE_RB = 11;
Constant WHEN_PLAY_BEGINS_RB = 13;
Constant WHEN_PLAY_ENDS_RB = 14;
Constant WHEN_SCENE_BEGINS_RB = 15;
Constant WHEN_SCENE_ENDS_RB = 16;
Constant ACTION_PROCESSING_RB = 18;
Constant SETTING_ACTION_VARIABLES_RB = 19;
Constant SPECIFIC_ACTION_PROCESSING_RB = 20;
Constant ACCESSIBILITY_RB = 22;
Constant REACHING_INSIDE_RB = 23;
Constant REACHING_OUTSIDE_RB = 24;
Constant VISIBLE_RB = 25;
Constant PERSUADE_RB = 26;
Constant UNSUCCESSFUL_ATTEMPT_RB = 27;
Constant AFTER_RB = 32;
Constant REPORT_RB = 33;
Constant DOES_THE_PLAYER_MEAN_RB = 34;
Constant MULTIPLE_ACTION_PROCESSING_RB = 35;
Constant PARSING_REASON = 0;
Constant TALKING_REASON = 1;
Constant EACH_TURN_REASON = 2;
Constant LOOPOVERSCOPE_REASON = 5;
Constant TESTSCOPE_REASON = 6;
Constant ILLEGAL_TT = 0;
Constant ELEMENTARY_TT = 1;
Constant PREPOSITION_TT = 2;
Constant ROUTINE_FILTER_TT = 3;
Constant ATTR_FILTER_TT = 4;
Constant SCOPE_TT = 5;
Constant GPR_TT = 6;
Constant NOUN_TOKEN = 0;
Constant HELD_TOKEN = 1;
Constant MULTI_TOKEN = 2;
Constant MULTIHELD_TOKEN = 3;
Constant MULTIEXCEPT_TOKEN = 4;
Constant MULTIINSIDE_TOKEN = 5;
Constant CREATURE_TOKEN = 6;
Constant SPECIAL_TOKEN = 7;
Constant NUMBER_TOKEN = 8;
Constant TOPIC_TOKEN = 9;
Constant ENDIT_TOKEN = 15;
Constant GPR_FAIL = -1;
Constant GPR_PREPOSITION = 0;
Constant GPR_NUMBER = 1;
Constant GPR_MULTIPLE = 2;
Constant GPR_NOUN = -256;
Constant Computed_Constant_Value_0_U2 = 1;
Constant Computed_Constant_Value_2_U2 = 2;
Constant Computed_Constant_Value_4_U1 = 3;
Constant Computed_Constant_Value_6_U1 = 4;
Constant Computed_Constant_Value_8_U1 = 5;
Constant Computed_Constant_Value_10_U1 = 6;
Constant NEWLINE_BIT = 1;
Constant INDENT_BIT = 2;
Constant FULLINV_BIT = 4;
Constant ENGLISH_BIT = 8;
Constant RECURSE_BIT = 16;
Constant ALWAYS_BIT = 32;
Constant TERSE_BIT = 64;
Constant PARTINV_BIT = 128;
Constant DEFART_BIT = 256;
Constant WORKFLAG_BIT = 512;
Constant ISARE_BIT = 1024;
Constant CONCEAL_BIT = 2048;
Constant NOARTICLE_BIT = 4096;
Constant EXTRAINDENT_BIT = 8192;
Constant CFIRSTART_BIT = 16384;
Constant QUARTER_HOUR = 15;
Constant HALF_HOUR = 30;
Constant ONE_HOUR = 60;
Constant TWELVE_HOURS = 720;
Constant TWENTY_FOUR_HOURS = 1440;
Constant list_filter_permits = A_privately_named;
Constant USE_SCORING_TCBIT = 1;
Constant PREVENT_UNDO_TCBIT = 2;
Constant SERIAL_COMMA_TCBIT = 4;
Constant PROGRAMMING_EXPONENTS_TCBIT = 8;
Constant FIX_RNG_TCBIT = 16;
Constant ECHO_COMMANDS_TCBIT = 32;
Constant NO_VERB_VERB_DEFINED_TCBIT = 64;
Constant DIALECT_US_TCBIT = 128;
Constant STORY_AUTHOR_TCBIT = 256;
Constant RANKING_TABLE_TCBIT = 512;
Constant Computed_Constant_Value_12_U1 = 4;
Constant LanguageCases = 1;
Constant R_DecimalNumber = GenerateRandomNumber;
Constant R_PrintTimeOfDay = GenerateRandomNumber;
Constant GLK_NULL = 0;
Constant INPUT_BUFFER_LEN = 260;
Constant MAX_BUFFER_WORDS = 20;
Constant PARSE_BUFFER_LEN = 61;
Constant evtype_Arrange = 5;
Constant evtype_CharInput = 2;
Constant evtype_Hyperlink = 8;
Constant evtype_LineInput = 3;
Constant evtype_MouseInput = 4;
Constant evtype_None = 0;
Constant evtype_Redraw = 6;
Constant evtype_SoundNotify = 7;
Constant evtype_Timer = 1;
Constant evtype_VolumeNotify = 9;
Constant filemode_Read = 2;
Constant filemode_ReadWrite = 3;
Constant filemode_Write = 1;
Constant filemode_WriteAppend = 5;
Constant fileusage_BinaryMode = 0;
Constant fileusage_Data = 0;
Constant fileusage_InputRecord = 3;
Constant fileusage_SavedGame = 1;
Constant fileusage_TextMode = 256;
Constant fileusage_Transcript = 2;
Constant fileusage_TypeMask = 15;
Constant gestalt_CharInput = 1;
Constant gestalt_CharOutput = 3;
Constant gestalt_CharOutput_ApproxPrint = 1;
Constant gestalt_CharOutput_CannotPrint = 0;
Constant gestalt_CharOutput_ExactPrint = 2;
Constant gestalt_DateTime = 20;
Constant gestalt_DrawImage = 7;
Constant gestalt_Graphics = 6;
Constant gestalt_GraphicsCharInput = 23;
Constant gestalt_GraphicsTransparency = 14;
Constant gestalt_HyperlinkInput = 12;
Constant gestalt_Hyperlinks = 11;
Constant gestalt_LineInput = 2;
Constant gestalt_LineInputEcho = 17;
Constant gestalt_LineTerminatorKey = 19;
Constant gestalt_LineTerminators = 18;
Constant gestalt_MouseInput = 4;
Constant gestalt_ResourceStream = 22;
Constant gestalt_Sound = 8;
Constant gestalt_Sound2 = 21;
Constant gestalt_SoundMusic = 13;
Constant gestalt_SoundNotify = 10;
Constant gestalt_SoundVolume = 9;
Constant gestalt_Timer = 5;
Constant gestalt_Unicode = 15;
Constant gestalt_UnicodeNorm = 16;
Constant gestalt_Version = 0;
Constant imagealign_InlineCenter = 3;
Constant imagealign_InlineDown = 2;
Constant imagealign_MarginLeft = 4;
Constant imagealign_MarginRight = 5;
Constant imagealign_InlineUp = 1;
Constant keycode_Delete = -7;
Constant keycode_Down = -5;
Constant keycode_End = -13;
Constant keycode_Escape = -8;
Constant keycode_Func1 = -17;
Constant keycode_Func10 = -26;
Constant keycode_Func11 = -27;
Constant keycode_Func12 = -28;
Constant keycode_Func2 = -18;
Constant keycode_Func3 = -19;
Constant keycode_Func4 = -20;
Constant keycode_Func5 = -21;
Constant keycode_Func6 = -22;
Constant keycode_Func7 = -23;
Constant keycode_Func8 = -24;
Constant keycode_Func9 = -25;
Constant keycode_Home = -12;
Constant keycode_Left = -2;
Constant keycode_MAXVAL = 28;
Constant keycode_PageDown = -11;
Constant keycode_PageUp = -10;
Constant keycode_Return = -6;
Constant keycode_Right = -3;
Constant keycode_Tab = -9;
Constant keycode_Unknown = -1;
Constant keycode_Up = -4;
Constant seekmode_Current = 1;
Constant seekmode_End = 2;
Constant seekmode_Start = 0;
Constant style_Alert = 5;
Constant style_BlockQuote = 7;
Constant style_Emphasized = 1;
Constant style_Header = 3;
Constant style_Input = 8;
Constant style_NUMSTYLES = 11;
Constant style_Normal = 0;
Constant style_Note = 6;
Constant style_Preformatted = 2;
Constant style_Subheader = 4;
Constant style_User1 = 9;
Constant style_User2 = 10;
Constant stylehint_BackColor = 8;
Constant stylehint_Indentation = 0;
Constant stylehint_Justification = 2;
Constant stylehint_NUMHINTS = 10;
Constant stylehint_Oblique = 5;
Constant stylehint_ParaIndentation = 1;
Constant stylehint_Proportional = 6;
Constant stylehint_ReverseColor = 9;
Constant stylehint_Size = 3;
Constant stylehint_TextColor = 7;
Constant stylehint_Weight = 4;
Constant stylehint_just_Centered = 2;
Constant stylehint_just_LeftFlush = 0;
Constant stylehint_just_LeftRight = 1;
Constant stylehint_just_RightFlush = 3;
Constant winmethod_Above = 2;
Constant winmethod_Below = 3;
Constant winmethod_Border = 0;
Constant winmethod_BorderMask = 256;
Constant winmethod_DirMask = 15;
Constant winmethod_DivisionMask = 240;
Constant winmethod_Fixed = 16;
Constant winmethod_Left = 0;
Constant winmethod_NoBorder = 256;
Constant winmethod_Proportional = 32;
Constant winmethod_Right = 1;
Constant wintype_AllTypes = 0;
Constant wintype_Blank = 2;
Constant wintype_Graphics = 5;
Constant wintype_Pair = 1;
Constant wintype_TextBuffer = 3;
Constant wintype_TextGrid = 4;
Constant GG_MAINWIN_ROCK = 201;
Constant GG_STATUSWIN_ROCK = 202;
Constant GG_QUOTEWIN_ROCK = 203;
Constant GG_SAVESTR_ROCK = 301;
Constant GG_SCRIPTSTR_ROCK = 302;
Constant GG_COMMANDWSTR_ROCK = 303;
Constant GG_COMMANDRSTR_ROCK = 304;
Constant GG_SCRIPTFREF_ROCK = 401;
Constant GG_FOREGROUNDCHAN_ROCK = 410;
Constant GG_BACKGROUNDCHAN_ROCK = 411;
Constant GG_ANYTOSTRING_LEN = 66;
Constant M_0 = 0;
Constant M_1 = 1065353216;
Constant M_HALF = 1056964608;
Constant M_THIRD = 1051372203;
Constant M_LOG10 = 1075010958;
Constant M_N1 = -1082130432;
Constant M_PI = 1078530011;
Constant M_NPI = -1068953637;
Constant M_2PI = 1086918619;
Constant M_PI2 = 1070141403;
Constant M_NPI2 = -1077342245;
Constant M_E = 1076754516;
Constant M_E2 = 1089237798;
Constant M_N0 = -2147483648;
Constant M_INF = 2139095040;
Constant M_NINF = -8388608;
Constant M_NAN = 2139095041;
Constant M_NNAN = -8388607;
Constant AUXF_MAGIC = 0;
Constant AUXF_MAGIC_VALUE = 16339;
Constant AUXF_STATUS = 1;
Constant AUXF_STATUS_IS_CLOSED = 1;
Constant AUXF_STATUS_IS_OPEN_FOR_READ = 2;
Constant AUXF_STATUS_IS_OPEN_FOR_WRITE = 3;
Constant AUXF_STATUS_IS_OPEN_FOR_APPEND = 4;
Constant AUXF_BINARY = 2;
Constant AUXF_STREAM = 3;
Constant AUXF_FILENAME = 4;
Constant AUXF_IFID_OF_OWNER = 5;
Constant TB_COLUMN_REAL = 32768;
Constant TB_COLUMN_SIGNED = 16384;
Constant TB_COLUMN_TOPIC = 8192;
Constant TB_COLUMN_DONTSORTME = 4096;
Constant TB_COLUMN_NOBLANKBITS = 2048;
Constant TB_COLUMN_CANEXCHANGE = 1024;
Constant TB_COLUMN_ALLOCATED = 512;
Constant TB_COLUMN_NUMBER = 511;
Constant COL_HSIZE = 2;
Constant Computed_Constant_Value_16_U1 = 2;
Constant MSTACK_CAPACITY = 20;
Constant RS_NEITHER = 0;
Constant RS_SUCCEEDS = 1;
Constant RS_FAILS = 2;
Constant BLK_HEADER_N = 0;
Constant BLK_HEADER_FLAGS = 1;
Constant BLK_FLAG_MULTIPLE = 1;
Constant BLK_FLAG_16_BIT = 2;
Constant BLK_FLAG_WORD = 4;
Constant BLK_FLAG_RESIDENT = 8;
Constant BLK_FLAG_TRUNCMULT = 16;
Constant BLK_HEADER_KOV = 1;
Constant BLK_HEADER_RCOUNT = 2;
Constant Computed_Constant_Value_19_U1 = 3;
Constant Computed_Constant_Value_21_U1 = 2;
Constant BLK_NEXT = 3;
Constant BLK_PREV = 4;
Constant SMALLEST_BLK_WORTH_ALLOCATING = 12;
Constant BLK_BVBITMAP = 255;
Constant BLK_BVBITMAP_LONGBLOCK = 16;
Constant BLK_BVBITMAP_TEXT = 32;
Constant BLK_BVBITMAP_CONSTANT = 64;
Constant BLK_BVBITMAP_LONGBLOCKMASK = -240;
Constant BLK_BVBITMAP_TEXTMASK = -224;
Constant BLK_BVBITMAP_CONSTANTMASK = -192;
Constant CREATE_KOVS = 1;
Constant CAST_KOVS = 2;
Constant DESTROY_KOVS = 3;
Constant MAKEMUTABLE_KOVS = 4;
Constant COPYKIND_KOVS = 5;
Constant EXTENT_KOVS = 6;
Constant COPYQUICK_KOVS = 7;
Constant COPYSB_KOVS = 8;
Constant KINDDATA_KOVS = 9;
Constant COPY_KOVS = 10;
Constant COMPARE_KOVS = 11;
Constant READ_FILE_KOVS = 12;
Constant WRITE_FILE_KOVS = 13;
Constant HASH_KOVS = 14;
Constant DEBUG_KOVS = 15;
Constant Computed_Constant_Value_26_U1 = 1;
Constant Computed_Constant_Value_29_U1 = 2;
Constant Computed_Constant_Value_31_U1 = 3;
Constant Computed_Constant_Value_34_U1 = 4;
Constant Large_Unicode_Tables = 0;
Constant TEXT_TY_NoBuffers = 2;
Constant CHR_BLOB = 1;
Constant WORD_BLOB = 2;
Constant PWORD_BLOB = 3;
Constant UWORD_BLOB = 4;
Constant PARA_BLOB = 5;
Constant LINE_BLOB = 6;
Constant REGEXP_BLOB = 7;
Constant WS_BRM = 1;
Constant SKIPPED_BRM = 2;
Constant ACCEPTED_BRM = 3;
Constant ACCEPTEDP_BRM = 4;
Constant ACCEPTEDN_BRM = 5;
Constant ACCEPTEDPN_BRM = 6;
Constant UNIC_NCT = 10000;
Constant NEWLINE_RE_CC = -1;
Constant TAB_RE_CC = -2;
Constant DIGIT_RE_CC = -3;
Constant NONDIGIT_RE_CC = -4;
Constant WHITESPACE_RE_CC = -5;
Constant NONWHITESPACE_RE_CC = -6;
Constant PUNCTUATION_RE_CC = -7;
Constant NONPUNCTUATION_RE_CC = -8;
Constant WORD_RE_CC = -9;
Constant NONWORD_RE_CC = -10;
Constant ANYTHING_RE_CC = -11;
Constant NOTHING_RE_CC = -12;
Constant RANGE_RE_CC = -13;
Constant LCASE_RE_CC = -14;
Constant NONLCASE_RE_CC = -15;
Constant UCASE_RE_CC = -16;
Constant NONUCASE_RE_CC = -17;
Constant SUBEXP_RE_CC = -20;
Constant DISJUNCTION_RE_CC = -21;
Constant CHOICE_RE_CC = -22;
Constant QUANTIFIER_RE_CC = -23;
Constant IF_RE_CC = -24;
Constant CONDITION_RE_CC = -25;
Constant THEN_RE_CC = -26;
Constant ELSE_RE_CC = -27;
Constant VARIABLE_RE_CC = -30;
Constant LITERAL_RE_CC = -31;
Constant START_RE_CC = -40;
Constant END_RE_CC = -41;
Constant BOUNDARY_RE_CC = -42;
Constant NONBOUNDARY_RE_CC = -43;
Constant ALWAYS_RE_CC = -44;
Constant NEVER_RE_CC = -45;
Constant SENSITIVITY_RE_CC = -50;
Constant RE_MAX_PACKETS = 32;
Constant RE_PACKET_SIZE = 14;
Constant RE_CCLASS = 0;
Constant RE_PAR1 = 1;
Constant RE_PAR2 = 2;
Constant RE_PAR3 = 3;
Constant RE_NEXT = 4;
Constant RE_PREVIOUS = 5;
Constant RE_DOWN = 6;
Constant RE_UP = 7;
Constant RE_DATA1 = 8;
Constant RE_DATA2 = 9;
Constant RE_CONSTRAINT = 10;
Constant RE_CACHE1 = 11;
Constant RE_CACHE2 = 12;
Constant RE_MODES = 13;
Constant CIS_MFLAG = 1;
Constant ACCUM_MFLAG = 2;
Constant LIST_ITEM_KOV_F = 0;
Constant LIST_LENGTH_F = 1;
Constant LIST_ITEM_BASE = 2;
Constant COMBINATION_KIND_F = 0;
Constant COMBINATION_ITEM_BASE = 1;
Constant Computed_Constant_Value_42_U1 = 5;
Constant Computed_Constant_Value_44_U1 = 5;
Constant Computed_Constant_Value_46_U1 = 5;
Constant Computed_Constant_Value_48_U1 = 5;
Constant Computed_Constant_Value_50_U1 = 5;
Constant Computed_Constant_Value_52_U1 = 5;
Constant RRV_USED = 6;
Constant RRV_FILLED = 7;
Constant RRV_DATA_BASE = 8;
Constant RRVAL_V_TO_V = 0;
Constant RRF_USED = 1;
Constant RRF_DELETED = 2;
Constant RRF_SINGLE = 4;
Constant RRF_HASX = 16;
Constant RRF_HASY = 32;
Constant RRF_ENTKEYX = 64;
Constant RRF_ENTKEYY = 128;
Constant RELS_COPY = 32;
Constant RELS_DESTROY = 16;
Constant RELS_EMPTY = 3;
Constant RELS_SET_VALENCY = 5;
Constant RLANY_GET_X = 1;
Constant RLANY_GET_Y = 2;
Constant RLANY_CAN_GET_X = 3;
Constant RLANY_CAN_GET_Y = 4;
Constant RLIST_ALL_X = 1;
Constant RLIST_ALL_Y = 2;
Constant RLIST_ALL_PAIRS = 3;
Constant RRP_MIN_SIZE = 8;
Constant RRP_PERTURB_SHIFT = 5;
Constant MINUS_RRP_PERTURB_SHIFT = -5;
Constant RRP_RESIZE_SMALL = 4;
Constant RRP_RESIZE_LARGE = 2;
Constant RRP_LARGE_IS = 256;
Constant RRP_CROWDED_IS = 2;
Constant RR_NAME = 5;
Constant RR_PERMISSIONS = 6;
Constant RR_STORAGE = 7;
Constant RR_KIND = 8;
Constant RR_HANDLER = 9;
Constant RR_DESCRIPTION = 10;
Constant VTOVS_LEFT_INDEX_PROP = 0;
Constant VTOVS_RIGHT_INDEX_PROP = 1;
Constant VTOVS_LEFT_DOMAIN_SIZE = 2;
Constant VTOVS_RIGHT_DOMAIN_SIZE = 3;
Constant VTOVS_LEFT_PRINTING_ROUTINE = 4;
Constant VTOVS_RIGHT_PRINTING_ROUTINE = 5;
Constant VTOVS_CACHE_BROKEN = 6;
Constant VTOVS_CACHE = 7;
Constant Computed_Constant_Value_61_U1 = 32;
Constant MAX_TIMERS = 0;
Constant Computed_Constant_Value_14_U1 = 1;
Constant Computed_Constant_Value_37_U1 = 2;
Constant property_id_U15 = 14;
Constant property_id_U16 = 15;
Constant property_id_U17 = 16;
Constant property_id_U18 = 17;
Constant property_id_U19 = 18;
Constant property_id_U20 = 19;
Constant property_id_U21 = 20;
Constant property_id_U22 = 21;
Constant property_id_U23 = 22;
Constant property_id_U24 = 23;
Constant property_id_U25 = 24;
Constant property_id_U26 = 25;
Constant property_id_U27 = 26;
Constant property_id_U28 = 27;
Constant property_id_U29 = 28;
Constant property_id_U30 = 29;
Constant property_id_U31 = 30;
Constant property_id_U32 = 31;
Constant property_id_U33 = 32;
Constant property_id_U34 = 33;
Constant property_id_U35 = 34;
Constant property_id_U36 = 35;
Constant property_id_U37 = 36;
Constant property_id_U38 = 37;
Constant property_id_U39 = 38;
Constant property_id_U40 = 39;
Constant property_id_U41 = 40;
Constant property_id_U42 = 41;
Constant property_id_U43 = 42;
Constant property_id_U44 = 43;
Constant property_id_U45 = 44;
Constant property_id_U46 = 45;
Constant property_id_U47 = 46;
Constant property_id_U48 = 47;
Constant property_id_U49 = 48;
Constant property_id_U50 = 49;
Constant property_id_U51 = 50;
Constant property_id_U52 = 51;
Constant property_id_U53 = 52;
Constant property_id_U54 = 53;
Constant property_id_U55 = 54;
Constant property_id_U56 = 55;
Constant property_id_U57 = 56;
Constant property_id_U58 = 57;
Constant property_id_U59 = 58;
Constant property_id_U60 = 59;
Constant property_id_U61 = 60;
Constant property_id_U62 = 61;
Constant property_id_U63 = 62;
Constant property_id_U64 = 63;
Constant property_id_U65 = 64;
Constant property_id_U66 = 65;
Constant property_id_U67 = 66;
Constant property_id_U68 = 67;
Constant property_id_U69 = 68;
Constant property_id_U70 = 69;
Constant property_id_U71 = 70;
Constant property_id_U72 = 71;
Constant property_id_U73 = 72;
Constant property_id_U74 = 73;
Constant property_id_U75 = 74;
Constant property_id_U76 = 75;
Constant property_id_U77 = 76;
Constant property_id_U78 = 77;
Constant property_id_U79 = 78;
Constant property_id_U80 = 79;
Constant property_id_U81 = 80;
Constant property_id_U82 = 81;
Constant property_id_U83 = 82;
Constant property_id_U84 = 83;
Constant property_id_U85 = 84;
Constant property_id_U86 = 85;
Constant property_id_U87 = 86;
Constant property_id_U88 = 87;
Constant property_id_U89 = 88;
Constant ENGLISHLANGUAGEKIT = 1;
Constant AGAIN1__WD = 'again';
Constant AGAIN2__WD = 'g//';
Constant AGAIN3__WD = 'again';
Constant OOPS1__WD = 'oops';
Constant OOPS2__WD = 'o//';
Constant OOPS3__WD = 'oops';
Constant UNDO1__WD = 'undo';
Constant UNDO2__WD = 'undo';
Constant UNDO3__WD = 'undo';
Constant ALL1__WD = 'all';
Constant ALL2__WD = 'each';
Constant ALL3__WD = 'every';
Constant ALL4__WD = 'everything';
Constant ALL5__WD = 'both';
Constant AND1__WD = 'and';
Constant AND2__WD = 'and';
Constant AND3__WD = 'and';
Constant BUT1__WD = 'but';
Constant BUT2__WD = 'except';
Constant BUT3__WD = 'but';
Constant ME1__WD = 'me';
Constant ME2__WD = 'myself';
Constant ME3__WD = 'self';
Constant OF1__WD = 'of';
Constant OF2__WD = 'of';
Constant OF3__WD = 'of';
Constant OF4__WD = 'of';
Constant OTHER1__WD = 'another';
Constant OTHER2__WD = 'other';
Constant OTHER3__WD = 'other';
Constant THEN1__WD = 'then';
Constant THEN2__WD = 'then';
Constant THEN3__WD = 'then';
Constant NO1__WD = 'n//';
Constant NO2__WD = 'no';
Constant NO3__WD = 'no';
Constant YES1__WD = 'y//';
Constant YES2__WD = 'yes';
Constant YES3__WD = 'yes';
Constant AMUSING__WD = 'amusing';
Constant FULLSCORE1__WD = 'fullscore';
Constant FULLSCORE2__WD = 'full';
Constant QUIT1__WD = 'q//';
Constant QUIT2__WD = 'quit';
Constant RESTART__WD = 'restart';
Constant RESTORE__WD = 'restore';
Constant LanguageAnimateGender = A_male;
Constant LanguageInanimateGender = A_neuter;
Constant LanguageContractionForms = 2;
Constant BASICINFORMEXTRASKIT = 1;
Constant MAX_NESTED_ACTIVITIES = 20;
Constant EMPTY_TEXT_PACKED = "";
Constant I7_VERSION_NUMBER = "10.1.2";
Constant I7_FULL_VERSION_NUMBER = "10.1.2";
Constant alphabetised_text_0 = "Observations in the Pottingham Green Case";
Constant outcome_allow_startup_U1 = "allow startup";
Constant outcome_deny_startup_U1 = "deny startup";
Constant abilities_U1 = (RELS_TEST);
Constant abilities_U2 = (RELS_TEST);
Constant abilities_U4 = (RELS_TEST);
Constant abilities_U5 = (RELS_TEST);
Constant V1_starting_the_virtual_mach = activity_id_U1;
Constant V2_printing_the_name = activity_id_U2;
Constant V3_printing_the_plural_name = activity_id_U3;
Constant text_U1 = alphabetised_text_0;
Constant GPR_REPARSE = REPARSE_CODE;
Constant TABLE_NOVALUE = IMPROBABLE_VALUE;
Constant RC_INFINITY = MAX_POSITIVE_NUMBER;
Constant RRVAL_V_TO_O = RELS_Y_UNIQUE;
Constant RRVAL_O_TO_V = RELS_X_UNIQUE;
Constant RRVAL_SYM_V_TO_V = RELS_SYMMETRIC;
Constant Computed_Constant_Value_2_U1 = (Computed_Constant_Value_0_U1 + Computed_Constant_Value_1_U1);
Constant Computed_Constant_Value_1_U2 = (GPR_NOUN + Computed_Constant_Value_0_U2);
Constant Computed_Constant_Value_3_U1 = (GPR_NOUN + Computed_Constant_Value_2_U2);
Constant Computed_Constant_Value_5_U1 = (GPR_NOUN + Computed_Constant_Value_4_U1);
Constant Computed_Constant_Value_7_U1 = (GPR_NOUN + Computed_Constant_Value_6_U1);
Constant Computed_Constant_Value_9_U1 = (GPR_NOUN + Computed_Constant_Value_8_U1);
Constant Computed_Constant_Value_11_U1 = (GPR_NOUN + Computed_Constant_Value_10_U1);
Constant Computed_Constant_Value_13_U1 = (DynamicMemoryAllocation / Computed_Constant_Value_12_U1);
Constant Computed_Constant_Value_17_U1 = (Computed_Constant_Value_16_U1 + MAX_FRAME_SIZE_NEEDED);
Constant Computed_Constant_Value_20_U1 = (Computed_Constant_Value_19_U1 * WORDSIZE);
Constant Computed_Constant_Value_22_U1 = (Computed_Constant_Value_21_U1 * WORDSIZE);
Constant Computed_Constant_Value_25_U1 = (BLK_BVBITMAP_TEXT + BLK_BVBITMAP_CONSTANT);
Constant Computed_Constant_Value_28_U1 = (BLK_BVBITMAP_TEXT + BLK_BVBITMAP_CONSTANT);
Constant Computed_Constant_Value_32_U1 = (BLK_BVBITMAP_TEXT + Computed_Constant_Value_31_U1);
Constant Computed_Constant_Value_33_U1 = (BLK_BVBITMAP_TEXT + BLK_BVBITMAP_LONGBLOCK);
Constant Computed_Constant_Value_36_U1 = (BLK_FLAG_MULTIPLE + BLK_FLAG_16_BIT);
Constant Computed_Constant_Value_40_U1 = (WORDSIZE * RE_PACKET_SIZE);
Constant Computed_Constant_Value_43_U1 = (RR_NAME - Computed_Constant_Value_42_U1);
Constant Computed_Constant_Value_45_U1 = (RR_PERMISSIONS - Computed_Constant_Value_44_U1);
Constant Computed_Constant_Value_47_U1 = (RR_STORAGE - Computed_Constant_Value_46_U1);
Constant Computed_Constant_Value_49_U1 = (RR_KIND - Computed_Constant_Value_48_U1);
Constant Computed_Constant_Value_51_U1 = (RR_HANDLER - Computed_Constant_Value_50_U1);
Constant Computed_Constant_Value_53_U1 = (RR_DESCRIPTION - Computed_Constant_Value_52_U1);
Constant Computed_Constant_Value_54_U1 = (RELS_X_UNIQUE + RELS_Y_UNIQUE);
Constant Computed_Constant_Value_55_U1 = (RELS_EQUIVALENCE + RELS_SYMMETRIC);
Constant Computed_Constant_Value_56_U1 = (RELS_SYMMETRIC + RELS_X_UNIQUE);
Constant Computed_Constant_Value_58_U1 = (RELS_EQUIVALENCE + RELS_SYMMETRIC);
Constant Computed_Constant_Value_62_U1 = (ICOUNT_OBJECT + Computed_Constant_Value_61_U1);
Constant Computed_Constant_Value_15_U1 = (GG_ANYTOSTRING_LEN + Computed_Constant_Value_14_U1);
Constant Computed_Constant_Value_41_U1 = (RE_MAX_PACKETS * RE_PACKET_SIZE);
Constant TEXT_TY_BufferSize = Computed_Constant_Value_2_U1;
Constant GPR_HELD = Computed_Constant_Value_1_U2;
Constant GPR_MULTI = Computed_Constant_Value_3_U1;
Constant GPR_MULTIHELD = Computed_Constant_Value_5_U1;
Constant GPR_MULTIEXCEPT = Computed_Constant_Value_7_U1;
Constant GPR_MULTIINSIDE = Computed_Constant_Value_9_U1;
Constant GPR_CREATURE = Computed_Constant_Value_11_U1;
Constant BLOCKV_STACK_SIZE = Computed_Constant_Value_13_U1;
Constant MAX_MSTACK_FRAME = Computed_Constant_Value_17_U1;
Constant BLK_DATA_OFFSET = Computed_Constant_Value_20_U1;
Constant PACKED_TEXT_STORAGE = Computed_Constant_Value_32_U1;
Constant TEXT_TY_Storage_Flags = Computed_Constant_Value_36_U1;
Constant RE_PACKET_SIZE_IN_BYTES = Computed_Constant_Value_40_U1;
Constant RRV_NAME = Computed_Constant_Value_43_U1;
Constant RRV_PERMISSIONS = Computed_Constant_Value_45_U1;
Constant RRV_STORAGE = Computed_Constant_Value_47_U1;
Constant RRV_KIND = Computed_Constant_Value_49_U1;
Constant RRV_HANDLER = Computed_Constant_Value_51_U1;
Constant RRV_DESCRIPTION = Computed_Constant_Value_53_U1;
Constant RRVAL_O_TO_O = Computed_Constant_Value_54_U1;
Constant RRVAL_EQUIV = Computed_Constant_Value_55_U1;
Constant MAX_ROUTE_LENGTH = Computed_Constant_Value_62_U1;
Constant strong_id_U1 = DK1_phrase_real_number____re;
Constant strong_id_U2 = DK2_phrase_real_number____nu;
Constant Computed_Constant_Value_27_U1 = (Computed_Constant_Value_25_U1 + Computed_Constant_Value_26_U1);
Constant Computed_Constant_Value_30_U1 = (Computed_Constant_Value_28_U1 + Computed_Constant_Value_29_U1);
Constant Computed_Constant_Value_35_U1 = (Computed_Constant_Value_33_U1 + Computed_Constant_Value_34_U1);
Constant Computed_Constant_Value_57_U1 = (Computed_Constant_Value_56_U1 + RELS_Y_UNIQUE);
Constant Computed_Constant_Value_59_U1 = (Computed_Constant_Value_58_U1 + RELS_X_UNIQUE);
Constant strong_id_U3 = DK3_relation_of_values;
Constant strong_id_U4 = DK4_relation_of_objects;
Constant Computed_Constant_Value_18_U1 = (MSTACK_CAPACITY * MAX_MSTACK_FRAME);
Constant CONSTANT_PACKED_TEXT_STORAGE = Computed_Constant_Value_27_U1;
Constant CONSTANT_PERISHABLE_TEXT_STORAGE = Computed_Constant_Value_30_U1;
Constant UNPACKED_TEXT_STORAGE = Computed_Constant_Value_35_U1;
Constant RRVAL_SYM_O_TO_O = Computed_Constant_Value_57_U1;
Constant Computed_Constant_Value_38_U1 = (TEXT_TY_BufferSize + Computed_Constant_Value_37_U1);
Constant MSTACK_SIZE = Computed_Constant_Value_18_U1;
Constant abilities_U6 = (RELS_TEST + RELS_LOOKUP_ANY + RELS_LOOKUP_ALL_X + RELS_LOOKUP_ALL_X + RELS_LIST);
Constant Computed_Constant_Value_60_U1 = (Computed_Constant_Value_59_U1 + RELS_Y_UNIQUE);
Constant Computed_Constant_Value_23_U1 = (BLK_DATA_OFFSET + Computed_Constant_Value_22_U1);
Constant VALENCY_MASK = Computed_Constant_Value_60_U1;
Constant Computed_Constant_Value_39_U1 = (Computed_Constant_Value_38_U1 * TEXT_TY_NoBuffers);
Constant BLK_DATA_MULTI_OFFSET = Computed_Constant_Value_23_U1;
Constant Computed_Constant_Value_24_U1 = (MEMORY_HEAP_SIZE + BLK_DATA_MULTI_OFFSET);
Constant abilities_U3 = (RELS_TEST + RELS_LOOKUP_ANY + RELS_LOOKUP_ALL_X + RELS_LOOKUP_ALL_X + RELS_LIST + RELS_ASSERT_TRUE + RELS_ASSERT_FALSE + RELS_LOOKUP_ANY);
Constant MEANINGLESS_RR = Rel_Record6;
Array A_absent --> [ 2; subterfuge_1; 1; "<nameless>"; NULL; ];
Array A_animate --> [ 2; subterfuge_2; 1; "<nameless>"; NULL; ];
Array A_clothing --> [ 2; subterfuge_3; 1; "<nameless>"; NULL; ];
Array A_concealed --> [ 2; subterfuge_4; 1; "<nameless>"; NULL; ];
Array A_container --> [ 2; subterfuge_5; 1; "<nameless>"; NULL; ];
Array A_door --> [ 2; subterfuge_6; 1; "<nameless>"; NULL; ];
Array A_edible --> [ 2; subterfuge_7; 1; "<nameless>"; NULL; ];
Array A_enterable --> [ 2; subterfuge_8; 1; "<nameless>"; NULL; ];
Array A_light --> [ 2; subterfuge_9; 1; "<nameless>"; NULL; ];
Array A_lockable --> [ 2; subterfuge_10; 1; "<nameless>"; NULL; ];
Array A_locked --> [ 2; subterfuge_11; 1; "<nameless>"; NULL; ];
Array A_moved --> [ 2; subterfuge_12; 1; "<nameless>"; NULL; ];
Array A_on --> [ 2; subterfuge_13; 1; "<nameless>"; NULL; ];
Array A_open --> [ 2; subterfuge_14; 1; "<nameless>"; NULL; ];
Array A_openable --> [ 2; subterfuge_15; 1; "<nameless>"; NULL; ];
Array A_scenery --> [ 2; subterfuge_16; 1; "<nameless>"; NULL; ];
Array A_static --> [ 2; subterfuge_17; 1; "<nameless>"; NULL; ];
Array A_supporter --> [ 2; subterfuge_18; 1; "<nameless>"; NULL; ];
Array A_switchable --> [ 2; subterfuge_19; 1; "<nameless>"; NULL; ];
Array A_talkable --> [ 2; subterfuge_20; 1; "<nameless>"; NULL; ];
Array A_transparent --> [ 2; subterfuge_21; 1; "<nameless>"; NULL; ];
Array A_visited --> [ 2; subterfuge_22; 1; "<nameless>"; NULL; ];
Array A_worn --> [ 2; subterfuge_23; 1; "<nameless>"; NULL; ];
Array A_male --> [ 2; subterfuge_24; 1; "<nameless>"; NULL; ];
Array A_female --> [ 2; subterfuge_25; 1; "<nameless>"; NULL; ];
Array A_neuter --> [ 2; subterfuge_26; 1; "<nameless>"; NULL; ];
Array A_pluralname --> [ 2; subterfuge_27; 1; "plural-named"; K0_kind; NULL; ];
Array A_ambigpluralname --> [ 2; subterfuge_28; 1; "ambiguously plural"; K0_kind; NULL; ];
Array A_proper --> [ 2; subterfuge_29; 1; "proper-named"; K0_kind; NULL; ];
Array A_remove_proper --> [ 2; subterfuge_30; 1; "<nameless>"; NULL; ];
Array A_privately_named --> [ 2; subterfuge_31; 1; "<nameless>"; NULL; ];
Array A_mentioned --> [ 2; subterfuge_32; 1; "<nameless>"; NULL; ];
Array A_pushable --> [ 2; subterfuge_33; 1; "<nameless>"; NULL; ];
Array A_mark_as_room --> [ 2; subterfuge_34; 1; "<nameless>"; NULL; ];
Array A_mark_as_thing --> [ 2; subterfuge_35; 1; "<nameless>"; NULL; ];
Array A_workflag --> [ 2; subterfuge_36; 1; "<nameless>"; NULL; ];
Array A_workflag2 --> [ 2; subterfuge_37; 1; "<nameless>"; NULL; ];
Array A_add_to_scope --> [ 1; subterfuge_38; 0; "<nameless>"; NULL; ];
Array A_article --> [ 1; subterfuge_39; 0; "indefinite article"; K0_kind; NULL; ];
Array A_capacity --> [ 1; subterfuge_40; 0; "<nameless>"; NULL; ];
Array A_component_child --> [ 1; subterfuge_41; 0; "<nameless>"; NULL; ];
Array A_component_parent --> [ 1; subterfuge_42; 0; "<nameless>"; NULL; ];
Array A_component_sibling --> [ 1; subterfuge_43; 0; "<nameless>"; NULL; ];
Array A_description --> [ 1; subterfuge_44; 0; "<nameless>"; NULL; ];
Array A_door_dir --> [ 1; subterfuge_45; 0; "<nameless>"; NULL; ];
Array A_door_to --> [ 1; subterfuge_46; 0; "<nameless>"; NULL; ];
Array A_found_in --> [ 1; subterfuge_47; 0; "<nameless>"; NULL; ];
Array A_initial --> [ 1; subterfuge_48; 0; "<nameless>"; NULL; ];
Array A_list_together --> [ 1; subterfuge_49; 0; "<nameless>"; NULL; ];
Array A_map_region --> [ 1; subterfuge_50; 0; "<nameless>"; NULL; ];
Array A_parse_name --> [ 1; subterfuge_51; 0; "<nameless>"; NULL; ];
Array A_plural --> [ 1; subterfuge_52; 0; "printed plural name"; K0_kind; NULL; ];
Array A_regional_found_in --> [ 1; subterfuge_53; 0; "<nameless>"; NULL; ];
Array A_room_index --> [ 1; subterfuge_54; 0; "<nameless>"; NULL; ];
Array A_short_name --> [ 1; subterfuge_55; 0; "printed name"; K0_kind; NULL; ];
Array A_saved_short_name --> [ 1; subterfuge_56; 0; "<nameless>"; NULL; ];
Array A_vector --> [ 1; subterfuge_57; 0; "vector"; K0_kind; NULL; ];
Array A_with_key --> [ 1; subterfuge_58; 0; "<nameless>"; NULL; ];
Array A_KD_Count --> [ 1; subterfuge_59; 0; "KD_Count"; K0_kind; NULL; ];
Array A_IK1_Count --> [ 1; subterfuge_60; 0; "<nameless>"; NULL; ];
Array A_IK2_Count --> [ 1; subterfuge_61; 0; "<nameless>"; NULL; ];
Array A_IK4_Count --> [ 1; subterfuge_62; 0; "<nameless>"; NULL; ];
Array A_IK5_Count --> [ 1; subterfuge_63; 0; "<nameless>"; NULL; ];
Array A_IK6_Count --> [ 1; subterfuge_64; 0; "<nameless>"; NULL; ];
Array A_IK8_Count --> [ 1; subterfuge_65; 0; "<nameless>"; NULL; ];
Array A_IK3_Count --> [ 1; subterfuge_66; 0; "<nameless>"; NULL; ];
Array A_IK1_link --> [ 1; subterfuge_67; 0; "<nameless>"; NULL; ];
Array A_IK2_link --> [ 1; subterfuge_68; 0; "<nameless>"; NULL; ];
Array A_IK5_link --> [ 1; subterfuge_69; 0; "<nameless>"; NULL; ];
Array A_IK6_link --> [ 1; subterfuge_70; 0; "<nameless>"; NULL; ];
Array A_IK8_link --> [ 1; subterfuge_71; 0; "<nameless>"; NULL; ];
Array A_articles --> [ 1; subterfuge_72; 0; "<nameless>"; NULL; ];
Array A_grammar --> [ 1; subterfuge_73; 0; "<nameless>"; NULL; ];
Array A_inside_description --> [ 1; subterfuge_74; 0; "<nameless>"; NULL; ];
Array A_short_name_indef --> [ 1; subterfuge_75; 0; "<nameless>"; NULL; ];
Array A_P_variable_initial_value --> [ 1; subterfuge_76; 0; "variable initial value"; K0_kind; NULL; ];
Array A_P_specification --> [ 1; subterfuge_77; 0; "specification"; NULL; ];
Array A_P_indefinite_appearance_text --> [ 1; subterfuge_78; 0; "indefinite appearance text"; NULL; ];
Array A_P_adaptive_text_viewpoint --> [ 1; subterfuge_79; 0; "adaptive text viewpoint"; NULL; ];
Array A_P_text_file --> [ 1; subterfuge_80; 0; "text file"; NULL; ];
Array A_P_heading --> [ 1; subterfuge_81; 0; "heading"; NULL; ];
Array Rel_Record1 --> [ 0; 101515264; RELATION_TY; MAX_POSITIVE_NUMBER; NULL; NULL; "equality relation"; abilities_U1; 0; DK3_relation_of_values; call_U7; "is"; ];
Array Rel_Record2 --> [ 0; 101515264; RELATION_TY; MAX_POSITIVE_NUMBER; NULL; NULL; "meaning relation"; abilities_U2; 0; DK4_relation_of_objects; call_U8; "means"; ];
Array Rel_Record3 --> [ 0; 101515264; RELATION_TY; MAX_POSITIVE_NUMBER; NULL; NULL; "possession relation"; abilities_U3; 0; DK4_relation_of_objects; call_U9; "has"; ];
Array Rel_Record4 --> [ 0; 101515264; RELATION_TY; MAX_POSITIVE_NUMBER; NULL; NULL; "universal relation"; abilities_U4; 0; DK4_relation_of_objects; call_U10; "relates"; ];
Array Rel_Record5 --> [ 0; 101515264; RELATION_TY; MAX_POSITIVE_NUMBER; NULL; NULL; "provision relation"; abilities_U5; 0; DK4_relation_of_objects; call_U11; "provides"; ];
Array Rel_Record6 --> [ 0; 101515264; RELATION_TY; MAX_POSITIVE_NUMBER; NULL; NULL; "never-holding relation"; abilities_U6; 0; DK3_relation_of_values; call_U12; "is"; ];
Array bc_U1 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U2 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U3 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array DK1_phrase_real_number____re --> [ PHRASE_TY; 2; REAL_NUMBER_TY; ];
Array DK2_phrase_real_number____nu --> [ PHRASE_TY; 2; NUMBER_TY; ];
Array DK3_relation_of_values --> [ RELATION_TY; 2; VALUE_TY; VALUE_TY; ];
Array DK4_relation_of_objects --> [ RELATION_TY; 2; OBJECT_TY; OBJECT_TY; ];
Array Activity_after_rulebooks --> [ rulebook_id_U5; rulebook_id_U8; rulebook_id_U11; ];
Array Activity_atb_rulebooks -> [ 0; 0; 0; ];
Array Activity_before_rulebooks --> [ rulebook_id_U3; rulebook_id_U6; rulebook_id_U9; ];
Array Activity_for_rulebooks --> [ rulebook_id_U4; rulebook_id_U7; rulebook_id_U10; ];
Array activity_var_creators --> [ 0; 0; 0; ];
Array TimedEventsTable table [ 0; 0; ];
Array TimedEventTimesTable table [ 0; 0; ];
Array PastActionsI6Routines --> [ 0; 0; ];
Array TableOfVerbs --> [ call_U125; call_U126; call_U127; call_U128; call_U129; call_U130; call_U131; call_U132; call_U133; call_U134; call_U135; call_U136; call_U137; call_U138; call_U139; call_U140; call_U141; call_U142; call_U143; call_U160; call_U161; call_U162; call_U163; call_U164; call_U165; call_U1; call_U2; call_U3; call_U4; call_U5; call_U6; 0; ];
Array KindHierarchy --> [ 0; 0; ];
Array ResourceIDsOfFigures --> [ 0; 0; ];
Array ResourceIDsOfSounds --> [ 0; 0; ];
Array TableOfExternalFiles --> [ 0; file_file_of_observations_U1; 0; ];
Array RulebookNames --> [ "Startup rulebook"; "Shutdown rulebook"; "before starting the virtual machine rulebook"; "for starting the virtual machine rulebook"; "after starting the virtual machine rulebook"; "before printing the name rulebook"; "for printing the name rulebook"; "after printing the name rulebook"; "before printing the plural name rulebook"; "for printing the plural name rulebook"; "after printing the plural name rulebook"; ];
Array rulebook_var_creators --> [ 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; ];
Array rulebooks_array --> [ call_U105; call_U106; call_U107; call_U108; call_U109; call_U110; call_U111; call_U112; call_U113; call_U114; call_U115; 0; ];
Array ResponseTexts --> [ 0; 0; ];
Array ResponseDivisions --> [ 0; 0; 0; ];
Array TableOfTables --> [ TheEmptyTable; 0; 0; ];
Array TB_Blanks -> [ 0; 0; ];
Array closure_data_U1 --> [ DK1_phrase_real_number____re; call_U121; "rsqr function"; ];
Array closure_data_U2 --> [ DK1_phrase_real_number____re; call_U122; "arcsinh function"; ];
Array closure_data_U3 --> [ DK1_phrase_real_number____re; call_U123; "arccosh function"; ];
Array closure_data_U4 --> [ DK1_phrase_real_number____re; call_U124; "arctanh function"; ];
Array closure_data_U5 --> [ DK1_phrase_real_number____re; REAL_NUMBER_TY_Abs; "abs function"; ];
Array closure_data_U6 --> [ DK1_phrase_real_number____re; REAL_NUMBER_TY_Root; "root function"; ];
Array closure_data_U7 --> [ DK1_phrase_real_number____re; REAL_NUMBER_TY_Ceiling; "ceiling function"; ];
Array closure_data_U8 --> [ DK1_phrase_real_number____re; REAL_NUMBER_TY_Floor; "floor function"; ];
Array closure_data_U9 --> [ DK2_phrase_real_number____nu; REAL_NUMBER_TY_to_NUMBER_TY; "int function"; ];
Array closure_data_U10 --> [ DK1_phrase_real_number____re; REAL_NUMBER_TY_Log; "log function"; ];
Array closure_data_U11 --> [ DK1_phrase_real_number____re; REAL_NUMBER_TY_Exp; "exp function"; ];
Array closure_data_U12 --> [ DK1_phrase_real_number____re; REAL_NUMBER_TY_Sin; "sin function"; ];
Array closure_data_U13 --> [ DK1_phrase_real_number____re; REAL_NUMBER_TY_Cos; "cos function"; ];
Array closure_data_U14 --> [ DK1_phrase_real_number____re; REAL_NUMBER_TY_Tan; "tan function"; ];
Array closure_data_U15 --> [ DK1_phrase_real_number____re; REAL_NUMBER_TY_Arcsin; "arcsin function"; ];
Array closure_data_U16 --> [ DK1_phrase_real_number____re; REAL_NUMBER_TY_Arccos; "arccos function"; ];
Array closure_data_U17 --> [ DK1_phrase_real_number____re; REAL_NUMBER_TY_Arctan; "arctan function"; ];
Array closure_data_U18 --> [ DK1_phrase_real_number____re; REAL_NUMBER_TY_Sinh; "sinh function"; ];
Array closure_data_U19 --> [ DK1_phrase_real_number____re; REAL_NUMBER_TY_Cosh; "cosh function"; ];
Array closure_data_U20 --> [ DK1_phrase_real_number____re; REAL_NUMBER_TY_Tanh; "tanh function"; ];
Array bc_U4 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U1; ];
Array bc_U5 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array ts_array_U1 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U171; ];
Array ts_array_U2 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U172; ];
Array ts_array_U3 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U173; ];
Array file_file_of_observations_U1 --> [ AUXF_MAGIC_VALUE; AUXF_STATUS_IS_CLOSED; 0; 0; "notebook"; UUID_ARRAY; ];
Array LocalParking --> [ 0; 0; ];
Array UUID_ARRAY -> [ 45; 'U'; 'U'; 'I'; 'D'; ':'; '/'; '/'; '1'; '1'; 'E'; 'A'; '6'; '3'; 'D'; '6'; '-'; 'C'; 'B'; '9'; 'E'; '-'; '4'; '9'; '0'; '9'; '-'; '8'; '4'; 'C'; 'D'; '-'; 'F'; '1'; 'A'; '5'; 'A'; 'D'; '1'; '1'; '3'; 'C'; '0'; '8'; '/'; '/'; ];
Array PowersOfTwo_TB --> [ 2048; 1024; 512; 256; 128; 64; 32; 16; 8; 4; 2; 1; ];
Array IncreasingPowersOfTwo_TB --> [ 1; 2; 4; 8; 16; 32; 64; 128; 256; 512; 1024; 2048; 4096; 8192; 16384; 32768; ];
Array EMPTY_TEXT_VALUE --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array TheEmptyTable --> [ 0; 0; ];
Array blockv_stack --> 2048; ! blank with extent 2048
Array Protect_I7_Arrays --> [ 16339; 12345; ];
Array I7_SOO_SHUF -> 32; ! blank with extent 32
Array gg_event --> 4; ! blank with extent 4
Array gg_arguments buffer 28; ! blank with extent 28
Array buffer buffer 260; ! blank with extent 260
Array buffer2 buffer 260; ! blank with extent 260
Array buffer3 buffer 260; ! blank with extent 260
Array parse --> 61; ! blank with extent 61
Array parse2 --> 61; ! blank with extent 61
Array gg_tokenbuf -> 9; ! blank with extent 9
Array AnyToStrArr -> 67; ! blank with extent 67
Array PowersOfTen --> [ 1; 10; 100; 1000; 10000; 100000; 1000000; 10000000; 100000000; 1000000000; ];
Array CheckTableEntryIsBlank_LU -> [ 1; 2; 4; 8; 16; 32; 64; 128; ];
Array CheckTableEntryIsNonBlank_LU -> [ 254; 253; 251; 247; 239; 223; 191; 127; ];
Array MStack --> 40; ! blank with extent 40
Array latest_rule_result --> 3; ! blank with extent 3
Array Flex_Heap -> 32788; ! blank with extent 32788
Array TEXT_TY_Buffers --> 2058; ! blank with extent 2058
Array CharCasingChart0 --> [ 97; 26; -32; 170; 1; UNIC_NCT; 181; 1; 743; 186; 1; UNIC_NCT; 223; 1; UNIC_NCT; 224; 23; -32; 248; 7; -32; 255; 1; 121; 257; -47; -1; 305; 1; -232; 307; -5; -1; 312; 1; UNIC_NCT; 314; -15; -1; 329; 1; UNIC_NCT; 331; -45; -1; 378; -5; -1; 383; 1; -300; 384; 1; UNIC_NCT; 387; -3; -1; 392; 1; -1; 396; 1; -1; 397; 1; UNIC_NCT; 402; 1; -1; 405; 1; 97; 409; 1; -1; 410; 2; UNIC_NCT; 414; 1; 130; 417; -5; -1; 424; 1; -1; 426; 2; UNIC_NCT; 429; 1; -1; 432; 1; -1; 436; -3; -1; 441; 1; -1; 442; 1; UNIC_NCT; 445; 1; -1; 446; 1; UNIC_NCT; 447; 1; 56; 454; 1; -2; 457; 1; -2; 460; 1; -2; 462; -15; -1; 477; 1; -79; 479; -17; -1; 496; 1; UNIC_NCT; 499; 1; -2; 501; 1; -1; 505; -39; -1; 545; 1; UNIC_NCT; 547; -17; -1; 564; 3; UNIC_NCT; 592; 3; UNIC_NCT; 595; 1; -210; 596; 1; -206; 597; 1; UNIC_NCT; 598; 2; -205; 600; 1; UNIC_NCT; 601; 1; -202; 602; 1; UNIC_NCT; 603; 1; -203; 604; 4; UNIC_NCT; 608; 1; -205; 609; 2; UNIC_NCT; 611; 1; -207; 612; 4; UNIC_NCT; 616; 1; -209; 617; 1; -211; 618; 5; UNIC_NCT; 623; 1; -211; 624; 2; UNIC_NCT; 626; 1; -213; 627; 2; UNIC_NCT; 629; 1; -214; 630; 10; UNIC_NCT; 640; 1; -218; 641; 2; UNIC_NCT; 643; 1; -218; 644; 4; UNIC_NCT; 648; 1; -218; 649; 1; UNIC_NCT; 650; 2; -217; 652; 6; UNIC_NCT; 658; 1; -219; 659; 29; UNIC_NCT; 912; 1; UNIC_NCT; 940; 1; -38; 941; 3; -37; 944; 1; UNIC_NCT; 945; 17; -32; 962; 1; -31; 963; 9; -32; 972; 1; -64; 973; 2; -63; 976; 1; -62; 977; 1; -57; 981; 1; -47; 982; 1; -54; 983; 1; UNIC_NCT; 985; -23; -1; 1008; 1; -86; 1009; 1; -80; 1010; 1; 7; 1011; 1; UNIC_NCT; 1013; 1; -96; 1016; 1; -1; 1019; 1; -1; 1072; 32; -32; 1104; 16; -80; 1121; -33; -1; 1163; -53; -1; 1218; -13; -1; 1233; -37; -1; 1273; 1; -1; 1281; -15; -1; 1377; 38; -48; 1415; 1; UNIC_NCT; 7424; 44; UNIC_NCT; 7522; 10; UNIC_NCT; 7681; -149; -1; 7830; 5; UNIC_NCT; 7835; 1; -59; 7841; -89; -1; 7936; 8; 8; 7952; 6; 8; 7968; 8; 8; 7984; 8; 8; 8000; 6; 8; 8016; 1; UNIC_NCT; 8017; 1; 8; 8018; 1; UNIC_NCT; 8019; 1; 8; 8020; 1; UNIC_NCT; 8021; 1; 8; 8022; 1; UNIC_NCT; 8023; 1; 8; 8032; 8; 8; 8048; 2; 74; 8050; 4; 86; 8054; 2; 100; 8056; 2; 128; 8058; 2; 112; 8060; 2; 126; 8064; 8; 8; 8080; 8; 8; 8096; 8; 8; 8112; 2; 8; 8114; 1; UNIC_NCT; 8115; 1; 9; 8116; -3; UNIC_NCT; 8119; 1; UNIC_NCT; 8126; 1; -7205; 8130; 1; UNIC_NCT; 8131; 1; 9; 8132; -3; UNIC_NCT; 8135; 1; UNIC_NCT; 8144; 2; 8; 8146; 2; UNIC_NCT; 8150; 2; UNIC_NCT; 8160; 2; 8; 8162; 3; UNIC_NCT; 8165; 1; 7; 8166; 2; UNIC_NCT; 8178; 1; UNIC_NCT; 8179; 1; 9; 8180; -3; UNIC_NCT; 8183; 1; UNIC_NCT; 8305; 1; UNIC_NCT; 8319; 1; UNIC_NCT; 8458; 1; UNIC_NCT; 8462; 2; UNIC_NCT; 8467; 1; UNIC_NCT; 8495; 1; UNIC_NCT; 8500; 1; UNIC_NCT; 8505; 1; UNIC_NCT; 8509; 1; UNIC_NCT; 8518; 4; UNIC_NCT; 64256; 7; UNIC_NCT; 64275; 5; UNIC_NCT; 65345; 26; -32; 0; ];
Array CharCasingChart1 --> [ 65; 26; 32; 192; 23; 32; 216; 7; 32; 256; -47; 1; 304; 1; -199; 306; -5; 1; 313; -15; 1; 330; -45; 1; 376; 1; -121; 377; -5; 1; 385; 1; 210; 386; -3; 1; 390; 1; 206; 391; 1; 1; 393; 2; 205; 395; 1; 1; 398; 1; 79; 399; 1; 202; 400; 1; 203; 401; 1; 1; 403; 1; 205; 404; 1; 207; 406; 1; 211; 407; 1; 209; 408; 1; 1; 412; 1; 211; 413; 1; 213; 415; 1; 214; 416; -5; 1; 422; 1; 218; 423; 1; 1; 425; 1; 218; 428; 1; 1; 430; 1; 218; 431; 1; 1; 433; 2; 217; 435; -3; 1; 439; 1; 219; 440; 1; 1; 444; 1; 1; 452; 1; 2; 455; 1; 2; 458; 1; 2; 461; -15; 1; 478; -17; 1; 497; 1; 2; 500; 1; 1; 502; 1; -97; 503; 1; -56; 504; -39; 1; 544; 1; -130; 546; -17; 1; 902; 1; 38; 904; 3; 37; 908; 1; 64; 910; 2; 63; 913; 17; 32; 931; 9; 32; 978; 3; UNIC_NCT; 984; -23; 1; 1012; 1; -60; 1015; 1; 1; 1017; 1; -7; 1018; 1; 1; 1024; 16; 80; 1040; 32; 32; 1120; -33; 1; 1162; -53; 1; 1216; 1; UNIC_NCT; 1217; -13; 1; 1232; -37; 1; 1272; 1; 1; 1280; -15; 1; 1329; 38; 48; 4256; 38; UNIC_NCT; 7680; -149; 1; 7840; -89; 1; 7944; 8; -8; 7960; 6; -8; 7976; 8; -8; 7992; 8; -8; 8008; 6; -8; 8025; -7; -8; 8040; 8; -8; 8120; 2; -8; 8122; 2; -74; 8136; 4; -86; 8152; 2; -8; 8154; 2; -100; 8168; 2; -8; 8170; 2; -112; 8172; 1; -7; 8184; 2; -128; 8186; 2; -126; 8450; 1; UNIC_NCT; 8455; 1; UNIC_NCT; 8459; 3; UNIC_NCT; 8464; 3; UNIC_NCT; 8469; 1; UNIC_NCT; 8473; 5; UNIC_NCT; 8484; 1; UNIC_NCT; 8486; 1; -7517; 8488; 1; UNIC_NCT; 8490; 1; -8383; 8491; 1; -8262; 8492; 2; UNIC_NCT; 8496; 2; UNIC_NCT; 8499; 1; UNIC_NCT; 8510; 2; UNIC_NCT; 8517; 1; UNIC_NCT; 65313; 26; 32; 0; ];
Array RE_PACKET_space --> 448; ! blank with extent 448
Array RE_Subexpressions --> 11; ! blank with extent 11
Array Allocated_Match_Vars --> 10; ! blank with extent 10
Array Subexp_Posns --> 20; ! blank with extent 20
Array RTP_Buffer --> [ -1; 0; 0; 0; 0; 0; 0; ];
Array LanguagePronouns table [ 'it'; 568; NULL; 'him'; 2048; NULL; 'her'; 1024; NULL; 'them'; 455; NULL; ];
Array LanguageDescriptors table [ 'my'; 4095; POSSESS_PK; 0; 'this'; 4095; POSSESS_PK; 0; 'these'; 455; POSSESS_PK; 0; 'that'; 4095; POSSESS_PK; 1; 'those'; 455; POSSESS_PK; 1; 'his'; 4095; POSSESS_PK; 'him'; 'her'; 4095; POSSESS_PK; 'her'; 'their'; 4095; POSSESS_PK; 'them'; 'its'; 4095; POSSESS_PK; 'it'; 'the'; 4095; DEFART_PK; NULL; 'a//'; 3640; INDEFART_PK; NULL; 'an'; 3640; INDEFART_PK; NULL; 'some'; 455; INDEFART_PK; NULL; 'lit'; 4095; LIGHTED_PK; NULL; 'lighted'; 4095; LIGHTED_PK; NULL; 'unlit'; 4095; UNLIGHTED_PK; NULL; ];
Array LanguageNumbers table [ 'one'; 1; 'two'; 2; 'three'; 3; 'four'; 4; 'five'; 5; 'six'; 6; 'seven'; 7; 'eight'; 8; 'nine'; 9; 'ten'; 10; 'eleven'; 11; 'twelve'; 12; 'thirteen'; 13; 'fourteen'; 14; 'fifteen'; 15; 'sixteen'; 16; 'seventeen'; 17; 'eighteen'; 18; 'nineteen'; 19; 'twenty'; 20; 'twenty-one'; 21; 'twenty-two'; 22; 'twenty-three'; 23; 'twenty-four'; 24; 'twenty-five'; 25; 'twenty-six'; 26; 'twenty-seven'; 27; 'twenty-eight'; 28; 'twenty-nine'; 29; 'thirty'; 30; ];
Array LanguageArticles --> [ "The "; "the "; "a "; "The "; "the "; "an "; "The "; "the "; "some "; "The "; "the "; "some "; ];
Array LanguageGNAsToArticles --> [ 0; 0; 0; 1; 1; 1; 0; 0; 0; 1; 1; 1; ];
Array StorageForShortName buffer 250; ! blank with extent 250
Array activities_stack --> 20; ! blank with extent 20
Array activity_parameters_stack --> 20; ! blank with extent 20
Array KOVP_0 table [ 0; 0; I_first_person_plural_U1; I_first_person_singular_U1; I_first_person_singular_U1; I_first_person_singular_U1; I_first_person_singular_U1; I_first_person_singular_U1; ];
Array KOVP_1 table [ 0; 0; I_file_of_observations_U1; ];
Array KOVP_2 table [ 0; 0; bc_U4; ];
Array value_ranges --> 0 0 6 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0;
Array value_property_holders --> 0 0 VPH_2 0 0 0 0 VPH_7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0;
Class K0_kind
    has ~pluralname
    has ~proper
    with short_name bc_U1
    with plural bc_U2
    with article bc_U3
    has ~ambigpluralname
;
Object VPH_2    with P_adaptive_text_viewpoint KOVP_0
;
Object VPH_7    with P_text_file KOVP_1
    with P_heading KOVP_2
;
#ifndef P_variable_initial_value; Constant P_variable_initial_value = 0; #endif;
#ifndef P_specification; Constant P_specification = 0; #endif;
#ifndef P_indefinite_appearance_text; Constant P_indefinite_appearance_text = 0; #endif;
#ifndef P_adaptive_text_viewpoint; Constant P_adaptive_text_viewpoint = 0; #endif;
#ifndef P_text_file; Constant P_text_file = 0; #endif;
#ifndef P_heading; Constant P_heading = 0; #endif;
#Ifdef TARGET_ZCODE;
Global max_z_object;
#Ifdef Z__Region;
[ OC__Cl obj cla j a n objflag;
    @jl obj 1 ?NotObj;
    @jg obj max_z_object ?NotObj;
    @inc objflag;
    #Ifdef K1_room;
    @je cla K1_room ?~NotRoom;
    @test_attr obj mark_as_room ?rtrue;
    @rfalse;
    .NotRoom;
    #Endif;
    #Ifdef K2_thing;
    @je cla K2_thing ?~NotObj;
    @test_attr obj mark_as_thing ?rtrue;
    @rfalse;
    #Endif;
    .NotObj;

    @je cla Object Class ?ObjOrClass;
    @je cla Routine String ?RoutOrStr;

    @jin cla 1 ?~Mistake;

    @jz objflag ?rfalse;
    @get_prop_addr obj 2 -> a;
    @jz a ?rfalse;
    @get_prop_len a -> n;

    @div n 2 -> n;
    .Loop;
    @loadw a j -> sp;
    @je sp cla ?rtrue;
    @inc j;
    @jl j n ?Loop;
    @rfalse;

    .ObjOrClass;
    @jz objflag ?rfalse;
    @je cla Object ?JustObj;

    ! So now cla is Class
    @jg obj String ?~rtrue;
    @jin obj Class ?rtrue;
    @rfalse;

    .JustObj;
    ! So now cla is Object
    @jg obj String ?~rfalse;
    @jin obj Class ?rfalse;
    @rtrue;

    .RoutOrStr;
    @jz objflag ?~rfalse;
    @call_2s Z__Region obj -> sp;
    @inc sp;
    @je sp cla ?rtrue;
    @rfalse;

    .Mistake;
    RT__Err("apply 'ofclass' for", cla, -1);
    rfalse;
];
#Endif;
#Endif;
[ ConjugateVerb1 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return Rel_Record1;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ call_U1 fn vp t modal_to;
    (t = ConjugateVerb1(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return Rel_Record1;
    }
];
[ ConjugateModalVerb1 fn vp t modal_to;
    switch (fn) {
        1:
            print "auxiliary-have";
            ;
        2:
            print "had";
            ;
        3:
            print "having";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "has";
                    } else {
                        print "have";
                    }
                    ;
                2:
                    print "had";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "has not";
                    } else {
                        print "have not";
                    }
                    ;
                2:
                    print "had not";
                    ;
            }
            ;
    }
];
[ ConjugateVerb2 fn vp t modal_to;
    switch (fn) {
        1:
            print "mean";
            ;
        2:
            print "meant";
            ;
        3:
            print "meaning";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return Rel_Record2;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "means";
                    } else {
                        print "mean";
                    }
                    ;
                2:
                    print "meant";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has meant";
                    } else {
                        print "have meant";
                    }
                    ;
                4:
                    print "had meant";
                    ;
                5:
                    print "will mean";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not mean";
                    } else {
                        print "do not mean";
                    }
                    ;
                2:
                    print "did not mean";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not meant";
                    } else {
                        print "have not meant";
                    }
                    ;
                4:
                    print "had not meant";
                    ;
                5:
                    print "will not mean";
                    ;
            }
            ;
    }
];
[ call_U2 fn vp t modal_to;
    (t = ConjugateVerb2(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb3 fn vp t modal_to;
    switch (fn) {
        1:
            print "do";
            ;
        2:
            print "done";
            ;
        3:
            print "doing";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does";
                    } else {
                        print "do";
                    }
                    ;
                2:
                    print "did";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has done";
                    } else {
                        print "have done";
                    }
                    ;
                4:
                    print "had done";
                    ;
                5:
                    print "will do";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not";
                    } else {
                        print "do not";
                    }
                    ;
                2:
                    print "did not";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not done";
                    } else {
                        print "have not done";
                    }
                    ;
                4:
                    print "had not done";
                    ;
                5:
                    print "will not do";
                    ;
            }
            ;
    }
];
[ call_U3 fn vp t modal_to;
    (t = ConjugateVerb3(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ call_U4 fn vp t modal_to;
    (t = ConjugateVerb3(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ call_U5 fn vp t modal_to;
    (t = ConjugateVerb3(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ call_U6 fn vp t modal_to;
    (t = ConjugateVerb3(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ call_U7 rr task X Y Z1 Z2 Z3 Z4;
    switch (task) {
        RELS_TEST:
            if ((X == Y)) {
                rtrue;
            }
            rfalse;
            ;
        default:
            RunTimeProblem(RTP_RELMINIMAL, task, 0, Rel_Record1);
            ;
    }
    rfalse;
];
[ call_U8 rr task X Y Z1 Z2 Z3 Z4;
    switch (task) {
        RELS_TEST:
            if ((BlkValueCompare((X)(CV_MEANING), Y) == 0)) {
                rtrue;
            }
            rfalse;
            ;
        default:
            RunTimeProblem(RTP_RELMINIMAL, task, 0, Rel_Record2);
            ;
    }
    rfalse;
];
[ call_U9 rr task X Y Z1 Z2 Z3 Z4;
    switch (task) {
        RELS_TEST:
            if ((X == OwnerOf(Y))) {
                rtrue;
            }
            rfalse;
            ;
        RELS_LOOKUP_ANY:
            if ((((Y == RLANY_GET_X)) || ((Y == RLANY_CAN_GET_X)))) {
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                rfalse;
            } else {
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                rfalse;
            }
            ;
        RELS_LOOKUP_ALL_X:
            LIST_OF_TY_SetLength(Y, 0);
            return Y;
            ;
        RELS_LOOKUP_ALL_Y:
            LIST_OF_TY_SetLength(Y, 0);
            return Y;
            ;
        RELS_LIST:
            LIST_OF_TY_SetLength(X, 0);
            if ((Y == RLIST_ALL_X)) {
            } else {
                if ((Y == RLIST_ALL_Y)) {
                }
            }
            return X;
            ;
        RELS_ASSERT_TRUE:
            MoveObject(Y, X);
            rtrue;
            ;
        RELS_ASSERT_FALSE:
            rfalse;
            ;
    }
    rfalse;
];
[ call_U10 rr task X Y Z1 Z2 Z3 Z4;
    switch (task) {
        RELS_TEST:
            if ((RlnGetF(X, RR_HANDLER))(X,RELS_TEST,Y,0)) {
                rtrue;
            }
            rfalse;
            ;
        default:
            RunTimeProblem(RTP_RELMINIMAL, task, 0, Rel_Record4);
            ;
    }
    rfalse;
];
[ call_U11 rr task X Y Z1 Z2 Z3 Z4;
    switch (task) {
        RELS_TEST:
            if (0) {
                rtrue;
            }
            rfalse;
            ;
        default:
            RunTimeProblem(RTP_RELMINIMAL, task, 0, Rel_Record5);
            ;
    }
    rfalse;
];
[ call_U12 rr task X Y Z1 Z2 Z3 Z4;
    switch (task) {
        RELS_TEST:
            if (0) {
                rtrue;
            }
            rfalse;
            ;
        RELS_LOOKUP_ANY:
            if ((((Y == RLANY_GET_X)) || ((Y == RLANY_CAN_GET_X)))) {
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                rfalse;
            } else {
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                rfalse;
            }
            ;
        RELS_LOOKUP_ALL_X:
            LIST_OF_TY_SetLength(Y, 0);
            return Y;
            ;
        RELS_LOOKUP_ALL_Y:
            LIST_OF_TY_SetLength(Y, 0);
            return Y;
            ;
        RELS_LIST:
            LIST_OF_TY_SetLength(X, 0);
            if ((Y == RLIST_ALL_X)) {
            } else {
                if ((Y == RLIST_ALL_Y)) {
                }
            }
            return X;
            ;
    }
    rfalse;
];
[ call_U13 sk;
    rfalse;
];
[ call_U14 sk;
    rfalse;
];
[ call_U16 sk;
    rfalse;
];
[ call_U18 sk;
    rfalse;
];
[ call_U19 sk;
    return BlkValueCreate(sk);
];
[ call_U20 sk;
    return 101;
];
[ call_U21 sk;
    return 32;
];
[ call_U22 sk;
    rfalse;
];
[ call_U23 sk;
    rfalse;
];
[ call_U24 sk;
    rfalse;
];
[ call_U25 sk;
    return TheEmptyTable;
];
[ call_U26 sk;
    rfalse;
];
[ RulebookOutcomePrintingRule nro;
    if ((nro == 0)) {
        print "(no outcome)";
    } else {
        print (string) nro;
        rfalse;
    }
];
[ call_U27 sk;
    return outcome_allow_startup_U1;
];
[ call_U28 sk;
    return I_file_of_observations_U1;
];
[ PrintExternalFileName value;
    switch (value) {
        I_file_of_observations_U1:
            print "file of Observations";
            ;
        default:
            print "<illegal external file>";
            ;
    }
];
[ call_U29 x;
    return x;
];
[ call_U30 x;
    return x;
];
[ call_U31 a b;
    if ((((a == 0)) && ((b == 0)))) {
        return random(1);
    }
    if ((a == b)) {
        return b;
    }
    if ((a > b)) {
        return (b + (random(MAX_POSITIVE_NUMBER)%((a - b) + 1)));
    }
    return (a + (random(MAX_POSITIVE_NUMBER)%((b - a) + 1)));
];
[ call_U32 sk;
    return BlkValueCreate(sk);
];
[ call_U33 sk;
    rfalse;
];
[ call_U34 sk;
    rfalse;
];
[ DB_Action_Details act n s for_say;
    switch (act) {
    }
];
[ TestSinglePastState past_flag pt turn_end wanted old new trips consecutives;
    rfalse;
];
[ ShowExtensionVersions;
];
[ ShowFullExtensionVersions;
    print "Basic Inform version 1 by Graham Nelson^";
    print "English Language version 1 by Graham Nelson^";
];
[ ShowOneExtension id;
    if ((id == 1)) {
        print "Basic Inform version 1 by Graham Nelson";
    }
    if ((id == 2)) {
        print "English Language version 1 by Graham Nelson";
    }
];
[ ShowMeInstanceDetails which na t_0;
    return na;
];
[ DefaultValueOfKOV sk k;
    (k = KindAtomic(sk));
    switch (k) {
        WEAK_ID_39:
            return call_U116(sk);
            ;
        WEAK_ID_40:
            return call_U144(sk);
            ;
        WEAK_ID_41:
            return call_U148(sk);
            ;
        WEAK_ID_42:
            return call_U152(sk);
            ;
        WEAK_ID_43:
            return call_U156(sk);
            ;
        WEAK_ID_44:
            return call_U166(sk);
            ;
        OBJECT_TY:
            return call_U13(sk);
            ;
        NUMBER_TY:
            return call_U14(sk);
            ;
        REAL_NUMBER_TY:
            return call_U16(sk);
            ;
        TRUTH_STATE_TY:
            return call_U18(sk);
            ;
        TEXT_TY:
            return call_U19(sk);
            ;
        SNIPPET_TY:
            return call_U20(sk);
            ;
        UNICODE_CHARACTER_TY:
            return call_U21(sk);
            ;
        USE_OPTION_TY:
            return call_U22(sk);
            ;
        RESPONSE_TY:
            return call_U23(sk);
            ;
        VERB_TY:
            return call_U24(sk);
            ;
        TABLE_TY:
            return call_U25(sk);
            ;
        EQUATION_TY:
            return call_U26(sk);
            ;
        RULEBOOK_OUTCOME_TY:
            return call_U27(sk);
            ;
        EXTERNAL_FILE_TY:
            return call_U28(sk);
            ;
        LIST_OF_TY:
            return call_U32(sk);
            ;
        NIL_TY:
            return call_U33(sk);
            ;
        VOID_TY:
            return call_U34(sk);
            ;
    }
    rfalse;
];
[ DefaultValueFinder k;
    rfalse;
];
[ PrintKindValuePair k v;
    (k = KindAtomic(k));
    switch (k) {
        WEAK_ID_39:
            E1(v);
            ;
        WEAK_ID_40:
            E2(v);
            ;
        WEAK_ID_41:
            E3(v);
            ;
        WEAK_ID_42:
            E4(v);
            ;
        WEAK_ID_43:
            E5(v);
            ;
        WEAK_ID_44:
            E6(v);
            ;
        OBJECT_TY:
            PrintShortName(v);
            ;
        NUMBER_TY:
            DecimalNumber(v);
            ;
        REAL_NUMBER_TY:
            REAL_NUMBER_TY_Say(v);
            ;
        TRUTH_STATE_TY:
            DA_TruthState(v);
            ;
        TEXT_TY:
            TEXT_TY_Say(v);
            ;
        SNIPPET_TY:
            PrintSnippet(v);
            ;
        UNICODE_CHARACTER_TY:
            DecimalNumber(v);
            ;
        USE_OPTION_TY:
            PrintUseOption(v);
            ;
        RESPONSE_TY:
            PrintResponse(v);
            ;
        VERB_TY:
            PrintVerbAsValue(v);
            ;
        TABLE_TY:
            PrintTableName(v);
            ;
        EQUATION_TY:
            DA_Number(v);
            ;
        RULEBOOK_OUTCOME_TY:
            RulebookOutcomePrintingRule(v);
            ;
        EXTERNAL_FILE_TY:
            PrintExternalFileName(v);
            ;
        VALUE_TY:
            DecimalNumber(v);
            ;
        STORED_VALUE_TY:
            DecimalNumber(v);
            ;
        SAYABLE_VALUE_TY:
            DecimalNumber(v);
            ;
        UNDERSTANDABLE_VALUE_TY:
            DecimalNumber(v);
            ;
        ARITHMETIC_VALUE_TY:
            DecimalNumber(v);
            ;
        REAL_ARITHMETIC_VALUE_TY:
            DecimalNumber(v);
            ;
        ENUMERATED_VALUE_TY:
            DecimalNumber(v);
            ;
        POINTER_VALUE_TY:
            DecimalNumber(v);
            ;
        PHRASE_TY:
            SayPhraseName(v);
            ;
        VARIABLE_TY:
            DecimalNumber(v);
            ;
        RELATION_TY:
            RELATION_TY_Say(v);
            ;
        RULE_TY:
            RulePrintingRule(v);
            ;
        RULEBOOK_TY:
            RulePrintingRule(v);
            ;
        ACTIVITY_TY:
            DecimalNumber(v);
            ;
        LIST_OF_TY:
            LIST_OF_TY_Say(v);
            ;
        DESCRIPTION_OF_TY:
            DecimalNumber(v);
            ;
        PROPERTY_TY:
            PROPERTY_TY_Say(v);
            ;
        TABLE_COLUMN_TY:
            DecimalNumber(v);
            ;
        COMBINATION_TY:
            COMBINATION_TY_Say(v);
            ;
        NIL_TY:
            DecimalNumber(v);
            ;
        UNKNOWN_TY:
            DecimalNumber(v);
            ;
        VOID_TY:
            DecimalNumber(v);
            ;
        TUPLE_ENTRY_TY:
            DecimalNumber(v);
            ;
        default:
            print v;
            ;
    }
];
[ KOVComparisonFunction k;
    (k = KindAtomic(k));
    switch (k) {
        OBJECT_TY:
            return UnsignedCompare;
            ;
        REAL_NUMBER_TY:
            return REAL_NUMBER_TY_Compare;
            ;
        TRUTH_STATE_TY:
            return UnsignedCompare;
            ;
        TEXT_TY:
            return BlkValueCompare;
            ;
        SNIPPET_TY:
            return UnsignedCompare;
            ;
        UNICODE_CHARACTER_TY:
            return UnsignedCompare;
            ;
        USE_OPTION_TY:
            return UnsignedCompare;
            ;
        RESPONSE_TY:
            return UnsignedCompare;
            ;
        VERB_TY:
            return UnsignedCompare;
            ;
        TABLE_TY:
            return UnsignedCompare;
            ;
        EQUATION_TY:
            return UnsignedCompare;
            ;
        RULEBOOK_OUTCOME_TY:
            return UnsignedCompare;
            ;
        EXTERNAL_FILE_TY:
            return UnsignedCompare;
            ;
        PHRASE_TY:
            return UnsignedCompare;
            ;
        VARIABLE_TY:
            return UnsignedCompare;
            ;
        RELATION_TY:
            return BlkValueCompare;
            ;
        RULE_TY:
            return UnsignedCompare;
            ;
        RULEBOOK_TY:
            return UnsignedCompare;
            ;
        ACTIVITY_TY:
            return UnsignedCompare;
            ;
        LIST_OF_TY:
            return BlkValueCompare;
            ;
        DESCRIPTION_OF_TY:
            return UnsignedCompare;
            ;
        PROPERTY_TY:
            return UnsignedCompare;
            ;
        TABLE_COLUMN_TY:
            return UnsignedCompare;
            ;
        COMBINATION_TY:
            return BlkValueCompare;
            ;
        NIL_TY:
            return UnsignedCompare;
            ;
        VOID_TY:
            return UnsignedCompare;
            ;
        TUPLE_ENTRY_TY:
            return UnsignedCompare;
            ;
    }
    rfalse;
];
[ KOVDomainSize k;
    (k = KindAtomic(k));
    switch (k) {
        WEAK_ID_39:
            return 6;
            ;
        WEAK_ID_40:
            return 5;
            ;
        WEAK_ID_41:
            return 6;
            ;
        WEAK_ID_42:
            return 2;
            ;
        WEAK_ID_43:
            return 3;
            ;
        WEAK_ID_44:
            rtrue;
            ;
        EXTERNAL_FILE_TY:
            rtrue;
            ;
    }
    rfalse;
];
[ KOVIsBlockValue k;
    (k = KindAtomic(k));
    switch (k) {
        TEXT_TY:
            rtrue;
            ;
        RELATION_TY:
            rtrue;
            ;
        LIST_OF_TY:
            rtrue;
            ;
        COMBINATION_TY:
            rtrue;
            ;
    }
    rfalse;
];
[ I7_Kind_Name k;
];
[ KOVSupportFunction k fail;
    (k = KindAtomic(k));
    switch (k) {
        TEXT_TY:
            return TEXT_TY_Support;
            ;
        RELATION_TY:
            return RELATION_TY_Support;
            ;
        LIST_OF_TY:
            return LIST_OF_TY_Support;
            ;
        COMBINATION_TY:
            return COMBINATION_TY_Support;
            ;
    }
    if (fail) {
        BlkValueError(fail);
    }
    rfalse;
];
[ ShowMeKindDetails which na t_0;
    return na;
];
[ CreateDynamicRelations;
];
[ IterateRelations callback;
    (callback)(Rel_Record1);
    (callback)(Rel_Record2);
    (callback)(Rel_Record3);
    (callback)(Rel_Record4);
    (callback)(Rel_Record5);
    (callback)(Rel_Record6);
];
[ RProperty obj cl pr;
    if ((obj ofclass cl)) {
        return _final_propertyvalue(OBJECT_TY, obj, pr);
    }
    rfalse;
];
[ MStack_GetRBVarCreator rb;
    return (rulebook_var_creators-->(rb));
];
[ RulePrintingRule R;
    if ((((R >= 0)) && ((R < 11)))) {
        print (string) (RulebookNames-->(R));
    } else {
        if ((R == FINAL_CODE_STARTUP_R)) {
            print "final code startup rule";
            rtrue;
        }
        if ((R == STANDARD_NAME_PRINTING_R)) {
            print "standard name printing rule";
            rtrue;
        }
        if ((R == STANDARD_PLURAL_NAME_PRINTING_R)) {
            print "standard printing the plural name rule";
            rtrue;
        }
        print "(nameless rule at address ";
        print R;
        print ")";
    }
];
[ PrintResponse R;
];
[ ShowSceneStatus;
];
[ DetectSceneChange chs;
    .Again;
    rfalse;
    if ((chs > 20)) {
        print ">--> The scene change machinery is stuck.^";
        rtrue;
    }
    ++(chs);
    jump Again;
];
[ PrintTableName T;
    switch (T) {
        TheEmptyTable:
            print "(the empty table)";
            rtrue;
            ;
        default:
            print "** No such table **";
            rtrue;
            ;
    }
];
[ TC_KOV tc unk;
    switch (tc) {
    }
    return unk;
];
[ TestScriptSub;
    print ">--> No test scripts exist for this game.^";
];
[ TestUseOption UO;
    if ((UO == 14)) {
        rtrue;
    }
    if ((UO == 15)) {
        rtrue;
    }
    if ((UO == 16)) {
        rtrue;
    }
    rfalse;
];
[ PrintUseOption UO;
    switch (UO) {
        0:
            print "ineffectual option";
            ;
        1:
            print "american dialect option";
            ;
        2:
            print "serial comma option";
            ;
        3:
            print "memory economy option";
            ;
        4:
            print "engineering notation option";
            ;
        5:
            print "unabbreviated object names option";
            ;
        6:
            print "predictable randomisation option";
            ;
        7:
            print "fast route-finding option";
            ;
        8:
            print "slow route-finding option";
            ;
        9:
            print "numbered rules option";
            ;
        10:
            print "telemetry recordings option";
            ;
        11:
            print "no deprecated features option";
            ;
        12:
            print "gn testing version option";
            ;
        13:
            print "authorial modesty option";
            ;
        14:
            print "dynamic memory allocation option [8192]";
            ;
        15:
            print "maximum text length option [1024]";
            ;
        16:
            print "index figure thumbnails option [50]";
            ;
    }
];
[ call_U35 t_0;
    if (1) {
        return (IntegerRemainder(t_0, 2) == 0);
    }
    rfalse;
];
[ call_U36 t_0;
    if (1) {
        return (~~((IntegerRemainder(t_0, 2) == 0)));
    }
    rfalse;
];
[ call_U37 t_0;
    if (1) {
        return (t_0 > 0);
    }
    rfalse;
];
[ call_U38 t_0;
    if (1) {
        return ((REAL_NUMBER_TY_Compare)(t_0,NUMBER_TY_to_REAL_NUMBER_TY(0)) > 0);
    }
    rfalse;
];
[ call_U39 t_0;
    if (1) {
        return (t_0 < 0);
    }
    rfalse;
];
[ call_U40 t_0;
    if (1) {
        return ((REAL_NUMBER_TY_Compare)(t_0,NUMBER_TY_to_REAL_NUMBER_TY(0)) < 0);
    }
    rfalse;
];
[ call_U41 t_0;
    if (1) {
        return TEXT_TY_Empty(t_0);
    }
    rfalse;
];
[ call_U42 t_0;
    if (1) {
        return (TableFilledRows(t_0) == 0);
    }
    rfalse;
];
[ call_U43 t_0;
    if (1) {
        return RulebookEmpty(t_0);
    }
    rfalse;
];
[ call_U44 t_0;
    if (1) {
        return ActivityEmpty(t_0);
    }
    rfalse;
];
[ call_U45 t_0;
    if (1) {
        return LIST_OF_TY_Empty(t_0);
    }
    rfalse;
];
[ call_U46 t_0;
    if (1) {
        return RELATION_TY_Empty(t_0, (-(1)));
    }
    rfalse;
];
[ call_U47 t_0;
    if (1) {
        return RELATION_TY_Empty(t_0, 1);
    }
    rfalse;
];
[ call_U48 t_0;
    if (1) {
        return RELATION_TY_Empty(t_0, 0);
    }
    rfalse;
];
[ call_U49 t_0;
    if (1) {
        return (~~(TEXT_TY_Empty(t_0)));
    }
    rfalse;
];
[ call_U50 t_0;
    if (1) {
        return (~~((TableFilledRows(t_0) == 0)));
    }
    rfalse;
];
[ call_U51 t_0;
    if (1) {
        return (~~(RulebookEmpty(t_0)));
    }
    rfalse;
];
[ call_U52 t_0;
    if (1) {
        return (~~(ActivityEmpty(t_0)));
    }
    rfalse;
];
[ call_U53 t_0;
    if (1) {
        return (~~(LIST_OF_TY_Empty(t_0)));
    }
    rfalse;
];
[ call_U54 t_0;
    if (1) {
        return (~~(RELATION_TY_Empty(t_0, (-(1)))));
    }
    rfalse;
];
[ call_U55 t_0;
    if (1) {
        return RELATION_TY_Empty(t_0, 0);
    }
    rfalse;
];
[ call_U56 t_0;
    if (1) {
        return RELATION_TY_Empty(t_0, 1);
    }
    rfalse;
];
[ call_U57 t_0;
    if (1) {
        return TEXT_TY_IsSubstituted(t_0);
    }
    rfalse;
];
[ call_U58 t_0;
    if (1) {
        return (~~(TEXT_TY_IsSubstituted(t_0)));
    }
    rfalse;
];
[ call_U59 t_0;
    if (1) {
        return (TableBlankRows(t_0) == 0);
    }
    rfalse;
];
[ call_U60 t_0;
    if (1) {
        return (~~((TableBlankRows(t_0) == 0)));
    }
    rfalse;
];
[ call_U61 t_0;
    if (1) {
        return TestActivity(t_0);
    }
    rfalse;
];
[ call_U62 t_0;
    if (1) {
        return TestUseOption(t_0);
    }
    rfalse;
];
[ call_U63 t_0;
    if (1) {
        return (~~(TestUseOption(t_0)));
    }
    rfalse;
];
[ call_U64 t_0;
    if (1) {
        return VerbIsModal(t_0);
    }
    rfalse;
];
[ call_U65 t_0;
    if (1) {
        return (~~(VerbIsModal(t_0)));
    }
    rfalse;
];
[ call_U66 t_0;
    if (1) {
        return VerbIsMeaningful(t_0);
    }
    rfalse;
];
[ call_U67 t_0;
    if (1) {
        return (~~(VerbIsMeaningful(t_0)));
    }
    rfalse;
];
[ call_U68 t_0;
    if (1) {
        return RELATION_TY_EquivalenceAdjective(t_0, (-(1)));
    }
    rfalse;
];
[ call_U69 t_0;
    if (1) {
        return RELATION_TY_EquivalenceAdjective(t_0, 1);
    }
    rfalse;
];
[ call_U70 t_0;
    if (1) {
        return RELATION_TY_EquivalenceAdjective(t_0, 0);
    }
    rfalse;
];
[ call_U71 t_0;
    if (1) {
        return RELATION_TY_SymmetricAdjective(t_0, (-(1)));
    }
    rfalse;
];
[ call_U72 t_0;
    if (1) {
        return RELATION_TY_SymmetricAdjective(t_0, 1);
    }
    rfalse;
];
[ call_U73 t_0;
    if (1) {
        return RELATION_TY_SymmetricAdjective(t_0, 0);
    }
    rfalse;
];
[ call_U74 t_0;
    if (1) {
        return RELATION_TY_OToOAdjective(t_0, (-(1)));
    }
    rfalse;
];
[ call_U75 t_0;
    if (1) {
        return RELATION_TY_OToOAdjective(t_0, 1);
    }
    rfalse;
];
[ call_U76 t_0;
    if (1) {
        return RELATION_TY_OToOAdjective(t_0, 0);
    }
    rfalse;
];
[ call_U77 t_0;
    if (1) {
        return RELATION_TY_OToVAdjective(t_0, (-(1)));
    }
    rfalse;
];
[ call_U78 t_0;
    if (1) {
        return RELATION_TY_OToVAdjective(t_0, 1);
    }
    rfalse;
];
[ call_U79 t_0;
    if (1) {
        return RELATION_TY_OToVAdjective(t_0, 0);
    }
    rfalse;
];
[ call_U80 t_0;
    if (1) {
        return RELATION_TY_VToOAdjective(t_0, (-(1)));
    }
    rfalse;
];
[ call_U81 t_0;
    if (1) {
        return RELATION_TY_VToOAdjective(t_0, 1);
    }
    rfalse;
];
[ call_U82 t_0;
    if (1) {
        return RELATION_TY_VToOAdjective(t_0, 0);
    }
    rfalse;
];
[ call_U83 t_0;
    if (1) {
        return RELATION_TY_VToVAdjective(t_0, (-(1)));
    }
    rfalse;
];
[ call_U84 t_0;
    if (1) {
        return RELATION_TY_VToVAdjective(t_0, 1);
    }
    rfalse;
];
[ call_U85 t_0;
    if (1) {
        return RELATION_TY_VToVAdjective(t_0, 0);
    }
    rfalse;
];
[ call_U86 t_0;
    if (1) {
        return ((((REAL_NUMBER_TY_Compare)(t_0,2139095040) == 0)) || (((REAL_NUMBER_TY_Compare)(t_0,-8388608) == 0)));
    }
    rfalse;
];
[ call_U87 t_0;
    if (1) {
        return (~~(((((REAL_NUMBER_TY_Compare)(t_0,2139095040) == 0)) || (((REAL_NUMBER_TY_Compare)(t_0,-8388608) == 0)))));
    }
    rfalse;
];
[ call_U88 t_0;
    if (1) {
        return REAL_NUMBER_TY_Nan(t_0);
    }
    rfalse;
];
[ call_U89 t_0;
    if (1) {
        return (~~(REAL_NUMBER_TY_Nan(t_0)));
    }
    rfalse;
];
[ call_U90 t_0;
    if (t_0) {
        return (t_0 has pluralname);
    }
    rfalse;
];
[ call_U91 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_pluralname, 1);
    }
    rfalse;
];
[ call_U92 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_pluralname, 0);
    }
    rfalse;
];
[ call_U93 t_0;
    if (t_0) {
        return ((t_0 has pluralname) == 0);
    }
    rfalse;
];
[ call_U94 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_pluralname, 0);
    }
    rfalse;
];
[ call_U95 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_pluralname, 1);
    }
    rfalse;
];
[ call_U96 t_0;
    if (t_0) {
        return (t_0 has proper);
    }
    rfalse;
];
[ call_U97 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_proper, 1);
    }
    rfalse;
];
[ call_U98 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_proper, 0);
    }
    rfalse;
];
[ call_U99 t_0;
    if (t_0) {
        return ((t_0 has proper) == 0);
    }
    rfalse;
];
[ call_U100 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_proper, 0);
    }
    rfalse;
];
[ call_U101 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_proper, 1);
    }
    rfalse;
];
[ call_U102 t_0;
    if (t_0) {
        return (t_0 has ambigpluralname);
    }
    rfalse;
];
[ call_U103 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_ambigpluralname, 1);
    }
    rfalse;
];
[ call_U104 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_ambigpluralname, 0);
    }
    rfalse;
];
[ ADJDEFN1 t_0;
    rfalse;
];
[ ADJDEFN2 t_0;
    rfalse;
];
[ ADJDEFN3 t_0;
    rfalse;
];
[ ADJDEFN4 t_0;
    rfalse;
];
[ ADJDEFN5 t_0;
    rfalse;
];
[ ADJDEFN6 t_0;
    rfalse;
];
[ ADJDEFN7 t_0;
    rfalse;
];
[ ADJDEFN8 t_0;
    rfalse;
];
[ ADJDEFN9 t_0;
    rfalse;
];
[ ADJDEFN10 t_0;
    rfalse;
];
[ ADJDEFN11 t_0;
    rfalse;
];
[ ADJDEFN12 t_0;
    rfalse;
];
[ ADJDEFN13 t_0;
    rfalse;
];
[ ADJDEFN14 t_0;
    rfalse;
];
[ ADJDEFN15 t_0;
    rfalse;
];
[ ADJDEFN16 t_0;
    rfalse;
];
[ ADJDEFN17 t_0;
    rfalse;
];
[ ADJDEFN18 t_0;
    rfalse;
];
[ ADJDEFN19 t_0;
    rfalse;
];
[ ADJDEFN20 t_0;
    rfalse;
];
[ ADJDEFN21 t_0;
    rfalse;
];
[ ADJDEFN22 t_0;
    rfalse;
];
[ ADJDEFN23 t_0;
    rfalse;
];
[ ADJDEFN24 t_0;
    rfalse;
];
[ ADJDEFN25 t_0;
    rfalse;
];
[ call_U108 forbid_breaks rv p;
    (p = parameter_value);
    (parameter_value = p);
    if (debug_rules) {
        DB_Rule(FINAL_CODE_STARTUP_R, 0, 0);
    }
    (rv = (FINAL_CODE_STARTUP_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return FINAL_CODE_STARTUP_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U111 forbid_breaks rv p;
    (p = parameter_value);
    (parameter_value = p);
    if (debug_rules) {
        DB_Rule(STANDARD_NAME_PRINTING_R, 0, 0);
    }
    (rv = (STANDARD_NAME_PRINTING_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return STANDARD_NAME_PRINTING_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U114 forbid_breaks rv p;
    (p = parameter_value);
    (parameter_value = p);
    if (debug_rules) {
        DB_Rule(STANDARD_PLURAL_NAME_PRINTING_R, 0, 0);
    }
    (rv = (STANDARD_PLURAL_NAME_PRINTING_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return STANDARD_PLURAL_NAME_PRINTING_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U116 sk;
    return I_english_language_U1;
];
[ E1 value;
    switch (value) {
        I_english_language_U1:
            print "English language";
            ;
        I_french_language_U1:
            print "French language";
            ;
        I_german_language_U1:
            print "German language";
            ;
        I_italian_language_U1:
            print "Italian language";
            ;
        I_spanish_language_U1:
            print "Spanish language";
            ;
        I_swedish_language_U1:
            print "Swedish language";
            ;
        default:
            print "<illegal natural language>";
            ;
    }
];
[ call_U117 x;
    return ((x%6) + 1);
];
[ call_U118 x;
    return (((x + 4)%6) + 1);
];
[ call_U119 a b;
    if ((((a == 0)) && ((b == 0)))) {
        return random(6);
    }
    if ((a == b)) {
        return b;
    }
    if ((a > b)) {
        return (b + (random(MAX_POSITIVE_NUMBER)%((a - b) + 1)));
    }
    return (a + (random(MAX_POSITIVE_NUMBER)%((b - a) + 1)));
];
[ call_U120;
    rfalse;
];
[ call_U121 t_0 tmp_0;
    (tmp_0 = REAL_NUMBER_TY_Pow(t_0, NUMBER_TY_to_REAL_NUMBER_TY(2)));
    return tmp_0;
    rfalse;
];
[ call_U122 t_0 tmp_0;
    (tmp_0 = (REAL_NUMBER_TY_Log)(REAL_NUMBER_TY_Plus(t_0, (REAL_NUMBER_TY_Root)(REAL_NUMBER_TY_Plus(REAL_NUMBER_TY_Pow(t_0, NUMBER_TY_to_REAL_NUMBER_TY(2)), NUMBER_TY_to_REAL_NUMBER_TY(1))))));
    return tmp_0;
    rfalse;
];
[ call_U123 t_0 tmp_0;
    (tmp_0 = (REAL_NUMBER_TY_Log)(REAL_NUMBER_TY_Plus(t_0, (REAL_NUMBER_TY_Root)(REAL_NUMBER_TY_Minus(REAL_NUMBER_TY_Pow(t_0, NUMBER_TY_to_REAL_NUMBER_TY(2)), NUMBER_TY_to_REAL_NUMBER_TY(1))))));
    return tmp_0;
    rfalse;
];
[ call_U124 t_0 tmp_0;
    (tmp_0 = REAL_NUMBER_TY_Times(1056964608, REAL_NUMBER_TY_Minus((REAL_NUMBER_TY_Log)(REAL_NUMBER_TY_Plus(NUMBER_TY_to_REAL_NUMBER_TY(1), t_0)), (REAL_NUMBER_TY_Log)(REAL_NUMBER_TY_Minus(NUMBER_TY_to_REAL_NUMBER_TY(1), t_0)))));
    return tmp_0;
    rfalse;
];
[ ConjugateModalVerb2 fn vp t modal_to;
    switch (fn) {
        1:
            print "mean";
            ;
        2:
            print "meant";
            ;
        3:
            print "meaning";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "means";
                    } else {
                        print "mean";
                    }
                    ;
                2:
                    print "meant";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has meant";
                    } else {
                        print "have meant";
                    }
                    ;
                4:
                    print "had meant";
                    ;
                5:
                    print "will mean";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not mean";
                    } else {
                        print "do not mean";
                    }
                    ;
                2:
                    print "did not mean";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not meant";
                    } else {
                        print "have not meant";
                    }
                    ;
                4:
                    print "had not meant";
                    ;
                5:
                    print "will not mean";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb3 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb4 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb5 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb6 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb7 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb8 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb9 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb10 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb11 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateVerb4 fn vp t modal_to;
    switch (fn) {
        1:
            print "imply";
            ;
        2:
            print "implied";
            ;
        3:
            print "implying";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return Rel_Record2;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "implies";
                    } else {
                        print "imply";
                    }
                    ;
                2:
                    print "implied";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has implied";
                    } else {
                        print "have implied";
                    }
                    ;
                4:
                    print "had implied";
                    ;
                5:
                    print "will imply";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not imply";
                    } else {
                        print "do not imply";
                    }
                    ;
                2:
                    print "did not imply";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not implied";
                    } else {
                        print "have not implied";
                    }
                    ;
                4:
                    print "had not implied";
                    ;
                5:
                    print "will not imply";
                    ;
            }
            ;
    }
];
[ call_U125 fn vp t modal_to;
    (t = ConjugateVerb4(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateModalVerb12 fn vp t modal_to;
    switch (fn) {
        1:
            print "imply";
            ;
        2:
            print "implied";
            ;
        3:
            print "implying";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "implies";
                    } else {
                        print "imply";
                    }
                    ;
                2:
                    print "implied";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has implied";
                    } else {
                        print "have implied";
                    }
                    ;
                4:
                    print "had implied";
                    ;
                5:
                    print "will imply";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not imply";
                    } else {
                        print "do not imply";
                    }
                    ;
                2:
                    print "did not imply";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not implied";
                    } else {
                        print "have not implied";
                    }
                    ;
                4:
                    print "had not implied";
                    ;
                5:
                    print "will not imply";
                    ;
            }
            ;
    }
];
[ ConjugateVerb5 fn vp t modal_to;
    switch (fn) {
        1:
            print "be able to be";
            ;
        2:
            print "been able to be";
            ;
        3:
            print "being able to be";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    print "can be";
                    ;
                2:
                    print "could be";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been able to be";
                    } else {
                        print "have been able to be";
                    }
                    ;
                4:
                    print "had been able to be";
                    ;
                5:
                    print "will be able to be";
                    ;
                6:
                    print "be";
                    ;
                7:
                    print "be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    print "cannot be";
                    ;
                2:
                    print "could not be";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been able to be";
                    } else {
                        print "have not been able to be";
                    }
                    ;
                4:
                    print "had not been able to be";
                    ;
                5:
                    print "will not be able to be";
                    ;
                6:
                    print "be";
                    ;
                7:
                    print "be";
                    ;
            }
            ;
    }
];
[ call_U126 fn vp t modal_to;
    (t = ConjugateVerb5(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb6 fn vp t modal_to;
    switch (fn) {
        1:
            print "be able to";
            ;
        2:
            print "been able to";
            ;
        3:
            print "being able to";
            ;
        CV_MODAL:
            rtrue;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "can";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "can";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "can";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "can";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "can";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "can";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "have been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "have been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "have been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "have been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "has been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "have been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "had been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "had been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "had been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "had been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "had been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "had been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "will be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "will be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "will be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "will be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "will be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "will be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "cannot";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "cannot";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "cannot";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "cannot";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "cannot";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "cannot";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "have not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "have not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "have not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "have not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "has not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "have not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "had not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "had not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "had not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "had not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "had not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "had not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "will not be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "will not be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "will not be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "will not be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "will not be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "will not be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
    }
];
[ call_U127 fn vp t modal_to;
    (t = ConjugateVerb6(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb7 fn vp t modal_to;
    switch (fn) {
        1:
            print "have";
            ;
        2:
            print "had";
            ;
        3:
            print "having";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return Rel_Record3;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "has";
                    } else {
                        print "have";
                    }
                    ;
                2:
                    print "had";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has had";
                    } else {
                        print "have had";
                    }
                    ;
                4:
                    print "had had";
                    ;
                5:
                    print "will have";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not have";
                    } else {
                        print "do not have";
                    }
                    ;
                2:
                    print "did not have";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not had";
                    } else {
                        print "have not had";
                    }
                    ;
                4:
                    print "had not had";
                    ;
                5:
                    print "will not have";
                    ;
            }
            ;
    }
];
[ call_U128 fn vp t modal_to;
    (t = ConjugateVerb7(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return Rel_Record3;
    }
];
[ ConjugateVerb8 fn vp t modal_to;
    switch (fn) {
        1:
            print "specify";
            ;
        2:
            print "specified";
            ;
        3:
            print "specifying";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "specifies";
                    } else {
                        print "specify";
                    }
                    ;
                2:
                    print "specified";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has specified";
                    } else {
                        print "have specified";
                    }
                    ;
                4:
                    print "had specified";
                    ;
                5:
                    print "will specify";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not specify";
                    } else {
                        print "do not specify";
                    }
                    ;
                2:
                    print "did not specify";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not specified";
                    } else {
                        print "have not specified";
                    }
                    ;
                4:
                    print "had not specified";
                    ;
                5:
                    print "will not specify";
                    ;
            }
            ;
    }
];
[ call_U129 fn vp t modal_to;
    (t = ConjugateVerb8(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb9 fn vp t modal_to;
    switch (fn) {
        1:
            print "relate";
            ;
        2:
            print "related";
            ;
        3:
            print "relating";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return Rel_Record4;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "relates";
                    } else {
                        print "relate";
                    }
                    ;
                2:
                    print "related";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has related";
                    } else {
                        print "have related";
                    }
                    ;
                4:
                    print "had related";
                    ;
                5:
                    print "will relate";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not relate";
                    } else {
                        print "do not relate";
                    }
                    ;
                2:
                    print "did not relate";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not related";
                    } else {
                        print "have not related";
                    }
                    ;
                4:
                    print "had not related";
                    ;
                5:
                    print "will not relate";
                    ;
            }
            ;
    }
];
[ call_U130 fn vp t modal_to;
    (t = ConjugateVerb9(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateModalVerb13 fn vp t modal_to;
    switch (fn) {
        1:
            print "relate";
            ;
        2:
            print "related";
            ;
        3:
            print "relating";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "relates";
                    } else {
                        print "relate";
                    }
                    ;
                2:
                    print "related";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has related";
                    } else {
                        print "have related";
                    }
                    ;
                4:
                    print "had related";
                    ;
                5:
                    print "will relate";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not relate";
                    } else {
                        print "do not relate";
                    }
                    ;
                2:
                    print "did not relate";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not related";
                    } else {
                        print "have not related";
                    }
                    ;
                4:
                    print "had not related";
                    ;
                5:
                    print "will not relate";
                    ;
            }
            ;
    }
];
[ ConjugateVerb10 fn vp t modal_to;
    switch (fn) {
        1:
            print "substitute";
            ;
        2:
            print "substituted";
            ;
        3:
            print "substituting";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "substitutes";
                    } else {
                        print "substitute";
                    }
                    ;
                2:
                    print "substituted";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has substituted";
                    } else {
                        print "have substituted";
                    }
                    ;
                4:
                    print "had substituted";
                    ;
                5:
                    print "will substitute";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not substitute";
                    } else {
                        print "do not substitute";
                    }
                    ;
                2:
                    print "did not substitute";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not substituted";
                    } else {
                        print "have not substituted";
                    }
                    ;
                4:
                    print "had not substituted";
                    ;
                5:
                    print "will not substitute";
                    ;
            }
            ;
    }
];
[ call_U131 fn vp t modal_to;
    (t = ConjugateVerb10(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ call_U132 fn vp t modal_to;
    (t = ConjugateVerb10(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
    print " for";
];
[ ConjugateModalVerb14 fn vp t modal_to;
    switch (fn) {
        1:
            print "do";
            ;
        2:
            print "done";
            ;
        3:
            print "doing";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does";
                    } else {
                        print "do";
                    }
                    ;
                2:
                    print "did";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has done";
                    } else {
                        print "have done";
                    }
                    ;
                4:
                    print "had done";
                    ;
                5:
                    print "will do";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not";
                    } else {
                        print "do not";
                    }
                    ;
                2:
                    print "did not";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not done";
                    } else {
                        print "have not done";
                    }
                    ;
                4:
                    print "had not done";
                    ;
                5:
                    print "will not do";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb15 fn vp t modal_to;
    switch (fn) {
        1:
            print "do";
            ;
        2:
            print "done";
            ;
        3:
            print "doing";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does";
                    } else {
                        print "do";
                    }
                    ;
                2:
                    print "did";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has done";
                    } else {
                        print "have done";
                    }
                    ;
                4:
                    print "had done";
                    ;
                5:
                    print "will do";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not";
                    } else {
                        print "do not";
                    }
                    ;
                2:
                    print "did not";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not done";
                    } else {
                        print "have not done";
                    }
                    ;
                4:
                    print "had not done";
                    ;
                5:
                    print "will not do";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb16 fn vp t modal_to;
    switch (fn) {
        1:
            print "do";
            ;
        2:
            print "done";
            ;
        3:
            print "doing";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does";
                    } else {
                        print "do";
                    }
                    ;
                2:
                    print "did";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has done";
                    } else {
                        print "have done";
                    }
                    ;
                4:
                    print "had done";
                    ;
                5:
                    print "will do";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not";
                    } else {
                        print "do not";
                    }
                    ;
                2:
                    print "did not";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not done";
                    } else {
                        print "have not done";
                    }
                    ;
                4:
                    print "had not done";
                    ;
                5:
                    print "will not do";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb17 fn vp t modal_to;
    switch (fn) {
        1:
            print "do";
            ;
        2:
            print "done";
            ;
        3:
            print "doing";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does";
                    } else {
                        print "do";
                    }
                    ;
                2:
                    print "did";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has done";
                    } else {
                        print "have done";
                    }
                    ;
                4:
                    print "had done";
                    ;
                5:
                    print "will do";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not";
                    } else {
                        print "do not";
                    }
                    ;
                2:
                    print "did not";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not done";
                    } else {
                        print "have not done";
                    }
                    ;
                4:
                    print "had not done";
                    ;
                5:
                    print "will not do";
                    ;
            }
            ;
    }
];
[ ConjugateVerb11 fn vp t modal_to;
    switch (fn) {
        1:
            print "translate";
            ;
        2:
            print "translated";
            ;
        3:
            print "translating";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "translates";
                    } else {
                        print "translate";
                    }
                    ;
                2:
                    print "translated";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has translated";
                    } else {
                        print "have translated";
                    }
                    ;
                4:
                    print "had translated";
                    ;
                5:
                    print "will translate";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not translate";
                    } else {
                        print "do not translate";
                    }
                    ;
                2:
                    print "did not translate";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not translated";
                    } else {
                        print "have not translated";
                    }
                    ;
                4:
                    print "had not translated";
                    ;
                5:
                    print "will not translate";
                    ;
            }
            ;
    }
];
[ call_U133 fn vp t modal_to;
    (t = ConjugateVerb11(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ call_U134 fn vp t modal_to;
    (t = ConjugateVerb11(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
    print " into";
];
[ call_U135 fn vp t modal_to;
    (t = ConjugateVerb11(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
    print " as";
];
[ ConjugateModalVerb18 fn vp t modal_to;
    switch (fn) {
        1:
            print "translate";
            ;
        2:
            print "translated";
            ;
        3:
            print "translating";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "translates";
                    } else {
                        print "translate";
                    }
                    ;
                2:
                    print "translated";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has translated";
                    } else {
                        print "have translated";
                    }
                    ;
                4:
                    print "had translated";
                    ;
                5:
                    print "will translate";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not translate";
                    } else {
                        print "do not translate";
                    }
                    ;
                2:
                    print "did not translate";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not translated";
                    } else {
                        print "have not translated";
                    }
                    ;
                4:
                    print "had not translated";
                    ;
                5:
                    print "will not translate";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb19 fn vp t modal_to;
    switch (fn) {
        1:
            print "translate";
            ;
        2:
            print "translated";
            ;
        3:
            print "translating";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "translates";
                    } else {
                        print "translate";
                    }
                    ;
                2:
                    print "translated";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has translated";
                    } else {
                        print "have translated";
                    }
                    ;
                4:
                    print "had translated";
                    ;
                5:
                    print "will translate";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not translate";
                    } else {
                        print "do not translate";
                    }
                    ;
                2:
                    print "did not translate";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not translated";
                    } else {
                        print "have not translated";
                    }
                    ;
                4:
                    print "had not translated";
                    ;
                5:
                    print "will not translate";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb20 fn vp t modal_to;
    switch (fn) {
        1:
            print "translate";
            ;
        2:
            print "translated";
            ;
        3:
            print "translating";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "translates";
                    } else {
                        print "translate";
                    }
                    ;
                2:
                    print "translated";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has translated";
                    } else {
                        print "have translated";
                    }
                    ;
                4:
                    print "had translated";
                    ;
                5:
                    print "will translate";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not translate";
                    } else {
                        print "do not translate";
                    }
                    ;
                2:
                    print "did not translate";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not translated";
                    } else {
                        print "have not translated";
                    }
                    ;
                4:
                    print "had not translated";
                    ;
                5:
                    print "will not translate";
                    ;
            }
            ;
    }
];
[ ConjugateVerb12 fn vp t modal_to;
    switch (fn) {
        1:
            print "provide";
            ;
        2:
            print "provided";
            ;
        3:
            print "providing";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return Rel_Record5;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "provides";
                    } else {
                        print "provide";
                    }
                    ;
                2:
                    print "provided";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has provided";
                    } else {
                        print "have provided";
                    }
                    ;
                4:
                    print "had provided";
                    ;
                5:
                    print "will provide";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not provide";
                    } else {
                        print "do not provide";
                    }
                    ;
                2:
                    print "did not provide";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not provided";
                    } else {
                        print "have not provided";
                    }
                    ;
                4:
                    print "had not provided";
                    ;
                5:
                    print "will not provide";
                    ;
            }
            ;
    }
];
[ call_U136 fn vp t modal_to;
    (t = ConjugateVerb12(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return Rel_Record5;
    }
];
[ ConjugateVerb13 fn vp t modal_to;
    switch (fn) {
        1:
            print "use";
            ;
        2:
            print "used";
            ;
        3:
            print "using";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "uses";
                    } else {
                        print "use";
                    }
                    ;
                2:
                    print "used";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has used";
                    } else {
                        print "have used";
                    }
                    ;
                4:
                    print "had used";
                    ;
                5:
                    print "will use";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not use";
                    } else {
                        print "do not use";
                    }
                    ;
                2:
                    print "did not use";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not used";
                    } else {
                        print "have not used";
                    }
                    ;
                4:
                    print "had not used";
                    ;
                5:
                    print "will not use";
                    ;
            }
            ;
    }
];
[ call_U137 fn vp t modal_to;
    (t = ConjugateVerb13(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb14 fn vp t modal_to;
    switch (fn) {
        1:
            print "include";
            ;
        2:
            print "included";
            ;
        3:
            print "including";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "includes";
                    } else {
                        print "include";
                    }
                    ;
                2:
                    print "included";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has included";
                    } else {
                        print "have included";
                    }
                    ;
                4:
                    print "had included";
                    ;
                5:
                    print "will include";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not include";
                    } else {
                        print "do not include";
                    }
                    ;
                2:
                    print "did not include";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not included";
                    } else {
                        print "have not included";
                    }
                    ;
                4:
                    print "had not included";
                    ;
                5:
                    print "will not include";
                    ;
            }
            ;
    }
];
[ call_U138 fn vp t modal_to;
    (t = ConjugateVerb14(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ call_U139 fn vp t modal_to;
    (t = ConjugateVerb14(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb15 fn vp t modal_to;
    switch (fn) {
        1:
            print "omit";
            ;
        2:
            print "omitted";
            ;
        3:
            print "omitting";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "omits";
                    } else {
                        print "omit";
                    }
                    ;
                2:
                    print "omitted";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has omitted";
                    } else {
                        print "have omitted";
                    }
                    ;
                4:
                    print "had omitted";
                    ;
                5:
                    print "will omit";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not omit";
                    } else {
                        print "do not omit";
                    }
                    ;
                2:
                    print "did not omit";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not omitted";
                    } else {
                        print "have not omitted";
                    }
                    ;
                4:
                    print "had not omitted";
                    ;
                5:
                    print "will not omit";
                    ;
            }
            ;
    }
];
[ call_U140 fn vp t modal_to;
    (t = ConjugateVerb15(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ call_U141 fn vp t modal_to;
    (t = ConjugateVerb15(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb16 fn vp t modal_to;
    switch (fn) {
        1:
            print "test";
            ;
        2:
            print "tested";
            ;
        3:
            print "testing";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "tests";
                    } else {
                        print "test";
                    }
                    ;
                2:
                    print "tested";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has tested";
                    } else {
                        print "have tested";
                    }
                    ;
                4:
                    print "had tested";
                    ;
                5:
                    print "will test";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not test";
                    } else {
                        print "do not test";
                    }
                    ;
                2:
                    print "did not test";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not tested";
                    } else {
                        print "have not tested";
                    }
                    ;
                4:
                    print "had not tested";
                    ;
                5:
                    print "will not test";
                    ;
            }
            ;
    }
];
[ call_U142 fn vp t modal_to;
    (t = ConjugateVerb16(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ call_U143 fn vp t modal_to;
    (t = ConjugateVerb16(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateModalVerb21 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb22 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb23 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb24 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ call_U144 sk;
    return I_present_tense_U1;
];
[ E2 value;
    switch (value) {
        I_present_tense_U1:
            print "present tense";
            ;
        I_past_tense_U1:
            print "past tense";
            ;
        I_perfect_tense_U1:
            print "perfect tense";
            ;
        I_past_perfect_tense_U1:
            print "past perfect tense";
            ;
        I_future_tense_U1:
            print "future tense";
            ;
        default:
            print "<illegal grammatical tense>";
            ;
    }
];
[ call_U145 x;
    return ((x%5) + 1);
];
[ call_U146 x;
    return (((x + 3)%5) + 1);
];
[ call_U147 a b;
    if ((((a == 0)) && ((b == 0)))) {
        return random(5);
    }
    if ((a == b)) {
        return b;
    }
    if ((a > b)) {
        return (b + (random(MAX_POSITIVE_NUMBER)%((a - b) + 1)));
    }
    return (a + (random(MAX_POSITIVE_NUMBER)%((b - a) + 1)));
];
[ call_U148 sk;
    return I_first_person_singular_U1;
];
[ E3 value;
    switch (value) {
        I_first_person_singular_U1:
            print "first person singular";
            ;
        I_second_person_singular_U1:
            print "second person singular";
            ;
        I_third_person_singular_U1:
            print "third person singular";
            ;
        I_first_person_plural_U1:
            print "first person plural";
            ;
        I_second_person_plural_U1:
            print "second person plural";
            ;
        I_third_person_plural_U1:
            print "third person plural";
            ;
        default:
            print "<illegal narrative viewpoint>";
            ;
    }
];
[ call_U149 x;
    return ((x%6) + 1);
];
[ call_U150 x;
    return (((x + 4)%6) + 1);
];
[ call_U151 a b;
    if ((((a == 0)) && ((b == 0)))) {
        return random(6);
    }
    if ((a == b)) {
        return b;
    }
    if ((a > b)) {
        return (b + (random(MAX_POSITIVE_NUMBER)%((a - b) + 1)));
    }
    return (a + (random(MAX_POSITIVE_NUMBER)%((b - a) + 1)));
];
[ call_U152 sk;
    return I_nominative_U1;
];
[ E4 value;
    switch (value) {
        I_nominative_U1:
            print "nominative";
            ;
        I_accusative_U1:
            print "accusative";
            ;
        default:
            print "<illegal grammatical case>";
            ;
    }
];
[ call_U153 x;
    return ((x%2) + 1);
];
[ call_U154 x;
    return ((x%2) + 1);
];
[ call_U155 a b;
    if ((((a == 0)) && ((b == 0)))) {
        return random(2);
    }
    if ((a == b)) {
        return b;
    }
    if ((a > b)) {
        return (b + (random(MAX_POSITIVE_NUMBER)%((a - b) + 1)));
    }
    return (a + (random(MAX_POSITIVE_NUMBER)%((b - a) + 1)));
];
[ call_U156 sk;
    return I_neuter_gender_U1;
];
[ E5 value;
    switch (value) {
        I_neuter_gender_U1:
            print "neuter gender";
            ;
        I_masculine_gender_U1:
            print "masculine gender";
            ;
        I_feminine_gender_U1:
            print "feminine gender";
            ;
        default:
            print "<illegal grammatical gender>";
            ;
    }
];
[ call_U157 x;
    return ((x%3) + 1);
];
[ call_U158 x;
    return (((x + 1)%3) + 1);
];
[ call_U159 a b;
    if ((((a == 0)) && ((b == 0)))) {
        return random(3);
    }
    if ((a == b)) {
        return b;
    }
    if ((a > b)) {
        return (b + (random(MAX_POSITIVE_NUMBER)%((a - b) + 1)));
    }
    return (a + (random(MAX_POSITIVE_NUMBER)%((b - a) + 1)));
];
[ ConjugateModalVerb25 fn vp t modal_to;
    switch (fn) {
        1:
            print "be able to";
            ;
        2:
            print "been able to";
            ;
        3:
            print "being able to";
            ;
        CV_MODAL:
            rtrue;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "can";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "can";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "can";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "can";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "can";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "can";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "have been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "have been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "have been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "have been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "has been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "have been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "had been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "had been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "had been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "had been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "had been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "had been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "will be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "will be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "will be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "will be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "will be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "will be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "cannot";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "cannot";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "cannot";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "cannot";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "cannot";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "cannot";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "have not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "have not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "have not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "have not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "has not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "have not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "had not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "had not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "had not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "had not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "had not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "had not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "will not be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "will not be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "will not be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "will not be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "will not be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "will not be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
    }
];
[ ConjugateVerb17 fn vp t modal_to;
    switch (fn) {
        1:
            print "could";
            ;
        2:
            print "coulded";
            ;
        3:
            print "coulding";
            ;
        CV_MODAL:
            rtrue;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "could have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "could have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "could have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "could have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "could have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "could have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "could have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "could have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "could have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "could have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "could have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "could have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "could have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "could have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "could have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "could have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "could have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "could have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "could not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "could not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "could not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "could not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "could not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "could not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "could not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "could not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "could not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "could not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "could not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "could not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "could not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "could not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "could not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "could not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "could not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "could not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
    }
];
[ call_U160 fn vp t modal_to;
    (t = ConjugateVerb17(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb18 fn vp t modal_to;
    switch (fn) {
        1:
            print "may";
            ;
        2:
            print "mayed";
            ;
        3:
            print "maying";
            ;
        CV_MODAL:
            rtrue;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "may";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "may";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "may";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "may";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "may";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "may";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "may have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "may have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "may have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "may have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "may have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "may have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "may have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "may have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "may have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "may have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "may have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "may have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "may have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "may have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "may have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "may have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "may have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "may have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "may";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "may";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "may";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "may";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "may";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "may";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "may not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "may not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "may not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "may not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "may not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "may not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "may not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "may not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "may not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "may not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "may not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "may not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "may not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "may not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "may not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "may not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "may not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "may not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "may not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "may not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "may not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "may not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "may not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "may not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "may not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "may not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "may not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "may not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "may not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "may not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
    }
];
[ call_U161 fn vp t modal_to;
    (t = ConjugateVerb18(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb19 fn vp t modal_to;
    switch (fn) {
        1:
            print "might";
            ;
        2:
            print "mighted";
            ;
        3:
            print "mighting";
            ;
        CV_MODAL:
            rtrue;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "might";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "might";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "might";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "might";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "might";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "might";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "might have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "might have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "might have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "might have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "might have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "might have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "might have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "might have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "might have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "might have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "might have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "might have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "might have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "might have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "might have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "might have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "might have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "might have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "might";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "might";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "might";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "might";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "might";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "might";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "might not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "might not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "might not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "might not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "might not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "might not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "might not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "might not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "might not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "might not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "might not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "might not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "might not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "might not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "might not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "might not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "might not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "might not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "might not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "might not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "might not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "might not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "might not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "might not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "might not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "might not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "might not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "might not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "might not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "might not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
    }
];
[ call_U162 fn vp t modal_to;
    (t = ConjugateVerb19(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb20 fn vp t modal_to;
    switch (fn) {
        1:
            print "must";
            ;
        2:
            print "musted";
            ;
        3:
            print "musting";
            ;
        CV_MODAL:
            rtrue;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "must";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "must";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "must";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "must";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "must";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "must";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "must have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "must have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "must have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "must have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "must have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "must have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "must have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "must have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "must have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "must have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "must have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "must have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "must have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "must have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "must have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "must have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "must have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "must have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "must";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "must";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "must";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "must";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "must";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "must";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "must not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "must not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "must not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "must not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "must not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "must not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "must not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "must not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "must not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "must not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "must not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "must not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "must not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "must not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "must not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "must not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "must not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "must not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "must not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "must not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "must not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "must not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "must not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "must not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "must not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "must not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "must not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "must not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "must not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "must not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
    }
];
[ call_U163 fn vp t modal_to;
    (t = ConjugateVerb20(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb21 fn vp t modal_to;
    switch (fn) {
        1:
            print "should";
            ;
        2:
            print "shoulded";
            ;
        3:
            print "shoulding";
            ;
        CV_MODAL:
            rtrue;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "should";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "should";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "should";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "should";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "should";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "should";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "should have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "should have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "should have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "should have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "should have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "should have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "should have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "should have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "should have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "should have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "should have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "should have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "should have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "should have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "should have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "should have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "should have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "should have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "should";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "should";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "should";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "should";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "should";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "should";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "should not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "should not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "should not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "should not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "should not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "should not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "should not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "should not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "should not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "should not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "should not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "should not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "should not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "should not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "should not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "should not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "should not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "should not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "should not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "should not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "should not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "should not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "should not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "should not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "should not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "should not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "should not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "should not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "should not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "should not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
    }
];
[ call_U164 fn vp t modal_to;
    (t = ConjugateVerb21(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb22 fn vp t modal_to;
    switch (fn) {
        1:
            print "would";
            ;
        2:
            print "woulded";
            ;
        3:
            print "woulding";
            ;
        CV_MODAL:
            rtrue;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "would";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "would";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "would";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "would";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "would";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "would";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "would have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "would have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "would have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "would have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "would have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "would have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "would have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "would have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "would have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "would have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "would have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "would have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "would have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "would have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "would have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "would have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "would have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "would have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "would";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "would";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "would";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "would";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "would";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "would";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "would not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "would not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "would not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "would not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "would not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "would not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "would not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "would not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "would not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "would not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "would not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "would not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "would not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "would not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "would not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "would not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "would not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "would not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "would not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "would not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "would not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "would not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "would not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "would not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "would not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "would not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "would not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "would not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "would not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "would not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
    }
];
[ call_U165 fn vp t modal_to;
    (t = ConjugateVerb22(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb23 fn vp t modal_to;
    switch (fn) {
        1:
            print "'re";
            ;
        2:
            print " been";
            ;
        3:
            print " being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "'m";
                            ;
                        4:
                            print "'re";
                            ;
                        2:
                            print "'re";
                            ;
                        5:
                            print "'re";
                            ;
                        3:
                            print "'s";
                            ;
                        6:
                            print "'re";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print " was";
                            ;
                        4:
                            print " were";
                            ;
                        2:
                            print " were";
                            ;
                        5:
                            print " were";
                            ;
                        3:
                            print " was";
                            ;
                        6:
                            print " were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "'s been";
                    } else {
                        print "'ve been";
                    }
                    ;
                4:
                    print "'d been";
                    ;
                5:
                    print "'ll be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "'m not";
                            ;
                        4:
                            print "'re not";
                            ;
                        2:
                            print "'re not";
                            ;
                        5:
                            print "'re not";
                            ;
                        3:
                            print "'s not";
                            ;
                        6:
                            print "'re not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print " wasn't";
                            ;
                        4:
                            print " weren't";
                            ;
                        2:
                            print " weren't";
                            ;
                        5:
                            print " weren't";
                            ;
                        3:
                            print " wasn't";
                            ;
                        6:
                            print " weren't";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "'s not been";
                    } else {
                        print "'ve not been";
                    }
                    ;
                4:
                    print "'d not been";
                    ;
                5:
                    print "'ll not be";
                    ;
            }
            ;
    }
];
[ ConjugateVerb24 fn vp t modal_to;
    switch (fn) {
        1:
            print "'ve";
            ;
        2:
            print " had";
            ;
        3:
            print " having";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "'s";
                    } else {
                        print "'ve";
                    }
                    ;
                2:
                    print " had";
                    ;
                3:
                    if ((vp == 3)) {
                        print "'s had";
                    } else {
                        print "'ve had";
                    }
                    ;
                4:
                    print "'d had";
                    ;
                5:
                    print "'ll have";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "'s not";
                    } else {
                        print "'ve not";
                    }
                    ;
                2:
                    print " hadn't";
                    ;
                3:
                    if ((vp == 3)) {
                        print "'s not had";
                    } else {
                        print "'ve not had";
                    }
                    ;
                4:
                    print "'d not had";
                    ;
                5:
                    print "'ll not have";
                    ;
            }
            ;
    }
];
[ ConjugateVerb25 fn vp t modal_to;
    switch (fn) {
        1:
            print "aren't";
            ;
        2:
            print "aren'ted";
            ;
        3:
            print "aren'ting";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "aren't";
                            ;
                        2:
                            print "aren't";
                            ;
                        5:
                            print "aren't";
                            ;
                        3:
                            print "isn't";
                            ;
                        6:
                            print "aren't";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "wasn't";
                            ;
                        4:
                            print "weren't";
                            ;
                        2:
                            print "weren't";
                            ;
                        5:
                            print "weren't";
                            ;
                        3:
                            print "wasn't";
                            ;
                        6:
                            print "weren't";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "hasn't been";
                    } else {
                        print "haven't been";
                    }
                    ;
                4:
                    print "hadn't been";
                    ;
                5:
                    print "won't be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
            }
            ;
    }
];
[ ConjugateVerb26 fn vp t modal_to;
    switch (fn) {
        1:
            print "can't";
            ;
        2:
            print "can'ted";
            ;
        3:
            print "can'ting";
            ;
        CV_MODAL:
            rtrue;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "can't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "can't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "can't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "can't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "can't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "can't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "couldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "couldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "couldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "couldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "couldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "couldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "haven't been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "haven't been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "haven't been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "haven't been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "hasn't been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "haven't been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "hadn't been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "hadn't been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "hadn't been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "hadn't been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "hadn't been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "hadn't been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "won't be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "won't be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "won't be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "won't be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "won't be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "won't be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
            }
            ;
    }
];
[ ConjugateVerb27 fn vp t modal_to;
    switch (fn) {
        1:
            print "haven't";
            ;
        2:
            print "haven'ted";
            ;
        3:
            print "haven'ting";
            ;
        CV_MODAL:
            rtrue;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "haven't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "haven't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "haven't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "haven't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "hasn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "haven't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "won't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "won't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "won't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "won't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "won't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "won't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
            }
            ;
    }
];
[ ConjugateVerb28 fn vp t modal_to;
    switch (fn) {
        1:
            print "don't";
            ;
        2:
            print "don'ted";
            ;
        3:
            print "don'ting";
            ;
        CV_MODAL:
            rtrue;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "don't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "don't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "don't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "don't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "doesn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "don't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "didn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "didn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "didn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "didn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "didn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "didn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "didn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "didn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "didn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "didn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "didn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "didn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "didn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "didn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "didn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "didn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "didn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "didn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "won't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "won't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "won't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "won't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "won't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "won't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
            }
            ;
    }
];
[ ConjugateModalVerb26 fn vp t modal_to;
    switch (fn) {
        1:
            print "haven't";
            ;
        2:
            print "haven'ted";
            ;
        3:
            print "haven'ting";
            ;
        CV_MODAL:
            rtrue;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "haven't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "haven't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "haven't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "haven't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "hasn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "haven't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "won't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "won't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "won't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "won't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "won't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "won't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
            }
            ;
    }
];
[ ConjugateVerb29 fn vp t modal_to;
    switch (fn) {
        1:
            print "mustn't";
            ;
        2:
            print "mustn'ted";
            ;
        3:
            print "mustn'ting";
            ;
        CV_MODAL:
            rtrue;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "mustn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "mustn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "mustn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "mustn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "mustn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "mustn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "mustn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "mustn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "mustn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "mustn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "mustn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "mustn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "mustn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "mustn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "mustn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "mustn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "mustn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "mustn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "mustn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "mustn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "mustn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "mustn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "mustn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "mustn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "mustn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "mustn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "mustn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "mustn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "mustn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "mustn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
            }
            ;
    }
];
[ ConjugateVerb30 fn vp t modal_to;
    switch (fn) {
        1:
            print "mightn't";
            ;
        2:
            print "mightn'ted";
            ;
        3:
            print "mightn'ting";
            ;
        CV_MODAL:
            rtrue;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "mightn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "mightn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "mightn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "mightn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "mightn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "mightn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "mightn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "mightn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "mightn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "mightn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "mightn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "mightn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "mightn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "mightn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "mightn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "mightn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "mightn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "mightn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "mightn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "mightn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "mightn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "mightn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "mightn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "mightn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "mightn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "mightn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "mightn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "mightn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "mightn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "mightn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
            }
            ;
    }
];
[ ConjugateVerb31 fn vp t modal_to;
    switch (fn) {
        1:
            print "mayn't";
            ;
        2:
            print "mayn'ted";
            ;
        3:
            print "mayn'ting";
            ;
        CV_MODAL:
            rtrue;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "mayn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "mayn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "mayn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "mayn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "mayn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "mayn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "mayn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "mayn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "mayn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "mayn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "mayn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "mayn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "mayn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "mayn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "mayn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "mayn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "mayn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "mayn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "mayn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "mayn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "mayn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "mayn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "mayn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "mayn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "mayn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "mayn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "mayn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "mayn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "mayn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "mayn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
            }
            ;
    }
];
[ ConjugateVerb32 fn vp t modal_to;
    switch (fn) {
        1:
            print "wouldn't";
            ;
        2:
            print "wouldn'ted";
            ;
        3:
            print "wouldn'ting";
            ;
        CV_MODAL:
            rtrue;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "wouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "wouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "wouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "wouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "wouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "wouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "wouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "wouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "wouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "wouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "wouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "wouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "wouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "wouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "wouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "wouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "wouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "wouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
            }
            ;
    }
];
[ ConjugateVerb33 fn vp t modal_to;
    switch (fn) {
        1:
            print "couldn't";
            ;
        2:
            print "couldn'ted";
            ;
        3:
            print "couldn'ting";
            ;
        CV_MODAL:
            rtrue;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "couldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "couldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "couldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "couldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "couldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "couldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "couldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "couldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "couldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "couldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "couldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "couldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "couldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "couldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "couldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "couldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "couldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "couldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "couldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "couldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "couldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "couldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "couldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "couldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "couldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "couldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "couldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "couldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "couldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "couldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
            }
            ;
    }
];
[ ConjugateVerb34 fn vp t modal_to;
    switch (fn) {
        1:
            print "shouldn't";
            ;
        2:
            print "shouldn'ted";
            ;
        3:
            print "shouldn'ting";
            ;
        CV_MODAL:
            rtrue;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "shouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "shouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "shouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "shouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "shouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "shouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "shouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "shouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "shouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "shouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "shouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "shouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "shouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "shouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "shouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "shouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "shouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "shouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "shouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "shouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "shouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "shouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "shouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "shouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "shouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "shouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "shouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "shouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "shouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "shouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
            }
            ;
    }
];
[ ConjugateVerb35 fn vp t modal_to;
    switch (fn) {
        1:
            print "won't";
            ;
        2:
            print "won'ted";
            ;
        3:
            print "won'ting";
            ;
        CV_MODAL:
            rtrue;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "won't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "won't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "won't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "won't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "won't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "won't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "won't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "won't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "won't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "won't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "won't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "won't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
            }
            ;
    }
];
[ call_U166 sk;
    return I_notebook_U1;
];
[ E6 value;
    switch (value) {
        I_notebook_U1:
            print "notebook";
            ;
        default:
            print "<illegal jotter>";
            ;
    }
];
[ call_U167 x;
    return x;
];
[ call_U168 x;
    return x;
];
[ call_U169 a b;
    if ((((a == 0)) && ((b == 0)))) {
        return random(1);
    }
    if ((a == b)) {
        return b;
    }
    if ((a > b)) {
        return (b + (random(MAX_POSITIVE_NUMBER)%((a - b) + 1)));
    }
    return (a + (random(MAX_POSITIVE_NUMBER)%((b - a) + 1)));
];
[ call_U170 RV;
    @push I7SFRAME;
    StackFrameCreate(12);
    BlkValueCreateOnStack(0, TEXT_TY);
    BlkValueCreateOnStack(2, TEXT_TY);
    BlkValueCreateOnStack(4, TEXT_TY);
    BlkValueCreateOnStack(6, TEXT_TY);
    BlkValueCreateOnStack(8, TEXT_TY);
    BlkValueCreateOnStack(10, TEXT_TY);
    (RV = kernel1_U1());
    BlkValueFreeOnStack(0);
    BlkValueFreeOnStack(2);
    BlkValueFreeOnStack(4);
    BlkValueFreeOnStack(6);
    BlkValueFreeOnStack(8);
    BlkValueFreeOnStack(10);
    @pull I7SFRAME;
    return RV;
];
[ kernel1_U1;
    FileIO_PutContents(GProperty(WEAK_ID_44, I_notebook_U1, A_P_text_file), BlkValueCopy(I7SFRAME, TEXT_TY_ExpandIfPerishable((I7SFRAME + (WORDSIZE*2)), ts_array_U1)), 0);
    FileIO_PutContents(GProperty(WEAK_ID_44, I_notebook_U1, A_P_text_file), BlkValueCopy((I7SFRAME + (WORDSIZE*4)), TEXT_TY_ExpandIfPerishable((I7SFRAME + (WORDSIZE*6)), ts_array_U2)), 1);
    FileIO_PutContents(GProperty(WEAK_ID_44, I_notebook_U1, A_P_text_file), BlkValueCopy((I7SFRAME + (WORDSIZE*8)), TEXT_TY_ExpandIfPerishable((I7SFRAME + (WORDSIZE*10)), ts_array_U3)), 1);
    (say__p = 1);
    ParaContent();
    print "You read back: ";
    ParaContent();
    DivideParagraphPoint();
    print "^";
    ParaContent();
    @push self;
    FileIO_PrintContents(GProperty(WEAK_ID_44, (self = I_notebook_U1), A_P_text_file));
    (say__p = 1);
    @pull self;
    rfalse;
];
[ call_U171;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[heading of the notebook][paragraph break]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    @push self;
    TEXT_TY_Say(GProperty(WEAK_ID_44, (self = I_notebook_U1), A_P_heading));
    @pull self;
    ParaContent();
    DivideParagraphPoint();
    print "^";
    rtrue;
];
[ call_U172;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Here's a comment.[line break]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Here's a comment.";
    ParaContent();
    print "^";
    rtrue;
];
[ call_U173;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Here's a secomd comment.[line break]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Here's a secomd comment.";
    ParaContent();
    print "^";
    rtrue;
];
[ Submain;
    call_U170();
];
[ Prop_Falsity reason obj;
    rfalse;
];
[ FINAL_CODE_STARTUP_R addr res;
    #ifdef TARGET_GLULX;
    @gestalt 9 0 res;
    if (res == 0) rfalse;
    addr = #classes_table;
    @accelparam 0 addr;
    @accelparam 1 INDIV_PROP_START;
    @accelparam 2 Class;
    @accelparam 3 Object;
    @accelparam 4 Routine;
    @accelparam 5 String;
    addr = #globals_array + WORDSIZE * #g$self;
    @accelparam 6 addr;
    @accelparam 7 NUM_ATTR_BYTES;
    addr = #cpv__start;
    @accelparam 8 addr;
    @accelfunc 1 Z__Region;
    @accelfunc 2 CP__Tab;
    @accelfunc 3 RA__Pr;
    @accelfunc 4 RL__Pr;
    @accelfunc 5 OC__Cl;
    @accelfunc 6 RV__Pr;
    @accelfunc 7 OP__Pr;
    #endif;
    rfalse;
];
[ DebugAction a anames str;
    #ifdef TARGET_GLULX;
    if (a < 4096) {
        if (a < 0 || a >= #identifiers_table-->7) print "<invalid action ", a, ">";
        else {
            str = #identifiers_table-->6;
            str = str-->a;
            if (str) print (string) str; else print "<unnamed action ", a, ">";
            return;
        }
    }
    #endif;
    #ifdef TARGET_ZCODE;
    if (a < 4096) {
        anames = #identifiers_table;
        anames = anames + 2*(anames-->0) + 2*48;
        print (string) anames-->a;
        return;
    }
    #endif;
    if ((a >= 4096)) {
        print "<fake action ";
        print (a - 4096);
        print ">";
    } else {
        print "<action ";
        print a;
        print ">";
    }
];
[ DebugAttribute a anames str;
    #ifdef TARGET_GLULX;
    if (a < 0 || a >= NUM_ATTR_BYTES*8) print "<invalid attribute ", a, ">";
    else {
        str = #identifiers_table-->4;
        str = str-->a;
        if (str) print (string) str; else print "<unnamed attribute ", a, ">";
    }
    return;
    #endif;
    #ifdef TARGET_ZCODE;
    if (a < 0 || a >= 48) print "<invalid attribute ", a, ">";
    else {
        anames = #identifiers_table; anames = anames + 2*(anames-->0);
        print (string) anames-->a;
    }
    return;
    #endif;
    print "<attribute ";
    print a;
    print ">";
];
[ DebugProperty p pnames str;
    print (property) p;
    return;
    print "<property ";
    print p;
    print ">";
];
[ DecimalNumber num;
    print num;
];
[ PrintI6Text x;
    if ((x ofclass String)) {
        print (string) x;
    }
    if ((x ofclass Routine)) {
        return (x)();
    }
    if ((x == EMPTY_TEXT_PACKED)) {
        rfalse;
    }
    rtrue;
];
[ I7_String x;
    TEXT_TY_Say(x);
];
[ PrintOrRun obj prop no_break pv st routine_return_value;
    @push self;
    (self = obj);
    if ((prop == 0)) {
        PrintShortName(prop);
        (routine_return_value = 1);
    } else {
        (routine_return_value = TEXT_TY_Say(_final_propertyvalue(OBJECT_TY, obj, prop)));
    }
    @pull self;
    if (routine_return_value) {
        (say__p = 1);
        if ((no_break == 0)) {
            print "^";
            DivideParagraphPoint();
        }
    }
    return routine_return_value;
];
[ DA_Number n;
    print n;
];
[ DA_TruthState n;
    if ((n == 0)) {
        print "false";
    } else {
        print "true";
    }
];
[ SayPhraseName closure;
    if ((closure == 0)) {
        print "nothing";
    } else {
        print (string) (closure-->(2));
    }
];
[ KindAtomic kind;
    if ((((kind >= 0)) && ((kind < BASE_KIND_HWM)))) {
        return kind;
    }
    return (kind-->(0));
];
[ KindBaseArity kind;
    if ((((kind >= 0)) && ((kind < BASE_KIND_HWM)))) {
        rfalse;
    }
    return (kind-->(1));
];
[ KindBaseTerm kind n;
    if ((((kind >= 0)) && ((kind < BASE_KIND_HWM)))) {
        return UNKNOWN_TY;
    }
    return (kind-->((2 + n)));
];
[ GenerateRandomNumber n m s;
    if ((n == m)) {
        return n;
    }
    if ((n > m)) {
        (s = n);
        (n = m);
        (m = s);
    }
    (n)--;
    return (random((m - n)) + n);
];
[ PrintSpaces n;
    while ((n > 0)) {
        print " ";
        (n = (n - 1));
    }
];
[ SwapWorkflags obj lst;
    objectloop (obj ofclass Object && (obj ofclass Object)) {
        (lst = 0);
        if ((obj has workflag2)) {
            (lst = 1);
        }
        give obj ~workflag2;
        if ((obj has workflag)) {
            give obj workflag2;
        }
        give obj ~workflag;
        if (lst) {
            give obj workflag;
        }
    }
];
[ ZRegion addr;
    switch (metaclass(addr)) {
        0:
            rfalse;
            ;
        Object, Class:
            rtrue;
            ;
        Routine:
            return 2;
            ;
        String:
            return 3;
            ;
    }
];
[ Memcpy to_addr from_addr size n;
    @mcopy size from_addr to_addr;
];
[ Arrcpy to_array to_entry_size from_array from_entry_size no_entries n val;
    if ((to_entry_size == from_entry_size)) {
        Memcpy(to_array, from_array, (to_entry_size*no_entries));
    } else {
        if ((((to_entry_size == 2)) && ((from_entry_size == 4)))) {
            for ((n = 0):(n < no_entries):(n)++) {
                (val = (from_array-->(n)));
                ((to_array->(0)) = ((val/256)%256));
                ((to_array->(1)) = (val%256));
                (to_array = (to_array + 2));
            }
        } else {
            print "*** Arrcpy doesn't support this ***";
            new_line;
            rtrue;
        }
    }
];
[ PrintVerbAsValue vb;
    if ((vb == 0)) {
        print "(no verb)";
    } else {
        print "verb ";
        (vb)(1);
    }
];
[ VerbIsMeaningful vb;
    if (((vb) && ((BlkValueCompare((vb)(CV_MEANING), MEANINGLESS_RR) ~= 0)))) {
        rtrue;
    }
    rfalse;
];
[ VerbIsModal vb;
    if (((vb) && ((vb)(CV_MODAL)))) {
        rtrue;
    }
    rfalse;
];
[ SEED_RANDOM_NUMBER_GENERATOR_R i;
    if (RNG_SEED_AT_START_OF_PLAY) {
        VM_Seed_RNG(RNG_SEED_AT_START_OF_PLAY);
    }
    for ((i = 1):(i <= 100):(i)++) {
        random(i);
    }
    rfalse;
];
[ DictionaryWordToVerbNum dword verbnum i;
    (dword = ((dword + #dict_par2) - 1));
    @aloads dword 0 verbnum;
    (verbnum = (65535 - verbnum));
    return verbnum;
];
[ RegardingSingleObject obj;
    (prior_named_list = 1);
    (prior_named_list_gender = -1);
    (prior_named_noun = obj);
];
[ RegardingNumber n;
    (prior_named_list = n);
    (prior_named_list_gender = -1);
    (prior_named_noun = 0);
];
[ I7_SOO_PAR oldval count;
    if ((count <= 1)) {
        return count;
    }
    return random(count);
];
[ I7_SOO_RAN oldval count v;
    if ((count <= 1)) {
        return count;
    }
    (v = oldval);
    while ((v == oldval)) {
        (v = random(count));
    }
    return v;
];
[ I7_SOO_STI oldval count v;
    if (oldval) {
        return oldval;
    }
    return I7_SOO_PAR(oldval, count);
];
[ I7_SOO_CYC oldval count;
    (oldval)++;
    if ((oldval > count)) {
        (oldval = 1);
    }
    return oldval;
];
[ I7_SOO_STOP oldval count;
    (oldval)++;
    if ((oldval > count)) {
        (oldval = count);
    }
    return oldval;
];
[ I7_SOO_TAP oldval count tn rn c;
    if ((count <= 1)) {
        return count;
    }
    (tn = ((count*(count + 1))/2));
    (rn = random(tn));
    for ((c = 1):(c <= count):(c)++) {
        (rn = (rn - c));
        if ((rn <= 0)) {
            return ((count - c) + 1);
        }
    }
];
[ I7_SOO_TRAN oldval count;
    if ((oldval < count)) {
        return (oldval + 1);
    }
    return ((count + 1) + I7_SOO_RAN((oldval%(count + 1)), count));
];
[ I7_SOO_TPAR oldval count;
    if ((oldval < count)) {
        return (oldval + 1);
    }
    return ((count + 1) + I7_SOO_PAR((oldval%(count + 1)), count));
];
[ I7_SOO_SHU oldval count sd ct v i j s ssd scope cc base;
    (base = (count + 1));
    (v = (oldval%base));
    (oldval = (oldval/base));
    (ct = (oldval%base));
    (sd = (oldval/base));
    if ((count > 32)) {
        return I7_SOO_PAR(oldval, count);
    }
    if ((count <= 1)) {
        (v = count);
    } else {
        (cc = (base*base));
        (scope = ((MAX_POSITIVE_NUMBER - 1)/cc));
        if ((sd == 0)) {
            (sd = random(scope));
            (ct = 0);
        }
        for ((i = 0):(i < count):(i)++) {
            ((I7_SOO_SHUF->(i)) = i);
        }
        (ssd = sd);
        for ((i = 0):(i < (count - 1)):(i)++) {
            (j = ((sd%(count - i)) + i));
            (sd = ((sd*31973) + 17));
            if ((sd < 0)) {
                (sd = (-(sd)));
            }
            (s = (I7_SOO_SHUF->(j)));
            ((I7_SOO_SHUF->(j)) = (I7_SOO_SHUF->(i)));
            ((I7_SOO_SHUF->(i)) = s);
        }
        (v = ((I7_SOO_SHUF->(ct)) + 1));
        (ct)++;
        if ((ct >= count)) {
            (ct = 0);
            (ssd = 0);
        }
    }
    return ((v + (ct*base)) + ((ssd*base)*base));
];
[ RoundOffValue t1 t2;
    if ((t1 >= 0)) {
        return (((t1 + (t2/2))/t2)*t2);
    }
    return (-(((((-(t1)) + (t2/2))/t2)*t2)));
];
[ glk_exit _vararg_count;
    @glk 1 _vararg_count 0;
    rfalse;
];
[ glk_tick _vararg_count;
    @glk 3 _vararg_count 0;
    rfalse;
];
[ glk_gestalt _vararg_count ret;
    @glk 4 _vararg_count ret;
    return ret;
];
[ glk_gestalt_ext _vararg_count ret;
    @glk 5 _vararg_count ret;
    return ret;
];
[ glk_window_iterate _vararg_count ret;
    @glk 32 _vararg_count ret;
    return ret;
];
[ glk_window_get_rock _vararg_count ret;
    @glk 33 _vararg_count ret;
    return ret;
];
[ glk_window_get_root _vararg_count ret;
    @glk 34 _vararg_count ret;
    return ret;
];
[ glk_window_open _vararg_count ret;
    @glk 35 _vararg_count ret;
    return ret;
];
[ glk_window_close _vararg_count;
    @glk 36 _vararg_count 0;
    rfalse;
];
[ glk_window_get_size _vararg_count;
    @glk 37 _vararg_count 0;
    rfalse;
];
[ glk_window_set_arrangement _vararg_count;
    @glk 38 _vararg_count 0;
    rfalse;
];
[ glk_window_get_arrangement _vararg_count;
    @glk 39 _vararg_count 0;
    rfalse;
];
[ glk_window_get_type _vararg_count ret;
    @glk 40 _vararg_count ret;
    return ret;
];
[ glk_window_get_parent _vararg_count ret;
    @glk 41 _vararg_count ret;
    return ret;
];
[ glk_window_clear _vararg_count;
    @glk 42 _vararg_count 0;
    rfalse;
];
[ glk_window_move_cursor _vararg_count;
    @glk 43 _vararg_count 0;
    rfalse;
];
[ glk_window_get_stream _vararg_count ret;
    @glk 44 _vararg_count ret;
    return ret;
];
[ glk_window_set_echo_stream _vararg_count;
    @glk 45 _vararg_count 0;
    rfalse;
];
[ glk_window_get_echo_stream _vararg_count ret;
    @glk 46 _vararg_count ret;
    return ret;
];
[ glk_set_window _vararg_count;
    @glk 47 _vararg_count 0;
    rfalse;
];
[ glk_window_get_sibling _vararg_count ret;
    @glk 48 _vararg_count ret;
    return ret;
];
[ glk_stream_iterate _vararg_count ret;
    @glk 64 _vararg_count ret;
    return ret;
];
[ glk_stream_get_rock _vararg_count ret;
    @glk 65 _vararg_count ret;
    return ret;
];
[ glk_stream_open_file _vararg_count ret;
    @glk 66 _vararg_count ret;
    return ret;
];
[ glk_stream_open_memory _vararg_count ret;
    @glk 67 _vararg_count ret;
    return ret;
];
[ glk_stream_close _vararg_count;
    @glk 68 _vararg_count 0;
    rfalse;
];
[ glk_stream_set_position _vararg_count;
    @glk 69 _vararg_count 0;
    rfalse;
];
[ glk_stream_get_position _vararg_count ret;
    @glk 70 _vararg_count ret;
    return ret;
];
[ glk_stream_set_current _vararg_count;
    @glk 71 _vararg_count 0;
    rfalse;
];
[ glk_stream_get_current _vararg_count ret;
    @glk 72 _vararg_count ret;
    return ret;
];
[ glk_stream_open_resource _vararg_count ret;
    @glk 73 _vararg_count ret;
    return ret;
];
[ glk_fileref_create_temp _vararg_count ret;
    @glk 96 _vararg_count ret;
    return ret;
];
[ glk_fileref_create_by_name _vararg_count ret;
    @glk 97 _vararg_count ret;
    return ret;
];
[ glk_fileref_create_by_prompt _vararg_count ret;
    @glk 98 _vararg_count ret;
    return ret;
];
[ glk_fileref_destroy _vararg_count;
    @glk 99 _vararg_count 0;
    rfalse;
];
[ glk_fileref_iterate _vararg_count ret;
    @glk 100 _vararg_count ret;
    return ret;
];
[ glk_fileref_get_rock _vararg_count ret;
    @glk 101 _vararg_count ret;
    return ret;
];
[ glk_fileref_delete_file _vararg_count;
    @glk 102 _vararg_count 0;
    rfalse;
];
[ glk_fileref_does_file_exist _vararg_count ret;
    @glk 103 _vararg_count ret;
    return ret;
];
[ glk_fileref_create_from_fileref _vararg_count ret;
    @glk 104 _vararg_count ret;
    return ret;
];
[ glk_put_char _vararg_count;
    @glk 128 _vararg_count 0;
    rfalse;
];
[ glk_put_char_stream _vararg_count;
    @glk 129 _vararg_count 0;
    rfalse;
];
[ glk_put_string _vararg_count;
    @glk 130 _vararg_count 0;
    rfalse;
];
[ glk_put_string_stream _vararg_count;
    @glk 131 _vararg_count 0;
    rfalse;
];
[ glk_put_buffer _vararg_count;
    @glk 132 _vararg_count 0;
    rfalse;
];
[ glk_put_buffer_stream _vararg_count;
    @glk 133 _vararg_count 0;
    rfalse;
];
[ glk_set_style _vararg_count;
    @glk 134 _vararg_count 0;
    rfalse;
];
[ glk_set_style_stream _vararg_count;
    @glk 135 _vararg_count 0;
    rfalse;
];
[ glk_get_char_stream _vararg_count ret;
    @glk 144 _vararg_count ret;
    return ret;
];
[ glk_get_line_stream _vararg_count ret;
    @glk 145 _vararg_count ret;
    return ret;
];
[ glk_get_buffer_stream _vararg_count ret;
    @glk 146 _vararg_count ret;
    return ret;
];
[ glk_char_to_lower _vararg_count ret;
    @glk 160 _vararg_count ret;
    return ret;
];
[ glk_char_to_upper _vararg_count ret;
    @glk 161 _vararg_count ret;
    return ret;
];
[ glk_stylehint_set _vararg_count;
    @glk 176 _vararg_count 0;
    rfalse;
];
[ glk_stylehint_clear _vararg_count;
    @glk 177 _vararg_count 0;
    rfalse;
];
[ glk_style_distinguish _vararg_count ret;
    @glk 178 _vararg_count ret;
    return ret;
];
[ glk_style_measure _vararg_count ret;
    @glk 179 _vararg_count ret;
    return ret;
];
[ glk_select _vararg_count;
    @glk 192 _vararg_count 0;
    rfalse;
];
[ glk_select_poll _vararg_count;
    @glk 193 _vararg_count 0;
    rfalse;
];
[ glk_request_line_event _vararg_count;
    @glk 208 _vararg_count 0;
    rfalse;
];
[ glk_cancel_line_event _vararg_count;
    @glk 209 _vararg_count 0;
    rfalse;
];
[ glk_request_char_event _vararg_count;
    @glk 210 _vararg_count 0;
    rfalse;
];
[ glk_cancel_char_event _vararg_count;
    @glk 211 _vararg_count 0;
    rfalse;
];
[ glk_request_mouse_event _vararg_count;
    @glk 212 _vararg_count 0;
    rfalse;
];
[ glk_cancel_mouse_event _vararg_count;
    @glk 213 _vararg_count 0;
    rfalse;
];
[ glk_request_timer_events _vararg_count;
    @glk 214 _vararg_count 0;
    rfalse;
];
[ glk_image_get_info _vararg_count ret;
    @glk 224 _vararg_count ret;
    return ret;
];
[ glk_image_draw _vararg_count ret;
    @glk 225 _vararg_count ret;
    return ret;
];
[ glk_image_draw_scaled _vararg_count ret;
    @glk 226 _vararg_count ret;
    return ret;
];
[ glk_window_flow_break _vararg_count;
    @glk 232 _vararg_count 0;
    rfalse;
];
[ glk_window_erase_rect _vararg_count;
    @glk 233 _vararg_count 0;
    rfalse;
];
[ glk_window_fill_rect _vararg_count;
    @glk 234 _vararg_count 0;
    rfalse;
];
[ glk_window_set_background_color _vararg_count;
    @glk 235 _vararg_count 0;
    rfalse;
];
[ glk_schannel_iterate _vararg_count ret;
    @glk 240 _vararg_count ret;
    return ret;
];
[ glk_schannel_get_rock _vararg_count ret;
    @glk 241 _vararg_count ret;
    return ret;
];
[ glk_schannel_create _vararg_count ret;
    @glk 242 _vararg_count ret;
    return ret;
];
[ glk_schannel_destroy _vararg_count;
    @glk 243 _vararg_count 0;
    rfalse;
];
[ glk_schannel_create_ext _vararg_count ret;
    @glk 244 _vararg_count ret;
    return ret;
];
[ glk_schannel_play_multi _vararg_count ret;
    @glk 247 _vararg_count ret;
    return ret;
];
[ glk_schannel_play _vararg_count ret;
    @glk 248 _vararg_count ret;
    return ret;
];
[ glk_schannel_play_ext _vararg_count ret;
    @glk 249 _vararg_count ret;
    return ret;
];
[ glk_schannel_stop _vararg_count;
    @glk 250 _vararg_count 0;
    rfalse;
];
[ glk_schannel_set_volume _vararg_count;
    @glk 251 _vararg_count 0;
    rfalse;
];
[ glk_sound_load_hint _vararg_count;
    @glk 252 _vararg_count 0;
    rfalse;
];
[ glk_schannel_set_volume_ext _vararg_count;
    @glk 253 _vararg_count 0;
    rfalse;
];
[ glk_schannel_pause _vararg_count;
    @glk 254 _vararg_count 0;
    rfalse;
];
[ glk_schannel_unpause _vararg_count;
    @glk 255 _vararg_count 0;
    rfalse;
];
[ glk_set_hyperlink _vararg_count;
    @glk 256 _vararg_count 0;
    rfalse;
];
[ glk_set_hyperlink_stream _vararg_count;
    @glk 257 _vararg_count 0;
    rfalse;
];
[ glk_request_hyperlink_event _vararg_count;
    @glk 258 _vararg_count 0;
    rfalse;
];
[ glk_cancel_hyperlink_event _vararg_count;
    @glk 259 _vararg_count 0;
    rfalse;
];
[ glk_buffer_to_lower_case_uni _vararg_count ret;
    @glk 288 _vararg_count ret;
    return ret;
];
[ glk_buffer_to_upper_case_uni _vararg_count ret;
    @glk 289 _vararg_count ret;
    return ret;
];
[ glk_buffer_to_title_case_uni _vararg_count ret;
    @glk 290 _vararg_count ret;
    return ret;
];
[ glk_buffer_canon_decompose_uni _vararg_count ret;
    @glk 291 _vararg_count ret;
    return ret;
];
[ glk_buffer_canon_normalize_uni _vararg_count ret;
    @glk 292 _vararg_count ret;
    return ret;
];
[ glk_put_char_uni _vararg_count;
    @glk 296 _vararg_count 0;
    rfalse;
];
[ glk_put_string_uni _vararg_count;
    @glk 297 _vararg_count 0;
    rfalse;
];
[ glk_put_buffer_uni _vararg_count;
    @glk 298 _vararg_count 0;
    rfalse;
];
[ glk_put_char_stream_uni _vararg_count;
    @glk 299 _vararg_count 0;
    rfalse;
];
[ glk_put_string_stream_uni _vararg_count;
    @glk 300 _vararg_count 0;
    rfalse;
];
[ glk_put_buffer_stream_uni _vararg_count;
    @glk 301 _vararg_count 0;
    rfalse;
];
[ glk_get_char_stream_uni _vararg_count ret;
    @glk 304 _vararg_count ret;
    return ret;
];
[ glk_get_buffer_stream_uni _vararg_count ret;
    @glk 305 _vararg_count ret;
    return ret;
];
[ glk_get_line_stream_uni _vararg_count ret;
    @glk 306 _vararg_count ret;
    return ret;
];
[ glk_stream_open_file_uni _vararg_count ret;
    @glk 312 _vararg_count ret;
    return ret;
];
[ glk_stream_open_memory_uni _vararg_count ret;
    @glk 313 _vararg_count ret;
    return ret;
];
[ glk_stream_open_resource_uni _vararg_count ret;
    @glk 314 _vararg_count ret;
    return ret;
];
[ glk_request_char_event_uni _vararg_count;
    @glk 320 _vararg_count 0;
    rfalse;
];
[ glk_request_line_event_uni _vararg_count;
    @glk 321 _vararg_count 0;
    rfalse;
];
[ glk_set_echo_line_event _vararg_count;
    @glk 336 _vararg_count 0;
    rfalse;
];
[ glk_set_terminators_line_event _vararg_count;
    @glk 337 _vararg_count 0;
    rfalse;
];
[ glk_current_time _vararg_count;
    @glk 352 _vararg_count 0;
    rfalse;
];
[ glk_current_simple_time _vararg_count ret;
    @glk 353 _vararg_count ret;
    return ret;
];
[ glk_time_to_date_utc _vararg_count;
    @glk 360 _vararg_count 0;
    rfalse;
];
[ glk_time_to_date_local _vararg_count;
    @glk 361 _vararg_count 0;
    rfalse;
];
[ glk_simple_time_to_date_utc _vararg_count;
    @glk 362 _vararg_count 0;
    rfalse;
];
[ glk_simple_time_to_date_local _vararg_count;
    @glk 363 _vararg_count 0;
    rfalse;
];
[ glk_date_to_time_utc _vararg_count;
    @glk 364 _vararg_count 0;
    rfalse;
];
[ glk_date_to_time_local _vararg_count;
    @glk 365 _vararg_count 0;
    rfalse;
];
[ glk_date_to_simple_time_utc _vararg_count ret;
    @glk 366 _vararg_count ret;
    return ret;
];
[ glk_date_to_simple_time_local _vararg_count ret;
    @glk 367 _vararg_count ret;
    return ret;
];
[ HandleGlkEvent x1 x2 x3;
    rfalse;
];
[ IdentifyGlkObject x1 x2 x3 x4;
    rfalse;
];
[ InitGlkWindow x1;
    rfalse;
];
[ VM_PreInitialise res;
    @gestalt 4 2 res;
    if ((res == 0)) {
        quit;
    }
    (unicode_gestalt_ok = 0);
    if (glk_gestalt(gestalt_Unicode, 0)) {
        (unicode_gestalt_ok = 1);
    }
    @setiosys 2 0;
];
[ VM_Initialise res sty i;
    @gestalt 4 2 res;
    if ((res == 0)) {
        quit;
    }
    GGRecoverObjects();
    if (glk_gestalt(gestalt_Sound, 0)) {
        if ((gg_foregroundchan == 0)) {
            (gg_foregroundchan = glk_schannel_create(GG_FOREGROUNDCHAN_ROCK));
        }
        if ((gg_backgroundchan == 0)) {
            (gg_backgroundchan = glk_schannel_create(GG_BACKGROUNDCHAN_ROCK));
        }
    }
    if (((KIT_CONFIGURATION_BITMAP)&(FIX_RNG_TCBIT))) {
        @random 10000 i;
        (i = ((-(i)) - 2000));
        @setrandom i;
    }
    (res = InitGlkWindow(0));
    if ((res ~= 0)) {
        rtrue;
    }
    if ((gg_mainwin == 0)) {
        (res = InitGlkWindow(GG_MAINWIN_ROCK));
        if ((res == 0)) {
            glk_stylehint_set(wintype_TextBuffer, style_Header, stylehint_Justification, 0);
            glk_stylehint_set(wintype_TextBuffer, style_Emphasized, stylehint_Weight, 0);
            glk_stylehint_set(wintype_TextBuffer, style_Emphasized, stylehint_Oblique, 1);
            (gg_mainwin = glk_window_open(0, 0, 0, wintype_TextBuffer, GG_MAINWIN_ROCK));
        }
        if ((gg_mainwin == 0)) {
            quit;
        }
    } else {
        glk_window_clear(gg_mainwin);
    }
    if ((gg_statuswin == 0)) {
        (res = InitGlkWindow(GG_STATUSWIN_ROCK));
        if ((res == 0)) {
            (statuswin_cursize = statuswin_size);
            for ((sty = 0):(sty < style_NUMSTYLES):(sty)++) {
                glk_stylehint_set(wintype_TextGrid, sty, stylehint_ReverseColor, 1);
            }
            (gg_statuswin = glk_window_open(gg_mainwin, (winmethod_Fixed + winmethod_Above), statuswin_cursize, wintype_TextGrid, GG_STATUSWIN_ROCK));
        }
    }
    glk_set_window(gg_mainwin);
    InitGlkWindow(1);
    ((buffer3-->(0)) = 0);
];
[ GGRecoverObjects id;
    (gg_mainwin = 0);
    (gg_statuswin = 0);
    (gg_quotewin = 0);
    (gg_scriptfref = 0);
    (gg_scriptstr = 0);
    (gg_savestr = 0);
    (statuswin_cursize = 0);
    (gg_foregroundchan = 0);
    (gg_backgroundchan = 0);
    (gg_commandstr = 0);
    (gg_command_reading = 0);
    IdentifyGlkObject(0);
    (id = glk_stream_iterate(0, gg_arguments));
    while (id) {
        switch ((gg_arguments-->(0))) {
            GG_SAVESTR_ROCK:
                (gg_savestr = id);
                ;
            GG_SCRIPTSTR_ROCK:
                (gg_scriptstr = id);
                ;
            GG_COMMANDWSTR_ROCK:
                (gg_commandstr = id);
                (gg_command_reading = 0);
                ;
            GG_COMMANDRSTR_ROCK:
                (gg_commandstr = id);
                (gg_command_reading = 1);
                ;
            default:
                IdentifyGlkObject(1, 1, id, (gg_arguments-->(0)));
                ;
        }
        (id = glk_stream_iterate(id, gg_arguments));
    }
    (id = glk_window_iterate(0, gg_arguments));
    while (id) {
        switch ((gg_arguments-->(0))) {
            GG_MAINWIN_ROCK:
                (gg_mainwin = id);
                ;
            GG_STATUSWIN_ROCK:
                (gg_statuswin = id);
                ;
            GG_QUOTEWIN_ROCK:
                (gg_quotewin = id);
                ;
            default:
                IdentifyGlkObject(1, 0, id, (gg_arguments-->(0)));
                ;
        }
        (id = glk_window_iterate(id, gg_arguments));
    }
    (id = glk_fileref_iterate(0, gg_arguments));
    while (id) {
        switch ((gg_arguments-->(0))) {
            GG_SCRIPTFREF_ROCK:
                (gg_scriptfref = id);
                ;
            default:
                IdentifyGlkObject(1, 2, id, (gg_arguments-->(0)));
                ;
        }
        (id = glk_fileref_iterate(id, gg_arguments));
    }
    if (glk_gestalt(gestalt_Sound, 0)) {
        (id = glk_schannel_iterate(0, gg_arguments));
        while (id) {
            switch ((gg_arguments-->(0))) {
                GG_FOREGROUNDCHAN_ROCK:
                    (gg_foregroundchan = id);
                    ;
                GG_BACKGROUNDCHAN_ROCK:
                    (gg_backgroundchan = id);
                    ;
                default:
                    IdentifyGlkObject(1, 3, id, (gg_arguments-->(0)));
                    ;
            }
            (id = glk_schannel_iterate(id, gg_arguments));
        }
        if ((gg_foregroundchan ~= 0)) {
            glk_schannel_stop(gg_foregroundchan);
        }
        if ((gg_backgroundchan ~= 0)) {
            glk_schannel_stop(gg_backgroundchan);
        }
    }
    IdentifyGlkObject(2);
];
[ VM_Describe_Release i;
    print "Release ";
    @aloads ROM_GAMERELEASE 0 i;
    print i;
    print " / Serial number ";
    for ((i = 0):(i < 6):(i)++) {
        print (char) (ROM_GAMESERIAL->(i));
    }
];
[ VM_KeyChar win nostat done res ix jx ch;
    (jx = ch);
    if ((win == 0)) {
        (win = gg_mainwin);
    }
    if ((((gg_commandstr ~= 0)) && ((gg_command_reading ~= 0)))) {
        (done = glk_get_line_stream(gg_commandstr, gg_arguments, 31));
        if ((done == 0)) {
            glk_stream_close(gg_commandstr, 0);
            (gg_commandstr = 0);
            (gg_command_reading = 0);
        } else {
            if (((gg_arguments->((done - 1))) == 10)) {
                (done = (done - 1));
            }
            (res = (gg_arguments->(0)));
            if ((res == 92)) {
                (res = 0);
                for ((ix = 1):(ix < done):(ix)++) {
                    (ch = (gg_arguments->(ix)));
                    if ((((ch >= 48)) && ((ch <= 57)))) {
                        @shiftl res 4 res;
                        (res = (res + (ch - 48)));
                    } else {
                        if ((((ch >= 97)) && ((ch <= 102)))) {
                            @shiftl res 4 res;
                            (res = (res + ((ch + 10) - 97)));
                        } else {
                            if ((((ch >= 65)) && ((ch <= 70)))) {
                                @shiftl res 4 res;
                                (res = (res + ((ch + 10) - 65)));
                            }
                        }
                    }
                }
            }
            jump KCPContinue;
        }
    }
    (done = 0);
    glk_request_char_event(win);
    while ((~~(done))) {
        glk_select(gg_event);
        switch ((gg_event-->(0))) {
            5:
                if (nostat) {
                    glk_cancel_char_event(win);
                    (res = -2147483648);
                    (done = 1);
                    break;
                }
                DrawStatusLine();
                ;
            2:
                if (((gg_event-->(1)) == win)) {
                    (res = (gg_event-->(2)));
                    (done = 1);
                }
                ;
        }
        (ix = HandleGlkEvent(gg_event, 1, gg_arguments));
        if ((ix == 2)) {
            (res = (gg_arguments-->(0)));
            (done = 1);
        } else {
            if ((ix == -1)) {
                (done = 0);
            }
        }
    }
    if ((((gg_commandstr ~= 0)) && ((gg_command_reading == 0)))) {
        if ((((((res < 32)) || ((res >= 256)))) || ((res == 92 or 32)))) {
            glk_put_char_stream(gg_commandstr, 92);
            (done = 0);
            (jx = res);
            for ((ix = 0):(ix < 8):(ix)++) {
                @ushiftr jx 28 ch;
                @shiftl jx 4 jx;
                (ch = ((ch)&(15)));
                if ((((ch ~= 0)) || ((ix == 7)))) {
                    (done = 1);
                }
                if (done) {
                    if ((((ch >= 0)) && ((ch <= 9)))) {
                        (ch = (ch + 48));
                    } else {
                        (ch = ((ch - 10) + 65));
                    }
                    glk_put_char_stream(gg_commandstr, ch);
                }
            }
        } else {
            glk_put_char_stream(gg_commandstr, res);
        }
        glk_put_char_stream(gg_commandstr, 10);
    }
    .KCPContinue;
    return res;
];
[ VM_KeyDelay tenths key done ix;
    glk_request_char_event(gg_mainwin);
    glk_request_timer_events((tenths*100));
    while ((~~(done))) {
        glk_select(gg_event);
        (ix = HandleGlkEvent(gg_event, 1, gg_arguments));
        if ((ix == 2)) {
            (key = (gg_arguments-->(0)));
            (done = 1);
        } else {
            if ((((ix >= 0)) && (((gg_event-->(0)) == 1 or 2)))) {
                (key = (gg_event-->(2)));
                (done = 1);
            }
        }
    }
    glk_cancel_char_event(gg_mainwin);
    glk_request_timer_events(0);
    return key;
];
[ VM_ReadKeyboard a_buffer a_table done ix;
    if ((((gg_commandstr ~= 0)) && ((gg_command_reading ~= 0)))) {
        (done = glk_get_line_stream(gg_commandstr, (a_buffer + WORDSIZE), ((INPUT_BUFFER_LEN - WORDSIZE) - 1)));
        if ((done == 0)) {
            glk_stream_close(gg_commandstr, 0);
            (gg_commandstr = 0);
            (gg_command_reading = 0);
        } else {
            if ((((a_buffer + WORDSIZE)->((done - 1))) == 10)) {
                (done = (done - 1));
            }
            ((a_buffer-->(0)) = done);
            VM_Style(INPUT_VMSTY);
            glk_put_buffer((a_buffer + WORDSIZE), done);
            VM_Style(NORMAL_VMSTY);
            print "^";
            jump KPContinue;
        }
    }
    (done = 0);
    glk_request_line_event(gg_mainwin, (a_buffer + WORDSIZE), (INPUT_BUFFER_LEN - WORDSIZE), 0);
    while ((~~(done))) {
        glk_select(gg_event);
        switch ((gg_event-->(0))) {
            5:
                DrawStatusLine();
                ;
            3:
                if (((gg_event-->(1)) == gg_mainwin)) {
                    ((a_buffer-->(0)) = (gg_event-->(2)));
                    (done = 1);
                }
                ;
        }
        (ix = HandleGlkEvent(gg_event, 0, a_buffer));
        if ((ix == 2)) {
            (done = 1);
        } else {
            if ((ix == -1)) {
                (done = 0);
            }
        }
    }
    if ((((gg_commandstr ~= 0)) && ((gg_command_reading == 0)))) {
        glk_put_buffer_stream(gg_commandstr, (a_buffer + WORDSIZE), (a_buffer-->(0)));
        glk_put_char_stream(gg_commandstr, 10);
    }
    .KPContinue;
    VM_Tokenise(a_buffer, a_table);
    if (gg_quotewin) {
        glk_window_close(gg_quotewin, 0);
        (gg_quotewin = 0);
    }
    if (((KIT_CONFIGURATION_BITMAP)&(ECHO_COMMANDS_TCBIT))) {
        print "** ";
        for ((ix = WORDSIZE):(ix < ((a_buffer-->(0)) + WORDSIZE)):(ix)++) {
            print (char) (a_buffer->(ix));
        }
        print "^";
    }
];
[ VM_CopyBuffer bto bfrom i;
    for ((i = 0):(i < INPUT_BUFFER_LEN):(i)++) {
        ((bto->(i)) = (bfrom->(i)));
    }
];
[ VM_PrintToBuffer buf len a b c;
    if (b) {
        if ((((((metaclass(a) == Object)) && (((_final_propertylength(OBJECT_TY, a, b)) == WORDSIZE)))) && ((metaclass(_final_propertyvalue(OBJECT_TY, a, b)) == String)))) {
            ((buf-->(0)) = Glulx_PrintAnyToArray((buf + WORDSIZE), len, _final_propertyvalue(OBJECT_TY, a, b)));
        } else {
            if ((metaclass(a) == Routine)) {
                ((buf-->(0)) = Glulx_PrintAnyToArray((buf + WORDSIZE), len, a, b, c));
            } else {
                ((buf-->(0)) = Glulx_PrintAnyToArray((buf + WORDSIZE), len, a, b));
            }
        }
    } else {
        if ((metaclass(a) == Routine)) {
            ((buf-->(0)) = Glulx_PrintAnyToArray((buf + WORDSIZE), len, a, b, c));
        } else {
            ((buf-->(0)) = Glulx_PrintAnyToArray((buf + WORDSIZE), len, a));
        }
    }
    if (((buf-->(0)) > len)) {
        ((buf-->(0)) = len);
    }
    return (buf-->(0));
];
[ VM_Tokenise buf tab cx numwords len bx ix wx wpos wlen val res dictlen entrylen;
    (len = (buf-->(0)));
    (buf = (buf + WORDSIZE));
    (cx = 0);
    (numwords = 0);
    while ((cx < len)) {
        while ((((cx < len)) && (((buf->(cx)) == 32)))) {
            (cx)++;
        }
        if ((cx >= len)) {
            break;
        }
        (bx = cx);
        if (((buf->(cx)) == 46 or 44 or 34)) {
            (cx)++;
        } else {
            while ((((cx < len)) && (((buf->(cx)) ~= 32 or 46 or 44 or 34)))) {
                (cx)++;
            }
        }
        ((tab-->(((numwords*3) + 2))) = (cx - bx));
        ((tab-->(((numwords*3) + 3))) = (WORDSIZE + bx));
        (numwords)++;
        if ((numwords >= MAX_BUFFER_WORDS)) {
            break;
        }
    }
    ((tab-->(0)) = numwords);
    (dictlen = (#dictionary_table-->(0)));
    (entrylen = (DICT_WORD_SIZE + 7));
    for ((wx = 0):(wx < numwords):(wx)++) {
        (wlen = (tab-->(((wx*3) + 2))));
        (wpos = (tab-->(((wx*3) + 3))));
        if ((wlen > DICT_WORD_SIZE)) {
            (wlen = DICT_WORD_SIZE);
        }
        (cx = (wpos - WORDSIZE));
        for ((ix = 0):(ix < wlen):(ix)++) {
            ((gg_tokenbuf->(ix)) = VM_UpperToLowerCase((buf->((cx + ix)))));
        }
        for (:(ix < DICT_WORD_SIZE):(ix)++) {
            ((gg_tokenbuf->(ix)) = 0);
        }
        (val = (#dictionary_table + WORDSIZE));
        @binarysearch gg_tokenbuf DICT_WORD_SIZE val entrylen dictlen 1 1 res;
        ((tab-->(((wx*3) + 1))) = res);
    }
];
[ LTI_Insert i ch b y;
    (b = buffer);
    (y = (b-->(0)));
    if ((y > INPUT_BUFFER_LEN)) {
        (y = INPUT_BUFFER_LEN);
    }
    for ((y = (y + WORDSIZE)):(y > i):(y)--) {
        ((b->(y)) = (b->((y - 1))));
    }
    ((b->(i)) = ch);
    if (((b-->(0)) < INPUT_BUFFER_LEN)) {
        ((b-->(0)))++;
    }
];
[ VM_InvalidDictionaryAddress addr;
    if ((addr < 0)) {
        rtrue;
    }
    rfalse;
];
[ VM_DictionaryAddressToNumber w;
    return w;
];
[ VM_NumberToDictionaryAddress n;
    return n;
];
[ GGWordCompare str1 str2 ix jx;
    for ((ix = 0):(ix < DICT_WORD_SIZE):(ix)++) {
        (jx = ((str1->(ix)) - (str2->(ix))));
        if ((jx ~= 0)) {
            return jx;
        }
    }
    rfalse;
];
[ VM_CommandTableAddress i;
    return (#grammar_table-->((i + 1)));
];
[ VM_PrintCommandWords i wd j dictlen entrylen;
    (dictlen = (#dictionary_table-->(0)));
    (entrylen = (DICT_WORD_SIZE + 7));
    for ((j = 0):(j < dictlen):(j)++) {
        (wd = ((#dictionary_table + WORDSIZE) + (entrylen*j)));
        if ((DictionaryWordToVerbNum(wd) == i)) {
            print "'";
            print (address) wd;
            print "' ";
        }
    }
];
[ VM_Seed_RNG n;
    @setrandom n;
];
[ VM_AllocateMemory amount i;
    @gestalt 7 0 i;
    if ((i == 0)) {
        return i;
    }
    @malloc amount i;
    return i;
];
[ VM_FreeMemory address i;
    @gestalt 7 0 i;
    if ((i == 0)) {
        rtrue;
    }
    @mfree address;
];
[ VM_Picture resource_ID;
    if (glk_gestalt(gestalt_Graphics, 0)) {
        glk_image_draw(gg_mainwin, resource_ID, imagealign_InlineCenter, 0);
    } else {
        print "[Picture number ";
        print resource_ID;
        print " here.]^";
    }
];
[ VM_SoundEffect resource_ID;
    if (glk_gestalt(gestalt_Sound, 0)) {
        glk_schannel_play(gg_foregroundchan, resource_ID);
    } else {
        print "[Sound effect number ";
        print resource_ID;
        print " here.]^";
    }
];
[ VM_Style sty;
    switch (sty) {
        NORMAL_VMSTY:
            glk_set_style(style_Normal);
            ;
        HEADER_VMSTY:
            glk_set_style(style_Header);
            ;
        SUBHEADER_VMSTY:
            glk_set_style(style_Subheader);
            ;
        NOTE_VMSTY:
            glk_set_style(style_Note);
            ;
        ALERT_VMSTY:
            glk_set_style(style_Alert);
            ;
        BLOCKQUOTE_VMSTY:
            glk_set_style(style_BlockQuote);
            ;
        INPUT_VMSTY:
            glk_set_style(style_Input);
            ;
    }
];
[ VM_UpperToLowerCase c;
    return glk_char_to_lower(c);
];
[ VM_LowerToUpperCase c;
    return glk_char_to_upper(c);
];
[ Glulx_PrintAnything _vararg_count obj mclass;
    if ((_vararg_count == 0)) {
        rtrue;
    }
    @copy sp obj;
    (_vararg_count)--;
    if ((obj == 0)) {
        rtrue;
    }
    if (((obj->(0)) == 96)) {
        print (address) obj;
        rtrue;
    }
    (mclass = metaclass(obj));
    switch (mclass) {
        0:
            rtrue;
            ;
        String:
            print (string) obj;
            rtrue;
            ;
        Routine:
            @call obj _vararg_count 0;
            rtrue;
            ;
        Object:
            if ((_vararg_count == 0)) {
                PrintShortName(obj);
            } else {
                @copy obj sp;
                (_vararg_count)++;
                @call PrintOrRun _vararg_count 0;
            }
            rtrue;
            ;
    }
];
[ Glulx_PrintAnyToArray _vararg_count arr arrlen str oldstr len;
    @copy sp arr;
    @copy sp arrlen;
    (_vararg_count = (_vararg_count - 2));
    (oldstr = glk_stream_get_current());
    (str = glk_stream_open_memory(arr, arrlen, 1, 0));
    if ((str == 0)) {
        rfalse;
    }
    glk_stream_set_current(str);
    @call Glulx_PrintAnything _vararg_count 0;
    glk_stream_set_current(oldstr);
    @copy -1 sp;
    @copy str sp;
    @glk 68 2 0;
    @copy sp len;
    @copy sp 0;
    return len;
];
[ Glulx_ChangeAnyToCString _vararg_count ix len;
    (ix = (GG_ANYTOSTRING_LEN - 2));
    @copy ix sp;
    (ix = (AnyToStrArr + 1));
    @copy ix sp;
    (ix = (_vararg_count + 2));
    @call Glulx_PrintAnyToArray ix len;
    ((AnyToStrArr->(0)) = 224);
    if ((len >= GG_ANYTOSTRING_LEN)) {
        (len = (GG_ANYTOSTRING_LEN - 1));
    }
    ((AnyToStrArr->((len + 1))) = 0);
    return AnyToStrArr;
];
[ VM_ClearScreen window;
    if ((window == WIN_ALL or WIN_MAIN)) {
        glk_window_clear(gg_mainwin);
        if (gg_quotewin) {
            glk_window_close(gg_quotewin, 0);
            (gg_quotewin = 0);
        }
    }
    if (((gg_statuswin) && ((window == WIN_ALL or WIN_STATUS)))) {
        glk_window_clear(gg_statuswin);
    }
];
[ VM_ScreenWidth id;
    (id = gg_mainwin);
    if (((gg_statuswin) && (statuswin_current))) {
        (id = gg_statuswin);
    }
    glk_window_get_size(id, gg_arguments, 0);
    return (gg_arguments-->(0));
];
[ VM_ScreenHeight;
    glk_window_get_size(gg_mainwin, 0, gg_arguments);
    return (gg_arguments-->(0));
];
[ VM_SetWindowColours f b window doclear i fwd bwd swin;
    if (((((clr_on) && (f))) && (b))) {
        if (window) {
            (swin = (5 - window));
        }
        (fwd = MakeColourWord(f));
        (bwd = MakeColourWord(b));
        for ((i = 0):(i < style_NUMSTYLES):(i)++) {
            if ((((f == CLR_DEFAULT)) || ((b == CLR_DEFAULT)))) {
                glk_stylehint_clear(swin, i, stylehint_TextColor);
                glk_stylehint_clear(swin, i, stylehint_BackColor);
            } else {
                glk_stylehint_set(swin, i, stylehint_TextColor, fwd);
                glk_stylehint_set(swin, i, stylehint_BackColor, bwd);
            }
        }
        if (gg_statuswin) {
            glk_window_close(gg_statuswin, 0);
        }
        (gg_statuswin = 0);
        if (((doclear) || ((((window ~= 1)) && ((((clr_fg ~= f)) || ((clr_bg ~= b)))))))) {
            glk_window_close(gg_mainwin, 0);
            (gg_mainwin = glk_window_open(0, 0, 0, wintype_TextBuffer, GG_MAINWIN_ROCK));
            if ((gg_scriptstr ~= 0)) {
                glk_window_set_echo_stream(gg_mainwin, gg_scriptstr);
            }
        }
        (gg_statuswin = glk_window_open(gg_mainwin, (winmethod_Fixed + winmethod_Above), statuswin_cursize, wintype_TextGrid, GG_STATUSWIN_ROCK));
        if (((statuswin_current) && (gg_statuswin))) {
            VM_MoveCursorInStatusLine();
        } else {
            VM_MainWindow();
        }
        if ((window ~= 2)) {
            (clr_fgstatus = f);
            (clr_bgstatus = b);
        }
        if ((window ~= 1)) {
            (clr_fg = f);
            (clr_bg = b);
        }
    }
];
[ VM_RestoreWindowColours;
    if (clr_on) {
        VM_SetWindowColours(clr_fg, clr_bg, 2);
        VM_SetWindowColours(clr_fgstatus, clr_bgstatus, 1, 1);
        VM_ClearScreen();
    }
];
[ MakeColourWord c;
    if ((c > 9)) {
        return c;
    }
    (c = (c - 2));
    return (((16711680*((c)&(1))) + (65280*(((c)&(2)) ~= 0))) + (255*(((c)&(4)) ~= 0)));
];
[ VM_MainWindow;
    glk_set_window(gg_mainwin);
    (statuswin_current = 0);
];
[ VM_StatusLineHeight hgt;
    if ((gg_statuswin == 0)) {
        rtrue;
    }
    if ((hgt == statuswin_cursize)) {
        rtrue;
    }
    glk_window_set_arrangement(glk_window_get_parent(gg_statuswin), 18, hgt, 0);
    (statuswin_cursize = hgt);
];
[ VM_MoveCursorInStatusLine line column;
    if ((gg_statuswin == 0)) {
        rtrue;
    }
    glk_set_window(gg_statuswin);
    if ((line == 0)) {
        (line = 1);
        (column = 1);
    }
    glk_window_move_cursor(gg_statuswin, (column - 1), (line - 1));
    (statuswin_current = 1);
];
[ Box__Routine maxwid arr ix lines lastnl parwin;
    (maxwid = 0);
    (lines = (arr-->(0)));
    if ((gg_quotewin == 0)) {
        ((gg_arguments-->(0)) = lines);
        (ix = InitGlkWindow(GG_QUOTEWIN_ROCK));
        if ((ix == 0)) {
            (gg_quotewin = glk_window_open(gg_mainwin, (winmethod_Fixed + winmethod_Above), lines, wintype_TextBuffer, GG_QUOTEWIN_ROCK));
        }
    } else {
        (parwin = glk_window_get_parent(gg_quotewin));
        glk_window_set_arrangement(parwin, 18, lines, 0);
    }
    (lastnl = 1);
    if (gg_quotewin) {
        glk_window_clear(gg_quotewin);
        glk_set_window(gg_quotewin);
        (lastnl = 0);
    }
    VM_Style(BLOCKQUOTE_VMSTY);
    for ((ix = 0):(ix < lines):(ix)++) {
        print (string) (arr-->((ix + 1)));
        if ((((ix < (lines - 1))) || (lastnl))) {
            print "^";
        }
    }
    VM_Style(NORMAL_VMSTY);
    if (gg_quotewin) {
        glk_set_window(gg_mainwin);
    }
];
[ Unsigned__Compare x y;
    @jleu x y ?lesseq;
    rtrue;
    .lesseq;
    @jeq x y ?equal;
    return (-(1));
    .equal;
    rfalse;
];
[ RT__ChLDW x y;
    @aload x y sp;
    @return sp;
];
[ RT__ChLDB x y;
    @aloadb x y sp;
    @return sp;
];
[ ClearParagraphing r;
    (say__p = 0);
    (say__pc = 0);
];
[ DivideParagraphPoint;
    if (say__p) {
        print "^";
        (say__p = 0);
        (say__pc = ((say__pc)|(PARA_COMPLETED)));
        (say__pc_save = 1);
        if (((say__pc)&(PARA_PROMPTSKIP))) {
            (say__pc = (say__pc - PARA_PROMPTSKIP));
        }
        if (((say__pc)&(PARA_SUPPRESSPROMPTSKIP))) {
            (say__pc = (say__pc - PARA_SUPPRESSPROMPTSKIP));
        }
    }
    (say__pc = ((say__pc)|(PARA_CONTENTEXPECTED)));
    (say__pc_save = ((say__pc)&(PARA_COMPLETED)));
];
[ AdjustParagraphPoint;
    if (say__pc_save) {
        (say__pc = ((say__pc)|(PARA_COMPLETED)));
    }
];
[ ParaContent;
    if (((say__pc)&(PARA_CONTENTEXPECTED))) {
        (say__pc = (say__pc - PARA_CONTENTEXPECTED));
        (say__p = 1);
    }
];
[ GoingLookBreak;
    if ((((say__pc)&(PARA_COMPLETED)) == 0)) {
        print "^";
    }
    ClearParagraphing(10);
];
[ CommandClarificationBreak;
    print "^";
    ClearParagraphing(11);
];
[ RunParagraphOn;
    (say__p = 0);
    (say__pc = ((say__pc)|(PARA_PROMPTSKIP)));
    (say__pc = ((say__pc)|(PARA_SUPPRESSPROMPTSKIP)));
];
[ SpecialLookSpacingBreak;
    (say__p = 0);
    (say__pc = ((say__pc)|(PARA_PROMPTSKIP)));
];
[ EnsureBreakBeforePrompt;
    if (((say__p) || (((((say__pc)&(PARA_PROMPTSKIP))) && ((((say__pc)&(PARA_SUPPRESSPROMPTSKIP)) == 0)))))) {
        print "^";
    }
    ClearParagraphing(12);
];
[ PrintSingleParagraph matter;
    (say__p = 1);
    (say__pc = ((say__pc)|(PARA_NORULEBOOKBREAKS)));
    TEXT_TY_Say(matter);
    DivideParagraphPoint();
    (say__pc = 0);
];
[ STextSubstitution;
    if ((say__n ~= 1)) {
        print "s";
    }
];
[ EnglishNumber n;
    LanguageNumber(n);
];
[ LanguageNumber n f;
    if ((n == 0)) {
        print "zero";
        rfalse;
    }
    if ((n == MIN_NEGATIVE_NUMBER)) {
        print "minus two billion";
        (n = 147483648);
        (f = 1);
    }
    if ((n < 0)) {
        print "minus ";
        (n = (-(n)));
    }
    if ((n >= 1000000000)) {
        if ((f == 1)) {
            print ", ";
        }
        LanguageNumber((n/1000000000));
        print " billion";
        (n = (n%1000000000));
        (f = 1);
    }
    if ((n >= 1000000)) {
        if ((f == 1)) {
            print ", ";
        }
        LanguageNumber((n/1000000));
        print " million";
        (n = (n%1000000));
        (f = 1);
    }
    if ((n >= 1000)) {
        if ((f == 1)) {
            print ", ";
        }
        LanguageNumber((n/1000));
        print " thousand";
        (n = (n%1000));
        (f = 1);
    }
    if ((n >= 100)) {
        if ((f == 1)) {
            print ", ";
        }
        LanguageNumber((n/100));
        print " hundred";
        (n = (n%100));
        (f = 1);
    }
    if ((n == 0)) {
        rfalse;
    }
    if (((KIT_CONFIGURATION_BITMAP)&(DIALECT_US_TCBIT))) {
        if ((f == 1)) {
            print " ";
        }
    } else {
        if ((f == 1)) {
            print " and ";
        }
    }
    if ((((n >= 20)) && ((n < 100)))) {
        switch ((n/10)) {
            2:
                print "twenty";
                ;
            3:
                print "thirty";
                ;
            4:
                print "forty";
                ;
            5:
                print "fifty";
                ;
            6:
                print "sixty";
                ;
            7:
                print "seventy";
                ;
            8:
                print "eighty";
                ;
            9:
                print "ninety";
                ;
        }
        if (((n%10) ~= 0)) {
            print "-";
            LanguageNumber((n%10));
        }
    } else {
        switch (n) {
            1:
                print "one";
                ;
            2:
                print "two";
                ;
            3:
                print "three";
                ;
            4:
                print "four";
                ;
            5:
                print "five";
                ;
            6:
                print "six";
                ;
            7:
                print "seven";
                ;
            8:
                print "eight";
                ;
            9:
                print "nine";
                ;
            10:
                print "ten";
                ;
            11:
                print "eleven";
                ;
            12:
                print "twelve";
                ;
            13:
                print "thirteen";
                ;
            14:
                print "fourteen";
                ;
            15:
                print "fifteen";
                ;
            16:
                print "sixteen";
                ;
            17:
                print "seventeen";
                ;
            18:
                print "eighteen";
                ;
            19:
                print "nineteen";
                ;
        }
    }
];
[ SquareRoot num op res one n x;
    if ((num < 0)) {
        RunTimeProblem(RTP_NEGATIVEROOT);
        rtrue;
    }
    @gestalt 11 0 n;
    if (n) {
        @numtof num x;
        @sqrt x x;
        @ftonumz x num;
        return num;
    }
    (op = num);
    if ((num < 0)) {
        RunTimeProblem(RTP_NEGATIVEROOT);
        rtrue;
    }
    for ((one = WORD_NEXTTOHIGHBIT):(one > op):(one = (one/4))) {
    }
    while ((one ~= 0)) {
        if ((op >= (res + one))) {
            (op = ((op - res) - one));
            (res = ((res/2) + one));
        } else {
            (res = (res/2));
        }
        (one = (one/4));
    }
    return res;
];
[ CubeRoot num neg x y n;
    @gestalt 11 0 n;
    if (n) {
        if ((num < 0)) {
            (neg = 1);
            (num = (-(num)));
        }
        @numtof num x;
        @pow x 1051372203 x;
        @ftonumz x num;
        if (neg) {
            return (-(num));
        } else {
            return num;
        }
    }
    if ((num < 0)) {
        (x = (-(SquareRoot((-(num))))));
    } else {
        (x = SquareRoot(num));
    }
    for ((n = 0):(((y ~= x)) && (((n)++ < 100))):((y = x),(x = (((2*x) + ((num/x)/x))/3)))) {
    }
    return x;
];
[ NUMBER_TY_Abs x;
    if ((x < 0)) {
        return (-(x));
    }
    return x;
];
[ IntegerDivide A B;
    if ((B == 0)) {
        RunTimeProblem(RTP_DIVZERO);
        rfalse;
    }
    return (A/B);
];
[ IntegerRemainder A B;
    if ((B == 0)) {
        RunTimeProblem(RTP_DIVZERO);
        rfalse;
    }
    return (A%B);
];
[ UnsignedCompare x y u v;
    @jleu x y ?lesseq;
    rtrue;
    .lesseq;
    @jeq x y ?equal;
    return (-(1));
    .equal;
    rfalse;
];
[ SignedCompare x y;
    if ((x > y)) {
        rtrue;
    }
    if ((x == y)) {
        rfalse;
    }
    return (-(1));
];
[ REAL_NUMBER_TY_Say fp;
    Float(fp);
];
[ REAL_NUMBER_TY_Compare r1 r2;
    @jflt r1 r2 ?less;
    @jfeq r1 r2 0 ?same;
    rtrue;
    .same;
    rfalse;
    .less;
    return (-(1));
];
[ NUMBER_TY_to_REAL_NUMBER_TY int real;
    @numtof int real;
    return real;
];
[ REAL_NUMBER_TY_to_NUMBER_TY real int;
    @ftonumn real int;
    return int;
];
[ REAL_NUMBER_TY_Sin in out;
    @sin in out;
    return out;
];
[ REAL_NUMBER_TY_Cos in out;
    @cos in out;
    return out;
];
[ REAL_NUMBER_TY_Tan in out;
    @tan in out;
    return out;
];
[ REAL_NUMBER_TY_Arcsin in out;
    @asin in out;
    return out;
];
[ REAL_NUMBER_TY_Arccos in out;
    @acos in out;
    return out;
];
[ REAL_NUMBER_TY_Arctan in out;
    @atan in out;
    return out;
];
[ REAL_NUMBER_TY_Sinh in tmp out;
    @exp in tmp;
    @fsub M_0 in in;
    @exp in out;
    @fadd tmp out out;
    @fmul out M_HALF out;
    return out;
];
[ REAL_NUMBER_TY_Cosh in tmp out;
    @exp in tmp;
    @fsub M_0 in in;
    @exp in out;
    @fsub tmp out out;
    @fmul out M_HALF out;
    return out;
];
[ REAL_NUMBER_TY_Tanh in s c t;
    (s = REAL_NUMBER_TY_Sinh(in));
    (c = REAL_NUMBER_TY_Cosh(in));
    @fdiv s c t;
    return t;
];
[ REAL_NUMBER_TY_Reciprocal in out;
    @fdiv M_1 in out;
    return out;
];
[ REAL_NUMBER_TY_Negate in out;
    @fsub M_0 in out;
    return out;
];
[ REAL_NUMBER_TY_Plus x y out;
    @fadd x y out;
    return out;
];
[ REAL_NUMBER_TY_Minus x y out;
    @fsub x y out;
    return out;
];
[ REAL_NUMBER_TY_Times x y out;
    @fmul x y out;
    return out;
];
[ REAL_NUMBER_TY_Divide x y out;
    @fdiv x y out;
    return out;
];
[ REAL_NUMBER_TY_Remainder x y r q;
    @fmod x y r q;
    return r;
];
[ REAL_NUMBER_TY_Approximate x y quotient out;
    @fdiv x y quotient;
    @fadd quotient M_HALF quotient;
    @floor quotient quotient;
    @fmul quotient y out;
    return out;
];
[ REAL_NUMBER_TY_Root x out;
    @sqrt x out;
    return out;
];
[ REAL_NUMBER_TY_Cube_Root x out;
    @pow x M_THIRD out;
    return out;
];
[ REAL_NUMBER_TY_Pow x y out;
    @pow x y out;
    return out;
];
[ REAL_NUMBER_TY_Exp x out;
    @exp x out;
    return out;
];
[ REAL_NUMBER_TY_Log x out;
    @log x out;
    return out;
];
[ REAL_NUMBER_TY_BLog x n d out;
    @log x out;
    if ((n == 10)) {
        (d = M_LOG10);
    } else {
        @numtof n d;
        @log d d;
    }
    @fdiv out d out;
    return out;
];
[ REAL_NUMBER_TY_Floor x out;
    @floor x out;
    return out;
];
[ REAL_NUMBER_TY_Ceiling x out;
    @ceil x out;
    return out;
];
[ REAL_NUMBER_TY_Abs x;
    return ((x)&(2147483647));
];
[ REAL_NUMBER_TY_Nan x;
    @jisnan x ?Nan;
    rfalse;
    .Nan;
    rtrue;
];
[ FloatParse buf len useall res ix val ch ten negative intpart fracpart fracdiv expon expnegative count;
    if ((len == 0)) {
        return FLOAT_NAN;
    }
    (ix = 0);
    (negative = 0);
    (intpart = 0);
    (fracpart = 0);
    @numtof 10 ten;
    (ch = (buf->(ix)));
    if ((ch == 45)) {
        (negative = 1);
        (ix)++;
    } else {
        if ((ch == 43)) {
            (ix)++;
        }
    }
    for ((count = 0):(ix < len):((ix)++,(count)++)) {
        (ch = (buf->(ix)));
        if ((((ch < 48)) || ((ch > 57)))) {
            break;
        }
        (val = (ch - 48));
        @numtof val val;
        @fmul intpart ten intpart;
        @fadd intpart val intpart;
    }
    if ((((ix < len)) && (((buf->(ix)) == 46)))) {
        (ix)++;
        @numtof 1 fracdiv;
        for (:(ix < len):((ix)++,(count)++)) {
            (ch = (buf->(ix)));
            if ((((ch < 48)) || ((ch > 57)))) {
                break;
            }
            (val = (ch - 48));
            @numtof val val;
            @fmul fracpart ten fracpart;
            @fadd fracpart val fracpart;
            @fmul fracdiv ten fracdiv;
        }
        @fdiv fracpart fracdiv fracpart;
    }
    if ((count == 0)) {
        return FLOAT_NAN;
    }
    @fadd intpart fracpart res;
    if ((((ix < len)) && (((buf->(ix)) == 101 or 69 or 32 or 42 or 120 or 88 or 215)))) {
        if (((buf->(ix)) == 101 or 69)) {
            (ix)++;
            if ((ix == len)) {
                return FLOAT_NAN;
            }
        } else {
            while ((((ix < len)) && (((buf->(ix)) == 32)))) {
                (ix)++;
            }
            if ((ix == len)) {
                return FLOAT_NAN;
            }
            if (((buf->(ix)) ~= 42 or 120 or 88 or 215)) {
                return FLOAT_NAN;
            }
            (ix)++;
            while ((((ix < len)) && (((buf->(ix)) == 32)))) {
                (ix)++;
            }
            if ((ix == len)) {
                return FLOAT_NAN;
            }
            if (((buf->(ix)) ~= 49)) {
                return FLOAT_NAN;
            }
            (ix)++;
            if (((buf->(ix)) ~= 48)) {
                return FLOAT_NAN;
            }
            (ix)++;
            if (((buf->(ix)) ~= 94)) {
                return FLOAT_NAN;
            }
            (ix)++;
        }
        (expnegative = 0);
        (ch = (buf->(ix)));
        if ((ch == 45)) {
            (expnegative = 1);
            (ix)++;
        } else {
            if ((ch == 43)) {
                (ix)++;
            }
        }
        (expon = 0);
        for ((count = 0):(ix < len):((ix)++,(count)++)) {
            (ch = (buf->(ix)));
            if ((((ch < 48)) || ((ch > 57)))) {
                break;
            }
            (expon = ((10*expon) + (ch - 48)));
        }
        if ((count == 0)) {
            return FLOAT_NAN;
        }
        if (expnegative) {
            (expon = (-(expon)));
        }
        if (expon) {
            @numtof expon expon;
            @pow ten expon val;
            @fmul res val res;
        }
    }
    if (negative) {
        (res = ((-2147483648)|(res)));
    }
    if (((useall) && ((ix ~= len)))) {
        return FLOAT_NAN;
    }
    return res;
];
[ Float val prec pval;
    (pval = ((val)&(2147483647)));
    @jz pval ?UseFloatDec;
    @jfge pval 1232348160 ?UseFloatExp;
    @jflt pval 953267991 ?UseFloatExp;
    .UseFloatDec;
    return FloatDec(val, prec);
    .UseFloatExp;
    return FloatExp(val, prec);
];
[ FloatExp val prec log10val expo fexpo idig ix pow10;
    if ((prec == 0)) {
        (prec = 5);
    }
    if ((prec > 8)) {
        (prec = 8);
    }
    (pow10 = (PowersOfTen-->(prec)));
    if (((val)&(-2147483648))) {
        @streamchar 45;
        (val = ((val)&(2147483647)));
    }
    @jisnan val ?IsNan;
    @jisinf val ?IsInf;
    if ((val == 0)) {
        (expo = 0);
        (idig = 0);
        jump DoPrint;
    }
    @log val sp;
    @fdiv sp 1075010958 log10val;
    @floor log10val fexpo;
    @ftonumn fexpo expo;
    @fsub log10val fexpo sp;
    @numtof prec sp;
    @fadd sp sp sp;
    @fmul sp 1075010958 sp;
    @exp sp sp;
    @ftonumn sp idig;
    .DoPrint;
    if ((idig >= (10*pow10))) {
        (expo)++;
        @div idig 10 idig;
    }
    while ((prec > 1)) {
        @mod idig 10 sp;
        @jnz sp ?DoneTrimming;
        @div pow10 10 pow10;
        @div idig 10 idig;
        (prec)--;
    }
    .DoneTrimming;
    for ((ix = 0):(ix <= prec):(ix)++) {
        @div idig pow10 sp;
        @mod sp 10 sp;
        @streamnum sp;
        if ((ix == 0)) {
            @streamchar 46;
        }
        @div pow10 10 pow10;
    }
    if ((((KIT_CONFIGURATION_BITMAP)&(PROGRAMMING_EXPONENTS_TCBIT)) == 0)) {
        PrintMultiplicationSign();
        @streamchar 49;
        @streamchar 48;
        @streamchar 94;
        @streamnum expo;
    } else {
        @streamchar 101;
        if ((expo < 0)) {
            @streamchar 45;
            @neg expo expo;
        } else {
            @streamchar 43;
        }
        if ((expo < 10)) {
            @streamchar 48;
        }
        @streamnum expo;
    }
    rtrue;
    .IsNan;
    PrintNan();
    rtrue;
    .IsInf;
    PrintInfinity();
    rtrue;
];
[ FloatDec val prec log10val int fint extra0 frac idig ix pow10;
    if ((prec == 0)) {
        (prec = 5);
    }
    if ((prec > 8)) {
        (prec = 8);
    }
    (pow10 = (PowersOfTen-->(prec)));
    if (((val)&(-2147483648))) {
        @streamchar 45;
        (val = ((val)&(2147483647)));
    }
    @jisnan val ?IsNan;
    @jisinf val ?IsInf;
    (extra0 = 0);
    @fmod val 1065353216 frac fint;
    @ftonumz fint int;
    if ((int == 2147483647)) {
        @log fint sp;
        @fdiv sp 1075010958 log10val;
        @ftonumz log10val extra0;
        @sub extra0 8 extra0;
        @numtof extra0 sp;
        @fsub log10val sp sp;
        @fmul sp 1075010958 sp;
        @exp sp sp;
        @ftonumz sp int;
    }
    @streamnum int;
    for ((ix = 0):(ix < extra0):(ix)++) {
        @streamchar 48;
    }
    @streamchar 46;
    @log frac sp;
    @fdiv sp 1075010958 log10val;
    @numtof prec sp;
    @fadd log10val sp sp;
    @fmul sp 1075010958 sp;
    @exp sp sp;
    @ftonumn sp idig;
    if ((idig >= pow10)) {
        (idig = (pow10 - 1));
    }
    while ((prec > 1)) {
        @mod idig 10 sp;
        @jnz sp ?DoneTrimming;
        @div pow10 10 pow10;
        @div idig 10 idig;
        (prec)--;
    }
    .DoneTrimming;
    @div pow10 10 pow10;
    for ((ix = 0):(ix < prec):(ix)++) {
        @div idig pow10 sp;
        @mod sp 10 sp;
        @streamnum sp;
        @div pow10 10 pow10;
    }
    rtrue;
    .IsNan;
    PrintNan();
    rtrue;
    .IsInf;
    PrintInfinity();
    rtrue;
];
[ PrintInfinity;
    @streamunichar 8734;
];
[ PrintNan;
    @streamunichar 9888;
];
[ PrintMultiplicationSign;
    print " ";
    @streamunichar 215;
    print " ";
];
[ FileIO_Error extf err_text struc;
    if ((((extf < 1)) || ((extf > NO_EXTERNAL_FILES)))) {
        print "^*** Error on unknown file: ";
        print (string) err_text;
        print " ***^";
    } else {
        (struc = (TableOfExternalFiles-->(extf)));
        print "^*** Error on file '";
        print (string) (struc-->(AUXF_FILENAME));
        print "': ";
        print (string) err_text;
        print " ***^";
    }
    RunTimeProblem(RTP_FILEIOERROR);
    rfalse;
];
[ FileIO_Exists extf fref struc rv usage;
    if ((((extf < 1)) || ((extf > NO_EXTERNAL_FILES)))) {
        rfalse;
    }
    (struc = (TableOfExternalFiles-->(extf)));
    if ((((struc == 0)) || (((struc-->(AUXF_MAGIC)) ~= AUXF_MAGIC_VALUE)))) {
        rfalse;
    }
    if ((struc-->(AUXF_BINARY))) {
        (usage = fileusage_BinaryMode);
    } else {
        (usage = fileusage_TextMode);
    }
    (fref = glk_fileref_create_by_name((fileusage_Data + usage), Glulx_ChangeAnyToCString((struc-->(AUXF_FILENAME))), 0));
    (rv = glk_fileref_does_file_exist(fref));
    glk_fileref_destroy(fref);
    return rv;
];
[ FileIO_Ready extf struc fref usage str ch;
    if ((((extf < 1)) || ((extf > NO_EXTERNAL_FILES)))) {
        rfalse;
    }
    (struc = (TableOfExternalFiles-->(extf)));
    if ((((struc == 0)) || (((struc-->(AUXF_MAGIC)) ~= AUXF_MAGIC_VALUE)))) {
        rfalse;
    }
    if ((struc-->(AUXF_BINARY))) {
        (usage = fileusage_BinaryMode);
    } else {
        (usage = fileusage_TextMode);
    }
    (fref = glk_fileref_create_by_name((fileusage_Data + usage), Glulx_ChangeAnyToCString((struc-->(AUXF_FILENAME))), 0));
    if ((glk_fileref_does_file_exist(fref) == 0)) {
        glk_fileref_destroy(fref);
        rfalse;
    }
    (str = glk_stream_open_file(fref, filemode_Read, 0));
    (ch = glk_get_char_stream(str));
    glk_stream_close(str, 0);
    glk_fileref_destroy(fref);
    if ((ch ~= 42)) {
        rfalse;
    }
    rtrue;
];
[ FileIO_MarkReady extf readiness struc fref str ch usage;
    if ((((extf < 1)) || ((extf > NO_EXTERNAL_FILES)))) {
        return FileIO_Error(extf, "tried to open a non-file");
    }
    (struc = (TableOfExternalFiles-->(extf)));
    if ((((struc == 0)) || (((struc-->(AUXF_MAGIC)) ~= AUXF_MAGIC_VALUE)))) {
        rfalse;
    }
    if ((struc-->(AUXF_BINARY))) {
        (usage = fileusage_BinaryMode);
    } else {
        (usage = fileusage_TextMode);
    }
    (fref = glk_fileref_create_by_name((fileusage_Data + usage), Glulx_ChangeAnyToCString((struc-->(AUXF_FILENAME))), 0));
    if ((glk_fileref_does_file_exist(fref) == 0)) {
        glk_fileref_destroy(fref);
        return FileIO_Error(extf, "only existing files can be marked");
    }
    if (((struc-->(AUXF_STATUS)) ~= AUXF_STATUS_IS_CLOSED)) {
        glk_fileref_destroy(fref);
        return FileIO_Error(extf, "only closed files can be marked");
    }
    (str = glk_stream_open_file(fref, filemode_ReadWrite, 0));
    glk_stream_set_position(str, 0, 0);
    if (readiness) {
        (ch = 42);
    } else {
        (ch = 45);
    }
    glk_put_char_stream(str, ch);
    glk_stream_close(str, 0);
    glk_fileref_destroy(fref);
];
[ FileIO_Open extf write_flag append_flag struc fref str mode ix ch not_this_ifid owner force_header usage;
    if ((((extf < 1)) || ((extf > NO_EXTERNAL_FILES)))) {
        return FileIO_Error(extf, "tried to open a non-file");
    }
    (struc = (TableOfExternalFiles-->(extf)));
    if ((((struc == 0)) || (((struc-->(AUXF_MAGIC)) ~= AUXF_MAGIC_VALUE)))) {
        rfalse;
    }
    if (((struc-->(AUXF_STATUS)) ~= AUXF_STATUS_IS_CLOSED)) {
        return FileIO_Error(extf, "tried to open a file already open");
    }
    if ((struc-->(AUXF_BINARY))) {
        (usage = fileusage_BinaryMode);
    } else {
        (usage = fileusage_TextMode);
    }
    (fref = glk_fileref_create_by_name((fileusage_Data + usage), Glulx_ChangeAnyToCString((struc-->(AUXF_FILENAME))), 0));
    if (write_flag) {
        if (append_flag) {
            (mode = filemode_WriteAppend);
            if ((glk_fileref_does_file_exist(fref) == 0)) {
                (force_header = 1);
            }
        } else {
            (mode = filemode_Write);
        }
    } else {
        (mode = filemode_Read);
        if ((glk_fileref_does_file_exist(fref) == 0)) {
            glk_fileref_destroy(fref);
            return FileIO_Error(extf, "tried to open a file which does not exist");
        }
    }
    (str = glk_stream_open_file(fref, mode, 0));
    glk_fileref_destroy(fref);
    if ((str == 0)) {
        return FileIO_Error(extf, "tried to open a file but failed");
    }
    ((struc-->(AUXF_STREAM)) = str);
    if (write_flag) {
        if (append_flag) {
            ((struc-->(AUXF_STATUS)) = AUXF_STATUS_IS_OPEN_FOR_APPEND);
        } else {
            ((struc-->(AUXF_STATUS)) = AUXF_STATUS_IS_OPEN_FOR_WRITE);
        }
        glk_stream_set_current(str);
        if ((((append_flag == 0)) || (force_header))) {
            print "- ";
            for ((ix = 6):(ix <= (UUID_ARRAY->(0))):(ix)++) {
                print (char) (UUID_ARRAY->(ix));
            }
            print " ";
            print (string) (struc-->(AUXF_FILENAME));
            print "^";
        }
    } else {
        ((struc-->(AUXF_STATUS)) = AUXF_STATUS_IS_OPEN_FOR_READ);
        (ch = FileIO_GetC(extf));
        if ((ch ~= 45 or 42)) {
            jump BadFile;
        }
        if ((ch == 45)) {
            return FileIO_Error(extf, "tried to open a file which was incomplete");
        }
        (ch = FileIO_GetC(extf));
        if ((ch ~= 32)) {
            jump BadFile;
        }
        (ch = FileIO_GetC(extf));
        if ((ch ~= 47)) {
            jump BadFile;
        }
        (ch = FileIO_GetC(extf));
        if ((ch ~= 47)) {
            jump BadFile;
        }
        (owner = (struc-->(AUXF_IFID_OF_OWNER)));
        (ix = 3);
        if ((owner == UUID_ARRAY)) {
            (ix = 8);
        }
        if ((owner ~= NULL)) {
            for (:(ix <= (owner->(0))):(ix)++) {
                (ch = FileIO_GetC(extf));
                if ((ch == -1)) {
                    jump BadFile;
                }
                if ((ch ~= (owner->(ix)))) {
                    (not_this_ifid = 1);
                }
                if ((ch == 32)) {
                    break;
                }
            }
            if ((not_this_ifid == 0)) {
                (ch = FileIO_GetC(extf));
                if ((ch ~= 32)) {
                    jump BadFile;
                }
            }
        }
        while ((ch ~= -1)) {
            (ch = FileIO_GetC(extf));
            if ((ch == 10 or 13)) {
                break;
            }
        }
        if (not_this_ifid) {
            ((struc-->(AUXF_STATUS)) = AUXF_STATUS_IS_CLOSED);
            glk_stream_close(str, 0);
            return FileIO_Error(extf, "tried to open a file owned by another project");
        }
    }
    return (struc-->(AUXF_STREAM));
    .BadFile;
    ((struc-->(AUXF_STATUS)) = AUXF_STATUS_IS_CLOSED);
    glk_stream_close(str, 0);
    return FileIO_Error(extf, "tried to open a file which seems to be malformed");
];
[ FileIO_Close extf struc;
    if ((((extf < 1)) || ((extf > NO_EXTERNAL_FILES)))) {
        return FileIO_Error(extf, "tried to open a non-file");
    }
    (struc = (TableOfExternalFiles-->(extf)));
    if (((struc-->(AUXF_STATUS)) ~= AUXF_STATUS_IS_OPEN_FOR_READ or AUXF_STATUS_IS_OPEN_FOR_WRITE or AUXF_STATUS_IS_OPEN_FOR_APPEND)) {
        return FileIO_Error(extf, "tried to close a file which is not open");
    }
    if (((struc-->(AUXF_STATUS)) == AUXF_STATUS_IS_OPEN_FOR_WRITE or AUXF_STATUS_IS_OPEN_FOR_APPEND)) {
        glk_stream_set_position((struc-->(AUXF_STREAM)), 0, 0);
        glk_put_char_stream((struc-->(AUXF_STREAM)), 42);
    }
    glk_stream_close((struc-->(AUXF_STREAM)), 0);
    ((struc-->(AUXF_STATUS)) = AUXF_STATUS_IS_CLOSED);
];
[ FileIO_GetC extf struc;
    if ((((extf < 1)) || ((extf > NO_EXTERNAL_FILES)))) {
        return (-(1));
    }
    (struc = (TableOfExternalFiles-->(extf)));
    if (((struc-->(AUXF_STATUS)) ~= AUXF_STATUS_IS_OPEN_FOR_READ)) {
        return (-(1));
    }
    return glk_get_char_stream((struc-->(AUXF_STREAM)));
];
[ FileIO_PutC extf char struc;
    if ((((extf < 1)) || ((extf > NO_EXTERNAL_FILES)))) {
        return FileIO_Error(extf, "tried to write to a non-file");
    }
    (struc = (TableOfExternalFiles-->(extf)));
    if (((struc-->(AUXF_STATUS)) ~= AUXF_STATUS_IS_OPEN_FOR_WRITE or AUXF_STATUS_IS_OPEN_FOR_APPEND)) {
        return FileIO_Error(extf, "tried to write to a file which is not open for writing");
    }
    return glk_put_char_stream((struc-->(AUXF_STREAM)), char);
];
[ FileIO_PrintLine extf ch struc;
    if ((((extf < 1)) || ((extf > NO_EXTERNAL_FILES)))) {
        return FileIO_Error(extf, "tried to write to a non-file");
    }
    (struc = (TableOfExternalFiles-->(extf)));
    for (:1:) {
        (ch = FileIO_GetC(extf));
        if ((ch == -1)) {
            rfalse;
        }
        if ((ch == 10 or 13)) {
            print "^";
            rtrue;
        }
        print (char) ch;
    }
];
[ FileIO_PrintContents extf tab struc;
    if ((((extf < 1)) || ((extf > NO_EXTERNAL_FILES)))) {
        return FileIO_Error(extf, "tried to access a non-file");
    }
    (struc = (TableOfExternalFiles-->(extf)));
    if ((struc-->(AUXF_BINARY))) {
        return FileIO_Error(extf, "printing text will not work with binary files");
    }
    if ((FileIO_Open(extf, 0) == 0)) {
        rfalse;
    }
    while (FileIO_PrintLine(extf)) {
    }
    FileIO_Close(extf);
    rtrue;
];
[ FileIO_PutContents extf text append_flag struc str ch oldstream;
    if ((((extf < 1)) || ((extf > NO_EXTERNAL_FILES)))) {
        return FileIO_Error(extf, "tried to access a non-file");
    }
    (struc = (TableOfExternalFiles-->(extf)));
    if ((struc-->(AUXF_BINARY))) {
        return FileIO_Error(extf, "writing text will not work with binary files");
    }
    (oldstream = glk_stream_get_current());
    (str = FileIO_Open(extf, 1, append_flag));
    if ((str == 0)) {
        rfalse;
    }
    @push say__p;
    @push say__pc;
    ClearParagraphing(19);
    TEXT_TY_Say(text);
    FileIO_Close(extf);
    if (oldstream) {
        glk_stream_set_current(oldstream);
    }
    @pull say__pc;
    @pull say__p;
    rfalse;
];
[ FileIO_PutTable extf tab rv struc oldstream;
    if ((((extf < 1)) || ((extf > NO_EXTERNAL_FILES)))) {
        return FileIO_Error(extf, "tried to write table to a non-file");
    }
    (struc = (TableOfExternalFiles-->(extf)));
    if ((struc-->(AUXF_BINARY))) {
        return FileIO_Error(extf, "writing a table will not work with binary files");
    }
    (oldstream = glk_stream_get_current());
    if ((FileIO_Open(extf, 1) == 0)) {
        rfalse;
    }
    (rv = TablePrint(tab));
    FileIO_Close(extf);
    if (oldstream) {
        glk_stream_set_current(oldstream);
    }
    if (rv) {
        return RunTimeProblem(RTP_TABLE_CANTSAVE, tab);
    }
    rtrue;
];
[ FileIO_GetTable extf tab struc;
    if ((((extf < 1)) || ((extf > NO_EXTERNAL_FILES)))) {
        return FileIO_Error(extf, "tried to read table from a non-file");
    }
    (struc = (TableOfExternalFiles-->(extf)));
    if ((struc-->(AUXF_BINARY))) {
        return FileIO_Error(extf, "reading a table will not work with binary files");
    }
    if ((FileIO_Open(extf, 0) == 0)) {
        rfalse;
    }
    TableRead(tab, extf);
    FileIO_Close(extf);
    rtrue;
];
[ SetSortDomain swapf compf;
    (I7S_Swap = swapf);
    (I7S_Comp = compf);
];
[ SortArray tab col dir size algorithm;
    (I7S_Tab = tab);
    (I7S_Col = col);
    (I7S_Dir = dir);
    SortRange(0, size, algorithm);
];
[ SortRange x y algorithm;
    if (((y - x) < 2)) {
        rtrue;
    }
    if (algorithm) {
        (algorithm)(x,y);
    } else {
        InPlaceMergeSortAlgorithm(x, y);
    }
];
[ CompareFields x y;
    return (I7S_Dir*(I7S_Comp)(I7S_Tab,I7S_Col,(x + 1),(y + 1),I7S_Dir));
];
[ ExchangeFields x y r;
    (r = (I7S_Swap)(I7S_Tab,(x + 1),(y + 1)));
    return r;
];
[ OldSortAlgorithm x y f i j;
    if (((y - x) < 2)) {
        rtrue;
    }
    (f = 1);
    while (f) {
        (f = 0);
        for ((i = x):(i < y):(i)++) {
            for ((j = (i + 1)):(j < y):(j)++) {
                if ((CompareFields(i, j) > 0)) {
                    ExchangeFields(i, j);
                    (f = 1);
                    break;
                }
            }
        }
    }
];
[ InsertionSortAlgorithm from to i j;
    if ((to > (from + 1))) {
        for ((i = (from + 1)):(i < to):(i)++) {
            for ((j = i):(j > from):(j)--) {
                if ((CompareFields(j, (j - 1)) < 0)) {
                    ExchangeFields(j, (j - 1));
                } else {
                    break;
                }
            }
        }
    }
];
[ InPlaceMergeSortAlgorithm from to middle;
    if (((to - from) < 12)) {
        if (((to - from) < 2)) {
            rtrue;
        }
        InsertionSortAlgorithm(from, to);
        rtrue;
    }
    (middle = ((from + to)/2));
    InPlaceMergeSortAlgorithm(from, middle);
    InPlaceMergeSortAlgorithm(middle, to);
    IPMS_Merge(from, middle, to, (middle - from), (to - middle));
];
[ IPMS_Lower from to val len half mid;
    (len = (to - from));
    while ((len > 0)) {
        (half = (len/2));
        (mid = (from + half));
        if ((CompareFields(mid, val) < 0)) {
            (from = (mid + 1));
            (len = ((len - half) - 1));
        } else {
            (len = half);
        }
    }
    return from;
];
[ IPMS_Upper from to val len half mid;
    (len = (to - from));
    while ((len > 0)) {
        (half = (len/2));
        (mid = (from + half));
        if ((CompareFields(val, mid) < 0)) {
            (len = half);
        } else {
            (from = (mid + 1));
            (len = ((len - half) - 1));
        }
    }
    return from;
];
[ IPMS_Reverse from to;
    while ((from < to)) {
        ExchangeFields((from)++, (to)--);
    }
];
[ IPMS_Rotate from mid to n val shift p1 p2;
    if ((((from == mid)) || ((mid == to)))) {
        rtrue;
    }
    IPMS_Reverse(from, (mid - 1));
    IPMS_Reverse(mid, (to - 1));
    IPMS_Reverse(from, (to - 1));
];
[ IPMS_Merge from pivot to len1 len2 first_cut second_cut len11 len22 new_mid;
    if ((((len1 == 0)) || ((len2 == 0)))) {
        rtrue;
    }
    if (((len1 + len2) == 2)) {
        if ((CompareFields(pivot, from) < 0)) {
            ExchangeFields(pivot, from);
        }
        rtrue;
    }
    if ((len1 > len2)) {
        (len11 = (len1/2));
        (first_cut = (from + len11));
        (second_cut = IPMS_Lower(pivot, to, first_cut));
        (len22 = (second_cut - pivot));
    } else {
        (len22 = (len2/2));
        (second_cut = (pivot + len22));
        (first_cut = IPMS_Upper(from, pivot, second_cut));
        (len11 = (first_cut - from));
    }
    IPMS_Rotate(first_cut, pivot, second_cut);
    (new_mid = (first_cut + len22));
    IPMS_Merge(from, first_cut, new_mid, len11, len22);
    IPMS_Merge(new_mid, second_cut, to, (len1 - len11), (len2 - len22));
];
[ TableFindCol tab col f i no_cols n;
    (no_cols = (tab-->(0)));
    for ((i = 1):(i <= no_cols):(i)++) {
        if ((col == ((((tab-->(i))-->(1)))&(TB_COLUMN_NUMBER)))) {
            return i;
        }
    }
    if (f) {
        RunTimeProblem(RTP_TABLE_NOCOL, tab);
        rfalse;
    }
    rfalse;
];
[ TableRows tab first_col;
    (first_col = (tab-->(1)));
    if ((first_col == 0)) {
        rfalse;
    }
    return ((first_col-->(0)) - COL_HSIZE);
];
[ CheckTableEntryIsBlank tab col row i at;
    if ((col >= 100)) {
        (col = TableFindCol(tab, col));
    }
    if ((col == 0)) {
        rtrue;
    }
    if ((((tab-->(col))-->((row + COL_HSIZE))) ~= TABLE_NOVALUE)) {
        print "*** CTEIB on nonblank value ";
        print tab;
        print " ";
        print col;
        print " ";
        print row;
        print " ***^";
    }
    if (((((tab-->(col))-->(1)))&(TB_COLUMN_NOBLANKBITS))) {
        rtrue;
    }
    (row)--;
    (at = (((tab-->(col))-->(2)) + (row/8)));
    if ((((TB_Blanks->(at)))&((CheckTableEntryIsBlank_LU->((row%8)))))) {
        rtrue;
    }
    rfalse;
];
[ ForceTableEntryBlank tab col row i at oldv flags;
    if ((col >= 100)) {
        (col = TableFindCol(tab, col));
    }
    if ((col == 0)) {
        rtrue;
    }
    (flags = ((tab-->(col))-->(1)));
    (oldv = ((tab-->(col))-->((row + COL_HSIZE))));
    if (((((flags)&(TB_COLUMN_ALLOCATED))) && ((oldv ~= 0 or TABLE_NOVALUE)))) {
        BlkValueFree(oldv);
    }
    (((tab-->(col))-->((row + COL_HSIZE))) = TABLE_NOVALUE);
    if (((flags)&(TB_COLUMN_NOBLANKBITS))) {
        rtrue;
    }
    (row)--;
    (at = (((tab-->(col))-->(2)) + (row/8)));
    ((TB_Blanks->(at)) = (((TB_Blanks->(at)))|((CheckTableEntryIsBlank_LU->((row%8))))));
];
[ ForceTableEntryNonBlank tab col row i at oldv flags tc kov;
    if ((col >= 100)) {
        (col = TableFindCol(tab, col));
    }
    if ((col == 0)) {
        rtrue;
    }
    if (((((tab-->(col))-->(1)))&(TB_COLUMN_NOBLANKBITS))) {
        rtrue;
    }
    (flags = ((tab-->(col))-->(1)));
    (oldv = ((tab-->(col))-->((row + COL_HSIZE))));
    if (((((flags)&(TB_COLUMN_ALLOCATED))) && ((oldv == 0 or TABLE_NOVALUE)))) {
        (kov = UNKNOWN_TY);
        (tc = ((((tab-->(col))-->(1)))&(TB_COLUMN_NUMBER)));
        (kov = TC_KOV(tc));
        if ((kov ~= UNKNOWN_TY)) {
            (((tab-->(col))-->((row + COL_HSIZE))) = BlkValueCreate(kov));
        }
    }
    (row)--;
    (at = (((tab-->(col))-->(2)) + (row/8)));
    ((TB_Blanks->(at)) = (((TB_Blanks->(at)))&((CheckTableEntryIsNonBlank_LU->((row%8))))));
];
[ TableSwapBlankBits tab row1 row2 col at1 at2 bit1 bit2;
    if ((col >= 100)) {
        (col = TableFindCol(tab, col));
    }
    if ((col == 0)) {
        rtrue;
    }
    if (((((tab-->(col))-->(1)))&(TB_COLUMN_NOBLANKBITS))) {
        rtrue;
    }
    (row1)--;
    (at1 = (((tab-->(col))-->(2)) + (row1/8)));
    (row2)--;
    (at2 = (((tab-->(col))-->(2)) + (row2/8)));
    (bit1 = (((TB_Blanks->(at1)))&((CheckTableEntryIsBlank_LU->((row1%8))))));
    (bit2 = (((TB_Blanks->(at2)))&((CheckTableEntryIsBlank_LU->((row2%8))))));
    if (bit1) {
        (bit1 = 1);
    }
    if (bit2) {
        (bit2 = 1);
    }
    if ((bit1 == bit2)) {
        rtrue;
    }
    if (bit1) {
        ((TB_Blanks->(at1)) = (((TB_Blanks->(at1)))&((CheckTableEntryIsNonBlank_LU->((row1%8))))));
        ((TB_Blanks->(at2)) = (((TB_Blanks->(at2)))|((CheckTableEntryIsBlank_LU->((row2%8))))));
    } else {
        ((TB_Blanks->(at1)) = (((TB_Blanks->(at1)))|((CheckTableEntryIsBlank_LU->((row1%8))))));
        ((TB_Blanks->(at2)) = (((TB_Blanks->(at2)))&((CheckTableEntryIsNonBlank_LU->((row2%8))))));
    }
];
[ TableMoveBlankBitsDown tab row1 row2 col at atp1 bit rx;
    if ((col >= 100)) {
        (col = TableFindCol(tab, col));
    }
    if ((col == 0)) {
        rtrue;
    }
    if (((((tab-->(col))-->(1)))&(TB_COLUMN_NOBLANKBITS))) {
        rtrue;
    }
    (row1)--;
    (row2)--;
    (at = (((tab-->(col))-->(2)) + (row1/8)));
    (bit = (((TB_Blanks->(at)))&((CheckTableEntryIsBlank_LU->((row1%8))))));
    if (bit) {
        (bit = 1);
    }
    for ((rx = row1):(rx < row2):(rx)++) {
        (atp1 = (((tab-->(col))-->(2)) + ((rx + 1)/8)));
        (at = (((tab-->(col))-->(2)) + (rx/8)));
        if ((((TB_Blanks->(atp1)))&((CheckTableEntryIsBlank_LU->(((rx + 1)%8)))))) {
            ((TB_Blanks->(at)) = (((TB_Blanks->(at)))|((CheckTableEntryIsBlank_LU->((rx%8))))));
        } else {
            ((TB_Blanks->(at)) = (((TB_Blanks->(at)))&((CheckTableEntryIsNonBlank_LU->((rx%8))))));
        }
    }
    (at = (((tab-->(col))-->(2)) + (row2/8)));
    if (bit) {
        ((TB_Blanks->(at)) = (((TB_Blanks->(at)))|((CheckTableEntryIsBlank_LU->((row2%8))))));
    } else {
        ((TB_Blanks->(at)) = (((TB_Blanks->(at)))&((CheckTableEntryIsNonBlank_LU->((row2%8))))));
    }
];
[ TableRowCorr tab col lookup_value lookup_col i j f v;
    if ((col >= 100)) {
        (col = TableFindCol(tab, col, 1));
    }
    (lookup_col = (tab-->(col)));
    (j = ((lookup_col-->(0)) - COL_HSIZE));
    if (((((tab-->(col))-->(1)))&(TB_COLUMN_ALLOCATED))) {
        (f = 1);
    }
    if (f) {
        for ((i = 1):(i <= j):(i)++) {
            (v = (lookup_col-->((i + COL_HSIZE))));
            if ((((v == TABLE_NOVALUE)) && (CheckTableEntryIsBlank(tab, col, i)))) {
                continue;
            }
            if ((BlkValueCompare(v, lookup_value) == 0)) {
                return i;
            }
        }
    } else {
        for ((i = 1):(i <= j):(i)++) {
            if ((((lookup_value == TABLE_NOVALUE)) && (CheckTableEntryIsBlank(tab, col, i)))) {
                continue;
            }
            if (((lookup_col-->((i + COL_HSIZE))) == lookup_value)) {
                return i;
            }
        }
    }
    return RunTimeProblem(RTP_TABLE_NOCORR, tab);
];
[ ExistsTableRowCorr tab col entry i k v f kov;
    if ((col >= 100)) {
        (col = TableFindCol(tab, col));
    }
    if ((col == 0)) {
        rfalse;
    }
    (f = 0);
    if (((((tab-->(col))-->(1)))&(TB_COLUMN_TOPIC))) {
        (f = 1);
    } else {
        if (((((tab-->(col))-->(1)))&(TB_COLUMN_ALLOCATED))) {
            (f = 2);
        }
    }
    (k = TableRows(tab));
    for ((i = 1):(i <= k):(i)++) {
        (v = ((tab-->(col))-->((i + COL_HSIZE))));
        if ((((v == TABLE_NOVALUE)) && (CheckTableEntryIsBlank(tab, col, i)))) {
            continue;
        }
        switch (f) {
            1:
                if (((v)((entry/100),(entry%100)) ~= GPR_FAIL)) {
                    return i;
                }
                ;
            2:
                if ((BlkValueCompare(v, entry) == 0)) {
                    return i;
                }
                ;
            default:
                if ((v == entry)) {
                    return i;
                }
                ;
        }
    }
    rfalse;
];
[ TableLookUpCorr tab col1 col2 lookup_value write_flag write_value cola1 cola2 i j v f;
    if ((col1 >= 100)) {
        (col1 = TableFindCol(tab, col1, 1));
    }
    if ((col2 >= 100)) {
        (col2 = TableFindCol(tab, col2, 1));
    }
    (cola1 = (tab-->(col1)));
    (cola2 = (tab-->(col2)));
    (j = (cola2-->(0)));
    (f = 0);
    if (((((tab-->(col2))-->(1)))&(TB_COLUMN_ALLOCATED))) {
        (f = 1);
    }
    if (((((tab-->(col2))-->(1)))&(TB_COLUMN_TOPIC))) {
        (f = 2);
    }
    for ((i = (1 + COL_HSIZE)):(i <= j):(i)++) {
        (v = (cola2-->(i)));
        if ((((v == TABLE_NOVALUE)) && (CheckTableEntryIsBlank(tab, col2, (i - COL_HSIZE))))) {
            continue;
        }
        if ((f == 1)) {
            if ((BlkValueCompare(v, lookup_value) ~= 0)) {
                continue;
            }
        } else {
            if ((f == 2)) {
                if (((v)((lookup_value/100),(lookup_value%100)) == GPR_FAIL)) {
                    continue;
                }
            } else {
                if ((v ~= lookup_value)) {
                    continue;
                }
            }
        }
        if (write_flag) {
            if ((write_flag == 4)) {
                ForceTableEntryBlank(tab, col1, (i - COL_HSIZE));
            } else {
                ForceTableEntryNonBlank(tab, col1, (i - COL_HSIZE));
            }
            switch (write_flag) {
                1:
                    ((cola1-->(i)) = write_value);
                    ;
                2:
                    ((cola1-->(i)) = ((cola1-->(i)) + write_value));
                    ;
                3:
                    ((cola1-->(i)) = ((cola1-->(i)) - write_value));
                    ;
                5:
                    return (cola1-->(i));
                    ;
            }
            rfalse;
        }
        (v = (cola1-->(i)));
        if ((((v == TABLE_NOVALUE)) && (CheckTableEntryIsBlank(tab, col1, (i - COL_HSIZE))))) {
            continue;
        }
        return v;
    }
    return RunTimeProblem(RTP_TABLE_NOCORR, tab);
];
[ ExistsTableLookUpCorr tab col1 col2 lookup_value cola1 cola2 i j f;
    if ((col1 >= 100)) {
        (col1 = TableFindCol(tab, col1, 0));
    }
    if ((col2 >= 100)) {
        (col2 = TableFindCol(tab, col2, 0));
    }
    if (((col1*col2) == 0)) {
        rfalse;
    }
    (cola1 = (tab-->(col1)));
    (cola2 = (tab-->(col2)));
    (j = (cola2-->(0)));
    (f = 0);
    if (((((tab-->(col2))-->(1)))&(TB_COLUMN_ALLOCATED))) {
        (f = 1);
    }
    if (((((tab-->(col2))-->(1)))&(TB_COLUMN_TOPIC))) {
        (f = 2);
    }
    for ((i = (1 + COL_HSIZE)):(i <= j):(i)++) {
        if (((((cola1-->(i)) == TABLE_NOVALUE)) && (CheckTableEntryIsBlank(tab, col1, (i - COL_HSIZE))))) {
            continue;
        }
        if ((f == 1)) {
            if ((BlkValueCompare((cola2-->(i)), lookup_value) ~= 0)) {
                continue;
            }
        } else {
            if ((f == 2)) {
                if ((((cola2-->(i)))((lookup_value/100),(lookup_value%100)) == GPR_FAIL)) {
                    continue;
                }
            } else {
                if (((cola2-->(i)) ~= lookup_value)) {
                    continue;
                }
            }
        }
        rtrue;
    }
    rfalse;
];
[ TableLookUpEntry tab col index write_flag write_value v;
    if ((tab == 0)) {
        return RunTimeProblem(RTP_TABLE_NOTABLE2);
    }
    if ((col >= 100)) {
        (col = TableFindCol(tab, col, 1));
    }
    if ((((index < 1)) || ((index > TableRows(tab))))) {
        RunTimeProblem(RTP_TABLE_NOROW, tab, index);
        (index = 1);
    }
    if (write_flag) {
        switch (write_flag) {
            1:
                ForceTableEntryNonBlank(tab, col, index);
                (((tab-->(col))-->((index + COL_HSIZE))) = write_value);
                ;
            2:
                ForceTableEntryNonBlank(tab, col, index);
                (((tab-->(col))-->((index + COL_HSIZE))) = (((tab-->(col))-->((index + COL_HSIZE))) + write_value));
                ;
            3:
                ForceTableEntryNonBlank(tab, col, index);
                (((tab-->(col))-->((index + COL_HSIZE))) = (((tab-->(col))-->((index + COL_HSIZE))) - write_value));
                ;
            4:
                ForceTableEntryBlank(tab, col, index);
                ;
            5:
                ForceTableEntryNonBlank(tab, col, index);
                return ((tab-->(col))-->((index + COL_HSIZE)));
                ;
        }
        rfalse;
    }
    (v = ((tab-->(col))-->((index + COL_HSIZE))));
    if ((((v == TABLE_NOVALUE)) && (CheckTableEntryIsBlank(tab, col, index)))) {
        RunTimeProblem(RTP_TABLE_NOENTRY, tab, col, index);
        rfalse;
    }
    return v;
];
[ ExistsTableLookUpEntry tab col index v;
    if ((col >= 100)) {
        (col = TableFindCol(tab, col));
    }
    if ((col == 0)) {
        rfalse;
    }
    if ((((index < 1)) || ((index > TableRows(tab))))) {
        rfalse;
    }
    (v = ((tab-->(col))-->((index + COL_HSIZE))));
    if ((((v == TABLE_NOVALUE)) && (CheckTableEntryIsBlank(tab, col, index)))) {
        rfalse;
    }
    rtrue;
];
[ TableRowIsBlank tab j k;
    for ((k = 1):(k <= (tab-->(0))):(k)++) {
        if ((((tab-->(k))-->((j + COL_HSIZE))) ~= TABLE_NOVALUE)) {
            rfalse;
        }
        if ((CheckTableEntryIsBlank(tab, k, j) == 0)) {
            rfalse;
        }
    }
    rtrue;
];
[ TableBlankOutRow tab row k;
    if ((tab == 0)) {
        return RunTimeProblem(RTP_TABLE_NOTABLE);
    }
    for ((k = 1):(k <= (tab-->(0))):(k)++) {
        ForceTableEntryBlank(tab, k, row);
    }
];
[ TableBlankOutColumn tab col n k;
    if ((tab == 0)) {
        return RunTimeProblem(RTP_TABLE_NOTABLE);
    }
    (n = TableRows(tab));
    for ((k = 1):(k <= n):(k)++) {
        ForceTableEntryBlank(tab, col, k);
    }
];
[ TableBlankOutAll tab n k;
    if ((tab == 0)) {
        return RunTimeProblem(RTP_TABLE_NOTABLE);
    }
    (n = TableRows(tab));
    for ((k = 1):(k <= n):(k)++) {
        TableBlankOutRow(tab, k);
    }
];
[ TableBlankRows tab i j c;
    (i = TableRows(tab));
    for ((j = 1):(j <= i):(j)++) {
        if (TableRowIsBlank(tab, j)) {
            (c)++;
        }
    }
    return c;
];
[ TableFilledRows tab;
    return (TableRows(tab) - TableBlankRows(tab));
];
[ TableBlankRow tab i j;
    (i = TableRows(tab));
    for ((j = 1):(j <= i):(j)++) {
        if (TableRowIsBlank(tab, j)) {
            return j;
        }
    }
    RunTimeProblem(RTP_TABLE_NOMOREBLANKS, tab);
    return i;
];
[ TableRandomRow tab i j k;
    (i = TableRows(tab));
    (j = TableFilledRows(tab));
    if ((j == 0)) {
        return RunTimeProblem(RTP_TABLE_NOROWS, tab);
    }
    if ((j > 1)) {
        (j = random(j));
    }
    for ((k = 1):(k <= i):(k)++) {
        if ((TableRowIsBlank(tab, k) == 0)) {
            (j)--;
        }
        if ((j == 0)) {
            return k;
        }
    }
];
[ TableSwapRows tab i j k l v1 v2;
    if ((i == j)) {
        rtrue;
    }
    (l = (tab-->(0)));
    for ((k = 1):(k <= l):(k)++) {
        (v1 = ((tab-->(k))-->((i + COL_HSIZE))));
        (v2 = ((tab-->(k))-->((j + COL_HSIZE))));
        (((tab-->(k))-->((i + COL_HSIZE))) = v2);
        (((tab-->(k))-->((j + COL_HSIZE))) = v1);
        if ((((v1 == TABLE_NOVALUE)) || ((v2 == TABLE_NOVALUE)))) {
            TableSwapBlankBits(tab, i, j, k);
        }
    }
];
[ TableCompareRows tab col row1 row2 dir val1 val2 bl1 bl2 f;
    if ((col >= 100)) {
        (col = TableFindCol(tab, col, 0));
    }
    (val1 = ((tab-->(col))-->((row1 + COL_HSIZE))));
    (val2 = ((tab-->(col))-->((row2 + COL_HSIZE))));
    if ((val1 == TABLE_NOVALUE)) {
        (bl1 = CheckTableEntryIsBlank(tab, col, row1));
    }
    if ((val2 == TABLE_NOVALUE)) {
        (bl2 = CheckTableEntryIsBlank(tab, col, row2));
    }
    if ((((val1 == val2)) && ((bl1 == bl2)))) {
        if ((val1 ~= TABLE_NOVALUE)) {
            rfalse;
        }
        if ((bl1 == 0)) {
            rfalse;
        }
        if (TableRowIsBlank(tab, row1)) {
            if (TableRowIsBlank(tab, row2)) {
                rfalse;
            }
            return (-(dir));
        }
        if (TableRowIsBlank(tab, row2)) {
            return dir;
        }
        rfalse;
    }
    if (bl1) {
        return dir;
    }
    if (bl2) {
        return (-(dir));
    }
    (f = ((tab-->(col))-->(1)));
    if (((f)&(TB_COLUMN_ALLOCATED))) {
        if ((BlkValueCompare(val2, val1) < 0)) {
            rtrue;
        }
        return (-(1));
    } else {
        if (((f)&(TB_COLUMN_REAL))) {
            if ((REAL_NUMBER_TY_Compare(val1, val2) > 0)) {
                rtrue;
            }
            return (-(1));
        } else {
            if (((f)&(TB_COLUMN_SIGNED))) {
                if ((val1 > val2)) {
                    rtrue;
                }
                return (-(1));
            } else {
                if ((UnsignedCompare(val1, val2) > 0)) {
                    rtrue;
                }
                return (-(1));
            }
        }
    }
];
[ TableMoveRowDown tab r1 r2 rx k l m v f;
    if ((r1 == r2)) {
        rtrue;
    }
    (l = (tab-->(0)));
    for ((k = 1):(k <= l):(k)++) {
        (f = 0);
        (m = ((tab-->(k))-->((r1 + COL_HSIZE))));
        if ((m == TABLE_NOVALUE)) {
            (f = 1);
        }
        for ((rx = r1):(rx < r2):(rx)++) {
            (v = ((tab-->(k))-->(((rx + COL_HSIZE) + 1))));
            (((tab-->(k))-->((rx + COL_HSIZE))) = v);
            if ((v == TABLE_NOVALUE)) {
                (f = 1);
            }
        }
        (((tab-->(k))-->((r2 + COL_HSIZE))) = m);
        if (f) {
            TableMoveBlankBitsDown(tab, r1, r2, k);
        }
    }
];
[ TableShuffle tab i to;
    TableMoveBlanksToBack(tab, 1, TableRows(tab));
    (to = TableFilledRows(tab));
    for ((i = 2):(i <= to):(i)++) {
        TableSwapRows(tab, i, random(i));
    }
];
[ TableNextRow tab col row dir i k val v dv min_dv min_at signed_arithmetic f blk z;
    if ((col >= 100)) {
        (col = TableFindCol(tab, col, 0));
    }
    (f = ((tab-->(col))-->(1)));
    if (((f)&(TB_COLUMN_ALLOCATED))) {
        (blk = 1);
    }
    (signed_arithmetic = ((f)&(TB_COLUMN_SIGNED)));
    if ((row == 0)) {
        if (signed_arithmetic) {
            if ((dir == 1)) {
                (val = -2147483648);
            } else {
                (val = 2147483647);
            }
        } else {
            if ((dir == 1)) {
                (val = 0);
            } else {
                (val = -1);
            }
        }
    } else {
        (val = ((tab-->(col))-->((row + COL_HSIZE))));
    }
    if (signed_arithmetic) {
        (min_dv = 2147483647);
    } else {
        (min_dv = -1);
    }
    (k = TableRows(tab));
    if ((dir == 1)) {
        for ((i = 1):(i <= k):(i)++) {
            (v = ((tab-->(col))-->((i + COL_HSIZE))));
            if ((((v == TABLE_NOVALUE)) && (CheckTableEntryIsBlank(tab, col, i)))) {
                continue;
            }
            if (blk) {
                (dv = v);
                if ((row == 0)) {
                    (z = 1);
                } else {
                    (z = BlkValueCompare(v, val));
                }
                (f = (((((z > 0)) || ((((z == 0)) && ((i > row)))))) && ((((min_at == 0)) || ((BlkValueCompare(v, min_dv) < 0))))));
            } else {
                (dv = (dir*v));
                if (signed_arithmetic) {
                    (f = (((((dv > (dir*val))) || ((((v == val)) && ((i > row)))))) && ((dv < min_dv))));
                } else {
                    (f = (((((UnsignedCompare(dv, (dir*val)) > 0)) || ((((v == val)) && ((i > row)))))) && ((UnsignedCompare(dv, min_dv) < 0))));
                }
            }
            if (f) {
                (min_dv = dv);
                (min_at = i);
            }
        }
    } else {
        for ((i = k):(i >= 1):(i)--) {
            (v = ((tab-->(col))-->((i + COL_HSIZE))));
            if ((((v == TABLE_NOVALUE)) && (CheckTableEntryIsBlank(tab, col, i)))) {
                continue;
            }
            if (blk) {
                (dv = v);
                if ((row == 0)) {
                    (z = -1);
                } else {
                    (z = BlkValueCompare(v, val));
                }
                (f = (((((z < 0)) || ((((z == 0)) && ((i < row)))))) && ((((min_at == 0)) || ((BlkValueCompare(v, min_dv) > 0))))));
            } else {
                (dv = (dir*v));
                if (signed_arithmetic) {
                    (f = (((((dv > (dir*val))) || ((((v == val)) && ((i < row)))))) && ((dv < min_dv))));
                } else {
                    (f = (((((UnsignedCompare(dv, (dir*val)) > 0)) || ((((v == val)) && ((i < row)))))) && ((UnsignedCompare(dv, min_dv) < 0))));
                }
            }
            if (f) {
                (min_dv = dv);
                (min_at = i);
            }
        }
    }
    return min_at;
];
[ TableMoveBlanksToBack tab fromrow torow i fbl lnbl blc;
    if ((torow < fromrow)) {
        rtrue;
    }
    (fbl = 0);
    (lnbl = 0);
    for ((i = fromrow):(i <= torow):(i)++) {
        if (TableRowIsBlank(tab, i)) {
            if ((fbl == 0)) {
                (fbl = i);
            }
            (blc)++;
        } else {
            (lnbl = i);
        }
    }
    if ((((((fbl > 0)) && ((lnbl > 0)))) && ((fbl < lnbl)))) {
        TableMoveRowDown(tab, fbl, lnbl);
        TableMoveBlanksToBack(tab, fbl, (lnbl - 1));
    }
    return (torow - blc);
];
[ TableSort tab col dir algorithm i j k f;
    for ((i = 1):(i <= (tab-->(0))):(i)++) {
        (j = (tab-->(i)));
        if ((((j-->(1)))&(TB_COLUMN_DONTSORTME))) {
            return RunTimeProblem(RTP_TABLE_CANTSORT, tab);
        }
    }
    if ((col >= 100)) {
        (col = TableFindCol(tab, col, 0));
    }
    (k = TableRows(tab));
    (k = TableMoveBlanksToBack(tab, 1, k));
    SetSortDomain(TableSwapRows, TableCompareRows);
    SortArray(tab, col, dir, k, algorithm);
];
[ TablePrint tab i j k row col v tc kov;
    for ((i = 1):(i <= (tab-->(0))):(i)++) {
        (j = (tab-->(i)));
        if (((((j-->(1)))&(TB_COLUMN_CANEXCHANGE)) == 0)) {
            rtrue;
        }
    }
    (k = TableRows(tab));
    (k = TableMoveBlanksToBack(tab, 1, k));
    print "! ";
    PrintTableName(tab);
    print " (";
    print k;
    print ")^";
    for ((row = 1):(row <= k):(row)++) {
        for ((col = 1):(col <= (tab-->(0))):(col)++) {
            (tc = ((((tab-->(col))-->(1)))&(TB_COLUMN_NUMBER)));
            (kov = KindAtomic(TC_KOV(tc)));
            if ((kov == UNKNOWN_TY)) {
                (kov = NUMBER_TY);
            }
            (v = ((tab-->(col))-->((row + COL_HSIZE))));
            if ((((v == TABLE_NOVALUE)) && (CheckTableEntryIsBlank(tab, col, row)))) {
                print "-- ";
            } else {
                if ((BlkValueWriteToFile(v, kov) == 0)) {
                    print v;
                }
                print " ";
            }
        }
        print "^";
    }
    rfalse;
];
[ TableRead tab auxf row maxrow col ch v sgn dg j tc kov;
    for ((col = 1):(col <= (tab-->(0))):(col)++) {
        (j = (tab-->(col)));
        if (((((j-->(1)))&(TB_COLUMN_CANEXCHANGE)) == 0)) {
            return RunTimeProblem(RTP_TABLE_CANTSAVE, tab);
        }
    }
    (maxrow = TableRows(tab));
    for ((row = 1):(row <= maxrow):(row)++) {
        TableBlankOutRow(tab, row);
    }
    for ((row = 1):(row <= maxrow):(row)++) {
        (ch = FileIO_GetC(auxf));
        if ((ch == 33)) {
            while ((ch ~= -1 or 10 or 13)) {
                (ch = FileIO_GetC(auxf));
            }
            while ((ch == 10 or 13)) {
                (ch = FileIO_GetC(auxf));
            }
        }
        for ((col = 1):(col <= (tab-->(0))):(col)++) {
            if ((ch == -1)) {
                (row)++;
                jump NoMore;
            }
            if ((ch == 10 or 13)) {
                break;
            }
            (tc = ((((tab-->(col))-->(1)))&(TB_COLUMN_NUMBER)));
            (kov = KindAtomic(TC_KOV(tc)));
            if ((kov == UNKNOWN_TY)) {
                (kov = NUMBER_TY);
            }
            (sgn = 1);
            if ((ch == 45)) {
                (ch = FileIO_GetC(auxf));
                if ((ch == -1)) {
                    jump NotTable;
                }
                if ((ch == 45)) {
                    (ch = FileIO_GetC(auxf));
                    jump EntryDone;
                }
                (sgn = -1);
            }
            if (((((tab-->(col))-->(1)))&(TB_COLUMN_ALLOCATED))) {
                ForceTableEntryNonBlank(tab, col, row);
            }
            (v = BlkValueReadFromFile(0, 0, (-(1)), kov));
            if (v) {
                if (((((tab-->(col))-->(1)))&(TB_COLUMN_ALLOCATED))) {
                    (v = BlkValueReadFromFile(TableLookUpEntry(tab, col, row), auxf, ch, kov));
                } else {
                    (v = BlkValueReadFromFile(0, auxf, ch, kov));
                }
                (ch = 32);
            } else {
                (dg = (ch - 48));
                if ((((dg < 0)) || ((dg > 9)))) {
                    jump NotTable;
                }
                (v = dg);
                for (:1:) {
                    (ch = FileIO_GetC(auxf));
                    (dg = (ch - 48));
                    if ((((dg < 0)) || ((dg > 9)))) {
                        break;
                    }
                    (v = ((10*v) + dg));
                }
                (v = (v*sgn));
            }
            if ((((((tab-->(col))-->(1)))&(TB_COLUMN_ALLOCATED)) == 0)) {
                TableLookUpEntry(tab, col, row, 1, v);
            }
            .EntryDone;
            while ((ch == 9 or 32)) {
                (ch = FileIO_GetC(auxf));
            }
        }
        while ((ch ~= -1 or 10 or 13)) {
            if ((((ch ~= 45)) && (((((ch - 48) < 0)) || (((ch - 48) > 9)))))) {
                jump NotTable;
            }
            if ((ch ~= 9 or 32)) {
                jump WontFit;
            }
            (ch = FileIO_GetC(auxf));
        }
    }
    .NoMore;
    while ((ch == 9 or 32 or 10 or 13)) {
        (ch = FileIO_GetC(auxf));
    }
    if ((ch == -1)) {
        rtrue;
    }
    .WontFit;
    return RunTimeProblem(RTP_TABLE_WONTFIT, tab);
    .NotTable;
    return RunTimeProblem(RTP_TABLE_BADFILE, tab);
];
[ TableColumnDebug tab col k i v tc kov;
    if ((col >= 100)) {
        (col = TableFindCol(tab, col, 0));
    }
    (k = TableRows(tab));
    (tc = ((((tab-->(col))-->(1)))&(TB_COLUMN_NUMBER)));
    (kov = TC_KOV(tc));
    for ((i = 1):(i <= k):(i)++) {
        if ((i > 1)) {
            print ", ";
        }
        (v = ((tab-->(col))-->((i + COL_HSIZE))));
        if ((((v == TABLE_NOVALUE)) && (CheckTableEntryIsBlank(tab, col, i)))) {
            print "--";
        } else {
            PrintKindValuePair(kov, v);
        }
    }
    (say__p = 1);
];
[ TableRowDebug tab i col k v tc kov;
    (k = TableRows(tab));
    if ((((i < 1)) || ((i > k)))) {
        print "No such row";
        new_line;
        rtrue;
    }
    print "(row ";
    print i;
    print ")  |";
    for ((col = 1):(col <= (tab-->(0))):(col)++) {
        print " ";
        (tc = ((((tab-->(col))-->(1)))&(TB_COLUMN_NUMBER)));
        (kov = TC_KOV(tc));
        (v = ((tab-->(col))-->((i + COL_HSIZE))));
        if ((((v == TABLE_NOVALUE)) && (CheckTableEntryIsBlank(tab, col, i)))) {
            print "-- ";
        } else {
            PrintKindValuePair(kov, v);
            print " |";
        }
    }
    (say__p = 1);
];
[ TableDebug tab i k;
    PrintTableName(tab);
    print "^";
    (k = TableRows(tab));
    for ((i = 1):(i <= k):(i)++) {
        TableRowDebug(tab, i);
        print "^";
    }
];
[ Mstack_Create_Frame creator id extent;
    if ((creator == 0)) {
        rfalse;
    }
    (extent = (creator)((MStack_Top + 2),1));
    if ((extent == 0)) {
        rfalse;
    }
    if (((MStack_Top + MAX_MSTACK_FRAME) >= (MSTACK_SIZE + 2))) {
        RunTimeProblem(RTP_MSTACKMEMORY, MSTACK_SIZE);
        Mstack_Backtrace();
        rfalse;
    }
    (MStack_Top)++;
    ((MStack-->(MStack_Top)) = id);
    (MStack_Top)++;
    (MStack_Top = (MStack_Top + extent));
    ((MStack-->(MStack_Top)) = (-((extent + 2))));
    rtrue;
];
[ Mstack_Destroy_Frame creator id pos;
    (pos = Mstack_Seek_Frame(id));
    if ((pos == 0)) {
        rfalse;
    }
    (MStack_Top = (pos - 2));
    if (creator) {
        (creator)(pos,(-(1)));
    }
    rtrue;
];
[ Mstack_Seek_Frame id pos;
    (pos = MStack_Top);
    while ((((pos > 0)) && (((MStack-->(pos)) ~= 0)))) {
        (MStack_Frame_Extent = (MStack-->(pos)));
        (pos = (pos + MStack_Frame_Extent));
        (MStack_Frame_Extent = (-2 - MStack_Frame_Extent));
        if (((MStack-->((pos + 1))) == id)) {
            return (pos + 2);
        }
    }
    (MStack_Frame_Extent = 0);
    rfalse;
];
[ Mstack_Backtrace pos k;
    print "Mstack backtrace: size ";
    print (MStack_Top + 1);
    print " words^";
    (pos = MStack_Top);
    while (((MStack-->(pos)) ~= 0)) {
        (MStack_Frame_Extent = (MStack-->(pos)));
        (pos = (pos + MStack_Frame_Extent));
        (MStack_Frame_Extent = (-2 - MStack_Frame_Extent));
        print "Block at ";
        print (pos + 2);
        print " owner ID ";
        print (MStack-->((pos + 1)));
        print " size ";
        print MStack_Frame_Extent;
        print "^";
        for ((k = 0):(k < MStack_Frame_Extent):(k)++) {
            print (MStack-->(((pos + 2) + k)));
            print " ";
        }
        print "^";
    }
];
[ MstVO id off pos;
    (pos = Mstack_Seek_Frame(id));
    if ((pos == 0)) {
        print "Variable unavailable for this action, activity or rulebook: ";
        print "internal ID number ";
        print id;
        print "/";
        print off;
        print "^";
        rfalse;
    }
    if ((((off < 0)) || ((off >= MStack_Frame_Extent)))) {
        print "Variable stack offset wrong: ";
        print id;
        print "/";
        print off;
        print " at ";
        print pos;
        print "^";
        rfalse;
    }
    return (pos + off);
];
[ MstVON id off pos;
    (pos = Mstack_Seek_Frame(id));
    if ((pos == 0)) {
        rfalse;
    }
    if ((((off < 0)) || ((off >= MStack_Frame_Extent)))) {
        print "Variable stack offset wrong: ";
        print id;
        print "/";
        print off;
        print " at ";
        print pos;
        print "^";
        rfalse;
    }
    return (pos + off);
];
[ MStack_CreateRBVars rb cr;
    (cr = MStack_GetRBVarCreator(rb));
    if (cr) {
        Mstack_Create_Frame(cr, rb);
    }
];
[ MStack_DestroyRBVars rb cr;
    (cr = MStack_GetRBVarCreator(rb));
    if (cr) {
        Mstack_Destroy_Frame(cr, rb);
    }
];
[ MStack_CreateAVVars av cr;
    (cr = (activity_var_creators-->(av)));
    if ((cr == 0)) {
        rtrue;
    }
    Mstack_Create_Frame(cr, (av + 10000));
];
[ MStack_DestroyAVVars av cr;
    (cr = (activity_var_creators-->(av)));
    if ((cr == 0)) {
        rtrue;
    }
    Mstack_Destroy_Frame(cr, (av + 10000));
];
[ RecordRuleOutcome usage strong_kind val;
    if (((((latest_rule_result-->(0)) == RS_SUCCEEDS or RS_FAILS)) && (KOVIsBlockValue((latest_rule_result-->(1)))))) {
        BlkValueFree((latest_rule_result-->(2)));
    }
    if ((((usage == RS_SUCCEEDS or RS_FAILS)) && (KOVIsBlockValue(strong_kind)))) {
        (val = BlkValueCopy(BlkValueCreate(strong_kind), val));
    }
    ((latest_rule_result-->(0)) = usage);
    ((latest_rule_result-->(1)) = strong_kind);
    ((latest_rule_result-->(2)) = val);
];
[ FollowRulebook rulebook parameter no_paragraph_skips rv ss spv;
    (ss = self);
    if (((((Protect_I7_Arrays-->(0)) ~= 16339)) || (((Protect_I7_Arrays-->(1)) ~= 12345)))) {
        print "^^*** Fatal programming error: I7 arrays corrupted ***^^";
        @quit;
    }
    if (parameter) {
        (self = parameter);
        (parameter_object = parameter);
    }
    (spv = parameter_value);
    (parameter_value = parameter);
    (parameter = debugging_rules);
    if (debugging_rules) {
        DebugRulebooks(rulebook, parameter);
        (process_rulebook_count = (process_rulebook_count + debugging_rules));
    }
    if ((((rulebook >= 0)) && ((rulebook < NUMBER_RULEBOOKS_CREATED)))) {
        (rv = (rulebooks_array-->(rulebook)));
        if ((rv ~= EMPTY_RULEBOOK)) {
            if ((rulebook ~= ACTION_PROCESSING_RB)) {
                MStack_CreateRBVars(rulebook);
            }
            if (say__p) {
                RulebookParBreak(no_paragraph_skips);
            }
            (rv = (rv)(no_paragraph_skips));
            if ((rulebook ~= ACTION_PROCESSING_RB)) {
                MStack_DestroyRBVars(rulebook);
            }
        } else {
            (rv = 0);
        }
    } else {
        if (say__p) {
            RulebookParBreak(no_paragraph_skips);
        }
        (rv = (rulebook)());
        if ((rv == 2)) {
            (rv = reason_the_action_failed);
        } else {
            if (rv) {
                (rv = rulebook);
            }
        }
    }
    if (rv) {
        if (debugging_rules) {
            (process_rulebook_count = (process_rulebook_count - debugging_rules));
            if ((process_rulebook_count < 0)) {
                (process_rulebook_count = 0);
            }
            spaces (2*process_rulebook_count);
            if (((latest_rule_result-->(0)) == RS_SUCCEEDS)) {
                print "[stopped: success]^";
            }
            if (((latest_rule_result-->(0)) == RS_FAILS)) {
                print "[stopped: fail]^";
            }
        }
    } else {
        if (debugging_rules) {
            (process_rulebook_count = (process_rulebook_count - debugging_rules));
        }
        ((latest_rule_result-->(0)) = RS_NEITHER);
    }
    (debugging_rules = parameter);
    (self = ss);
    (parameter_value = spv);
    return rv;
];
[ RulebookParBreak no_paragraph_skips;
    if ((((no_paragraph_skips == 0)) && ((((say__pc)&(PARA_NORULEBOOKBREAKS)) == 0)))) {
        DivideParagraphPoint();
    }
];
[ ActRulebookSucceeds rule_id;
    if (rule_id) {
        (reason_the_action_failed = rule_id);
    }
    RulebookSucceeds();
];
[ ActRulebookFails rule_id;
    if (rule_id) {
        (reason_the_action_failed = rule_id);
    }
    RulebookFails();
];
[ RulebookSucceeds strong_kind value;
    RecordRuleOutcome(RS_SUCCEEDS, strong_kind, value);
];
[ RulebookFails strong_kind value;
    RecordRuleOutcome(RS_FAILS, strong_kind, value);
];
[ RuleHasNoOutcome;
    RecordRuleOutcome(RS_NEITHER, 0, 0);
];
[ SetRulebookOutcome a;
    ((latest_rule_result-->(0)) = a);
];
[ RulebookOutcome a;
    (a = (latest_rule_result-->(0)));
    if ((((a == RS_FAILS)) || ((a == RS_SUCCEEDS)))) {
        return a;
    }
    return RS_NEITHER;
];
[ RulebookFailed;
    if (((latest_rule_result-->(0)) == RS_FAILS)) {
        rtrue;
    }
    rfalse;
];
[ RulebookSucceeded;
    if (((latest_rule_result-->(0)) == RS_SUCCEEDS)) {
        rtrue;
    }
    rfalse;
];
[ ResultOfRule RB V F K a;
    if (RB) {
        FollowRulebook(RB, V, F);
    }
    (a = (latest_rule_result-->(0)));
    if ((((a == RS_FAILS)) || ((a == RS_SUCCEEDS)))) {
        (a = (latest_rule_result-->(1)));
        if (a) {
            return (latest_rule_result-->(2));
        }
    }
    if (K) {
        return DefaultValueOfKOV(K);
    }
    rfalse;
];
[ RULEBOOK_TY_to_RULE_TY r;
    return r;
];
[ DebugRulebooks subs parameter i;
    spaces (2*process_rulebook_count);
    print "[";
    RulePrintingRule(subs);
    if (parameter) {
        print " / on O";
        print parameter;
    }
    print "]^";
];
[ DB_Rule R N blocked;
    if ((R == 0)) {
        rtrue;
    }
    print "[Rule ~";
    RulePrintingRule(R);
    print "~ ";
    if ((blocked == 0)) {
        print "applies.]";
        new_line;
        rtrue;
    }
    print "does not apply (wrong ";
    if ((blocked == 1)) {
        print "scene";
    }
    if ((blocked == 2)) {
        print "action";
    }
    if ((blocked == 3)) {
        print "actor";
    }
    if ((blocked == 4)) {
        print "context";
    }
    print ").]^";
];
[ LITTLE_USED_DO_NOTHING_R;
    rfalse;
];
[ EMPTY_RULEBOOK forbid_breaks;
    rfalse;
];
[ HeapInitialise n bsize blk2;
    (blk2 = (Flex_Heap + BLK_DATA_MULTI_OFFSET));
    ((Flex_Heap->(BLK_HEADER_N)) = 4);
    ((Flex_Heap-->(BLK_HEADER_KOV)) = 0);
    ((Flex_Heap-->(BLK_HEADER_RCOUNT)) = MAX_POSITIVE_NUMBER);
    ((Flex_Heap->(BLK_HEADER_FLAGS)) = BLK_FLAG_MULTIPLE);
    ((Flex_Heap-->(BLK_NEXT)) = blk2);
    ((Flex_Heap-->(BLK_PREV)) = NULL);
    for ((bsize = 1):(bsize < MEMORY_HEAP_SIZE):(bsize = (bsize*2))) {
        (n)++;
    }
    ((blk2->(BLK_HEADER_N)) = n);
    ((blk2-->(BLK_HEADER_KOV)) = 0);
    ((blk2-->(BLK_HEADER_RCOUNT)) = 0);
    ((blk2->(BLK_HEADER_FLAGS)) = BLK_FLAG_MULTIPLE);
    ((blk2-->(BLK_NEXT)) = NULL);
    ((blk2-->(BLK_PREV)) = Flex_Heap);
];
[ HeapNetFreeSpace multiple txb asize;
    for ((txb = (Flex_Heap-->(BLK_NEXT))):(txb ~= NULL):(txb = (txb-->(BLK_NEXT)))) {
        (asize = (asize + FlexSize(txb)));
        if (multiple) {
            (asize = (asize - BLK_DATA_MULTI_OFFSET));
        } else {
            (asize = (asize - BLK_DATA_OFFSET));
        }
    }
    return asize;
];
[ HeapMakeSpace size multiple newblocksize newblock B n hsize;
    for (:1:) {
        if (multiple) {
            (hsize = BLK_DATA_MULTI_OFFSET);
            if ((HeapNetFreeSpace(multiple) >= size)) {
                rtrue;
            }
        } else {
            (hsize = BLK_DATA_OFFSET);
            if ((HeapLargestFreeBlock(0) >= size)) {
                rtrue;
            }
        }
        (newblocksize = 1);
        for ((n = 0):(((n < SMALLEST_BLK_WORTH_ALLOCATING)) || ((newblocksize < (size + hsize)))):(n)++) {
            (newblocksize = (newblocksize*2));
        }
        (newblock = VM_AllocateMemory(newblocksize));
        if ((newblock == 0)) {
            rfalse;
        }
        ((newblock->(BLK_HEADER_N)) = n);
        ((newblock-->(BLK_HEADER_KOV)) = 0);
        ((newblock-->(BLK_HEADER_RCOUNT)) = 0);
        ((newblock->(BLK_HEADER_FLAGS)) = BLK_FLAG_MULTIPLE);
        ((newblock-->(BLK_NEXT)) = NULL);
        ((newblock-->(BLK_PREV)) = NULL);
        for ((B = (Flex_Heap-->(BLK_NEXT))):(B ~= NULL):(B = (B-->(BLK_NEXT)))) {
            if (((B-->(BLK_NEXT)) == NULL)) {
                ((B-->(BLK_NEXT)) = newblock);
                ((newblock-->(BLK_PREV)) = B);
                jump Linked;
            }
        }
        ((Flex_Heap-->(BLK_NEXT)) = newblock);
        ((newblock-->(BLK_PREV)) = Flex_Heap);
        .Linked;
    }
    rtrue;
];
[ HeapLargestFreeBlock multiple txb asize best;
    (best = 0);
    for ((txb = (Flex_Heap-->(BLK_NEXT))):(txb ~= NULL):(txb = (txb-->(BLK_NEXT)))) {
        (asize = FlexSize(txb));
        if (multiple) {
            (asize = (asize - BLK_DATA_MULTI_OFFSET));
        } else {
            (asize = (asize - BLK_DATA_OFFSET));
        }
        if ((asize > best)) {
            (best = asize);
        }
    }
    return best;
];
[ HeapDebug full;
    if (full) {
        print "Managing a heap of initially ";
        print (MEMORY_HEAP_SIZE + 16);
        print " bytes.^";
        print HeapNetFreeSpace(0);
        print " bytes currently free.^";
        print "Free space decomposition: ";
        FlexDebugDecomposition(Flex_Heap);
        print "Free space map: ";
        FlexDebug(Flex_Heap);
    } else {
        print HeapNetFreeSpace(0);
        print " of ";
        print (MEMORY_HEAP_SIZE + 16);
        print " bytes free.^";
    }
];
[ FlexAllocate size kov flags dsize n m free_block min_m max_m smallest_oversized_block secondhalf i hsize head tail;
    if ((HeapMakeSpace(size, ((flags)&(BLK_FLAG_MULTIPLE))) == 0)) {
        FlexError("ran out");
    }
    if (((flags)&(BLK_FLAG_MULTIPLE))) {
        (hsize = BLK_DATA_MULTI_OFFSET);
    } else {
        (hsize = BLK_DATA_OFFSET);
    }
    (n = 0);
    for ((dsize = 1):(((dsize < (hsize + size))) || ((n < (3 + (WORDSIZE/2))))):(dsize = (dsize*2))) {
        (n)++;
    }
    (min_m = 10000);
    (max_m = 0);
    for ((free_block = (Flex_Heap-->(BLK_NEXT))):(free_block ~= NULL):(free_block = (free_block-->(BLK_NEXT)))) {
        (m = (free_block->(BLK_HEADER_N)));
        if ((m == n)) {
            jump CorrectSizeFound;
        }
        if ((m > n)) {
            if ((min_m > m)) {
                (min_m = m);
                (smallest_oversized_block = free_block);
            }
        }
        if ((m < n)) {
            if ((max_m < m)) {
                (max_m = m);
            }
        }
    }
    if ((min_m == 10000)) {
        if ((((flags)&(BLK_FLAG_MULTIPLE)) == 0)) {
            FlexError("too fragmented");
        }
        for ((dsize = 1):(max_m > 0):(dsize = (dsize*2))) {
            (max_m)--;
        }
        (head = FlexAllocate((dsize - hsize), kov, flags));
        if ((head == 0)) {
            FlexError("for head block not available");
        }
        (tail = FlexAllocate((size - (dsize - hsize)), kov, flags));
        if ((tail == 0)) {
            FlexError("for tail block not available");
        }
        ((head-->(BLK_NEXT)) = tail);
        ((tail-->(BLK_PREV)) = head);
        return head;
    }
    for (((dsize = 1),(m = 1)):(m <= min_m):(dsize = (dsize*2))) {
        (m)++;
    }
    (free_block = smallest_oversized_block);
    while ((min_m > n)) {
        (dsize = (dsize/2));
        (secondhalf = (free_block + dsize));
        ((secondhalf-->(BLK_NEXT)) = (free_block-->(BLK_NEXT)));
        if (((secondhalf-->(BLK_NEXT)) ~= NULL)) {
            (((secondhalf-->(BLK_NEXT))-->(BLK_PREV)) = secondhalf);
        }
        ((secondhalf-->(BLK_PREV)) = free_block);
        ((free_block-->(BLK_NEXT)) = secondhalf);
        ((free_block->(BLK_HEADER_N)) = ((free_block->(BLK_HEADER_N)) - 1));
        ((secondhalf->(BLK_HEADER_N)) = (free_block->(BLK_HEADER_N)));
        ((secondhalf-->(BLK_HEADER_KOV)) = (free_block-->(BLK_HEADER_KOV)));
        ((secondhalf-->(BLK_HEADER_RCOUNT)) = 0);
        ((secondhalf->(BLK_HEADER_FLAGS)) = (free_block->(BLK_HEADER_FLAGS)));
        (min_m)--;
    }
    .CorrectSizeFound;
    if (((free_block-->(BLK_NEXT)) == NULL)) {
        (((free_block-->(BLK_PREV))-->(BLK_NEXT)) = NULL);
    } else {
        (((free_block-->(BLK_PREV))-->(BLK_NEXT)) = (free_block-->(BLK_NEXT)));
        (((free_block-->(BLK_NEXT))-->(BLK_PREV)) = (free_block-->(BLK_PREV)));
    }
    ((free_block-->(BLK_HEADER_KOV)) = KindAtomic(kov));
    ((free_block-->(BLK_HEADER_RCOUNT)) = 1);
    ((free_block->(BLK_HEADER_FLAGS)) = flags);
    if (((flags)&(BLK_FLAG_MULTIPLE))) {
        ((free_block-->(BLK_NEXT)) = NULL);
        ((free_block-->(BLK_PREV)) = NULL);
    }
    for ((i = hsize):(i < dsize):(i)++) {
        ((free_block->(i)) = 0);
    }
    return free_block;
];
[ FlexError reason;
    print "*** Memory ";
    print (string) reason;
    print " ***^";
    RunTimeProblem(RTP_HEAPERROR);
    @quit;
];
[ FlexMergeInternal block first last pv nx;
    (first = block);
    (last = block);
    while (((last-->(BLK_NEXT)) == (last + FlexSize(last)))) {
        (last = (last-->(BLK_NEXT)));
    }
    while ((((((first-->(BLK_PREV)) + FlexSize((first-->(BLK_PREV)))) == first)) && (((first-->(BLK_PREV)) ~= Flex_Heap)))) {
        (first = (first-->(BLK_PREV)));
    }
    (pv = (first-->(BLK_PREV)));
    (nx = (last-->(BLK_NEXT)));
    if (FlexRecutInternal(first, last)) {
    }
];
[ FlexRecutInternal first last tsize backsize mfrom mto bnext backend n dsize fine_so_far;
    if ((first == last)) {
        rfalse;
    }
    (mfrom = first);
    (mto = (last + FlexSize(last)));
    (bnext = (last-->(BLK_NEXT)));
    (fine_so_far = 1);
    for (:(mto > mfrom):(mto = (mto - backsize))) {
        for (((n = 0),(backsize = 1)):((backsize*2) <= (mto - mfrom)):(n)++) {
            (backsize = (backsize*2));
        }
        if (((fine_so_far) && ((backsize == FlexSize(last))))) {
            (bnext = last);
            (last = (last-->(BLK_PREV)));
            ((bnext-->(BLK_PREV)) = last);
            ((last-->(BLK_NEXT)) = bnext);
            continue;
        }
        (fine_so_far = 0);
        (backend = (mto - backsize));
        ((backend->(BLK_HEADER_N)) = n);
        ((backend-->(BLK_HEADER_KOV)) = 0);
        ((backend-->(BLK_HEADER_RCOUNT)) = 0);
        ((backend->(BLK_HEADER_FLAGS)) = BLK_FLAG_MULTIPLE);
        ((backend-->(BLK_NEXT)) = bnext);
        if ((bnext ~= NULL)) {
            ((bnext-->(BLK_PREV)) = backend);
            (bnext = backend);
        }
    }
    if (fine_so_far) {
        rfalse;
    }
    rtrue;
];
[ FlexFree block fromtxb ptxb;
    if ((block == 0)) {
        rtrue;
    }
    if ((((block->(BLK_HEADER_FLAGS)))&(BLK_FLAG_RESIDENT))) {
        rtrue;
    }
    if ((((block->(BLK_HEADER_N)))&(128))) {
        rtrue;
    }
    if ((((block->(BLK_HEADER_FLAGS)))&(BLK_FLAG_MULTIPLE))) {
        if (((block-->(BLK_PREV)) ~= NULL)) {
            (((block-->(BLK_PREV))-->(BLK_NEXT)) = NULL);
        }
        (fromtxb = block);
        for (:((block-->(BLK_NEXT)) ~= NULL):(block = (block-->(BLK_NEXT)))) {
        }
        while ((block ~= fromtxb)) {
            (ptxb = (block-->(BLK_PREV)));
            FlexFreeSingleBlockInternal(block);
            (block = ptxb);
        }
    }
    FlexFreeSingleBlockInternal(block);
];
[ FlexFreeSingleBlockInternal block free nx;
    ((block-->(BLK_HEADER_KOV)) = 0);
    ((block-->(BLK_HEADER_RCOUNT)) = 0);
    ((block->(BLK_HEADER_FLAGS)) = BLK_FLAG_MULTIPLE);
    for ((free = Flex_Heap):(free ~= NULL):(free = (free-->(BLK_NEXT)))) {
        (nx = (free-->(BLK_NEXT)));
        if ((nx == NULL)) {
            ((free-->(BLK_NEXT)) = block);
            ((block-->(BLK_PREV)) = free);
            ((block-->(BLK_NEXT)) = NULL);
            FlexMergeInternal(block);
            rtrue;
        }
        if ((UnsignedCompare(nx, block) == 1)) {
            ((free-->(BLK_NEXT)) = block);
            ((block-->(BLK_PREV)) = free);
            ((block-->(BLK_NEXT)) = nx);
            ((nx-->(BLK_PREV)) = block);
            FlexMergeInternal(block);
            rtrue;
        }
    }
];
[ FlexResize block req newsize dsize newblk kov n i otxb flags;
    if ((block == 0)) {
        FlexError("failed resizing null block");
    }
    (kov = (block-->(BLK_HEADER_KOV)));
    (flags = (block->(BLK_HEADER_FLAGS)));
    if ((((flags)&(BLK_FLAG_MULTIPLE)) == 0)) {
        FlexError("failed resizing inextensible block");
    }
    (otxb = block);
    (newsize = req);
    for (:1:(block = (block-->(BLK_NEXT)))) {
        (n = (block->(BLK_HEADER_N)));
        for ((dsize = 1):(n > 0):(n)--) {
            (dsize = (dsize*2));
        }
        (i = (dsize - BLK_DATA_MULTI_OFFSET));
        (newsize = (newsize - i));
        if ((newsize > 0)) {
            if (((block-->(BLK_NEXT)) ~= NULL)) {
                continue;
            }
            (newblk = FlexAllocate(newsize, kov, flags));
            if ((newblk == 0)) {
                rfalse;
            }
            ((block-->(BLK_NEXT)) = newblk);
            ((newblk-->(BLK_PREV)) = block);
            rtrue;
        }
        if (((block-->(BLK_NEXT)) ~= NULL)) {
            FlexFree((block-->(BLK_NEXT)));
            ((block-->(BLK_NEXT)) = NULL);
        }
        rtrue;
    }
];
[ FlexSize txb bsize n m;
    if ((txb == 0)) {
        rfalse;
    }
    (m = (txb->(BLK_HEADER_N)));
    for ((bsize = 1):(n < m):(bsize = (bsize*2))) {
        (n)++;
    }
    return bsize;
];
[ FlexTotalSize txb size_in_bytes;
    if ((txb == 0)) {
        rfalse;
    }
    if (((((txb->(BLK_HEADER_FLAGS)))&(BLK_FLAG_MULTIPLE)) == 0)) {
        return (FlexSize(txb) - BLK_DATA_OFFSET);
    }
    for (:(txb ~= NULL):(txb = (txb-->(BLK_NEXT)))) {
        (size_in_bytes = ((size_in_bytes + FlexSize(txb)) - BLK_DATA_MULTI_OFFSET));
    }
    return size_in_bytes;
];
[ FlexDebug txb n k i bsize tot dtot kov;
    if ((txb == 0)) {
        print "Block never created.";
        new_line;
        rtrue;
    }
    (kov = (txb-->(BLK_HEADER_KOV)));
    print "Block ";
    print txb;
    print " (kov ";
    print kov;
    print "): ";
    for (:(txb ~= NULL):(txb = (txb-->(BLK_NEXT)))) {
        if (((k)++ == 100)) {
            print " ... and so on.";
            new_line;
            rtrue;
        }
        if (((txb-->(BLK_HEADER_KOV)) ~= kov)) {
            print "*Wrong kov=";
            print (txb-->(BLK_HEADER_KOV));
            print "* ";
        }
        (n = (txb->(BLK_HEADER_N)));
        for ((bsize = 1):(n > 0):(n)--) {
            (bsize = (bsize*2));
        }
        (i = (bsize - BLK_DATA_OFFSET));
        (dtot = (dtot + i));
        (tot = (tot + bsize));
        print txb;
        print "(";
        print bsize;
        print ") > ";
    }
    print dtot;
    print " data in ";
    print tot;
    print " bytes^";
];
[ FlexDebugDecomposition from to txb pf;
    if ((to == 0)) {
        (to = NULL);
    }
    for ((txb = from):(((txb ~= to)) && ((txb ~= NULL))):(txb = (txb-->(BLK_NEXT)))) {
        if (pf) {
            print "+";
        }
        print FlexSize(txb);
        (pf = 1);
    }
    print "^";
];
[ BlkValueGetLongBlock bv o;
    if (bv) {
        (o = (bv-->(0)));
        if ((o == 0)) {
            return (bv + WORDSIZE);
        }
        if ((((o)&(BLK_BVBITMAP)) == o)) {
            if (((o)&(BLK_BVBITMAP_LONGBLOCK))) {
                return (bv-->(1));
            }
            rfalse;
        }
        return o;
    }
    return bv;
];
[ BlkValueWeakKind bv o;
    if (bv) {
        (o = (bv-->(0)));
        if ((o == 0)) {
            return (bv-->((BLK_HEADER_KOV + 1)));
        }
        if ((((o)&(BLK_BVBITMAP)) == o)) {
            if (((o)&(BLK_BVBITMAP_TEXT))) {
                return TEXT_TY;
            }
            (o = (bv-->(1)));
        }
        return (o-->(BLK_HEADER_KOV));
    }
    return NIL_TY;
];
[ BlkValueGetRefCountPrimitive bv long_block;
    (long_block = BlkValueGetLongBlock(bv));
    if (long_block) {
        return (long_block-->(BLK_HEADER_RCOUNT));
    }
    return RC_INFINITY;
];
[ BlkValueIncRefCountPrimitive bv long_block refc;
    (long_block = BlkValueGetLongBlock(bv));
    if (long_block) {
        (refc = (long_block-->(BLK_HEADER_RCOUNT)));
        if ((refc < RC_INFINITY)) {
            ((long_block-->(BLK_HEADER_RCOUNT)) = (refc + 1));
        }
    }
];
[ BlkValueDecRefCountPrimitive bv long_block refc;
    (long_block = BlkValueGetLongBlock(bv));
    if (long_block) {
        (refc = (long_block-->(BLK_HEADER_RCOUNT)));
        if ((refc < RC_INFINITY)) {
            (refc)--;
            if ((refc < 0)) {
                BlkValueError("reference count negative");
            }
            ((long_block-->(BLK_HEADER_RCOUNT)) = refc);
        }
        return refc;
    }
    return RC_INFINITY;
];
[ BlkValueLBCapacity bv long_block array_size_in_bytes entry_size_in_bytes flags;
    (long_block = BlkValueGetLongBlock(bv));
    if ((long_block == 0)) {
        rfalse;
    }
    (array_size_in_bytes = FlexTotalSize(long_block));
    (flags = (long_block->(BLK_HEADER_FLAGS)));
    (entry_size_in_bytes = 1);
    if (((flags)&(BLK_FLAG_16_BIT))) {
        (entry_size_in_bytes = 2);
    } else {
        if (((flags)&(BLK_FLAG_WORD))) {
            (entry_size_in_bytes = WORDSIZE);
        }
    }
    return (array_size_in_bytes/entry_size_in_bytes);
];
[ BlkValueSetLBCapacity bv new_capacity long_block flags entry_size_in_bytes;
    if ((bv == 0)) {
        rfalse;
    }
    BlkMakeMutable(bv);
    (long_block = BlkValueGetLongBlock(bv));
    if ((long_block == 0)) {
        rfalse;
    }
    (flags = (long_block->(BLK_HEADER_FLAGS)));
    (entry_size_in_bytes = 1);
    if (((flags)&(BLK_FLAG_16_BIT))) {
        (entry_size_in_bytes = 2);
    } else {
        if (((flags)&(BLK_FLAG_WORD))) {
            (entry_size_in_bytes = WORDSIZE);
        }
    }
    FlexResize(long_block, (new_capacity*entry_size_in_bytes));
    rtrue;
];
[ BlkValueRead from pos do_not_indirect long_block chunk_size_in_bytes header_size_in_bytes flags entry_size_in_bytes seek_byte_position;
    if ((from == 0)) {
        rfalse;
    }
    if (do_not_indirect) {
        (long_block = from);
    } else {
        (long_block = BlkValueGetLongBlock(from));
    }
    (flags = (long_block->(BLK_HEADER_FLAGS)));
    (entry_size_in_bytes = 1);
    if (((flags)&(BLK_FLAG_16_BIT))) {
        (entry_size_in_bytes = 2);
    } else {
        if (((flags)&(BLK_FLAG_WORD))) {
            (entry_size_in_bytes = WORDSIZE);
        }
    }
    if (((flags)&(BLK_FLAG_MULTIPLE))) {
        (header_size_in_bytes = BLK_DATA_MULTI_OFFSET);
    } else {
        (header_size_in_bytes = BLK_DATA_OFFSET);
    }
    (seek_byte_position = (pos*entry_size_in_bytes));
    for (:(long_block ~= NULL):(long_block = (long_block-->(BLK_NEXT)))) {
        (chunk_size_in_bytes = (FlexSize(long_block) - header_size_in_bytes));
        if ((((seek_byte_position >= 0)) && ((seek_byte_position < chunk_size_in_bytes)))) {
            (long_block = ((long_block + header_size_in_bytes) + seek_byte_position));
            switch (entry_size_in_bytes) {
                1:
                    return (long_block->(0));
                    ;
                2:
                    return (((long_block->(0))*256) + (long_block->(1)));
                    ;
                4:
                    return (long_block-->(0));
                    ;
            }
        }
        (seek_byte_position = (seek_byte_position - chunk_size_in_bytes));
    }
    print "*** BlkValueRead: reading from index out of range: ";
    print pos;
    print " in ";
    print from;
    print " ***";
    print "^";
    rtrue;
];
[ BlkValueWrite to pos val do_not_indirect long_block chunk_size_in_bytes header_size_in_bytes flags entry_size_in_bytes seek_byte_position;
    if ((to == 0)) {
        rfalse;
    }
    if (do_not_indirect) {
        (long_block = to);
    } else {
        BlkMakeMutable(to);
        (long_block = BlkValueGetLongBlock(to));
    }
    (flags = (long_block->(BLK_HEADER_FLAGS)));
    (entry_size_in_bytes = 1);
    if (((flags)&(BLK_FLAG_16_BIT))) {
        (entry_size_in_bytes = 2);
    } else {
        if (((flags)&(BLK_FLAG_WORD))) {
            (entry_size_in_bytes = WORDSIZE);
        }
    }
    if (((flags)&(BLK_FLAG_MULTIPLE))) {
        (header_size_in_bytes = BLK_DATA_MULTI_OFFSET);
    } else {
        (header_size_in_bytes = BLK_DATA_OFFSET);
    }
    (seek_byte_position = (pos*entry_size_in_bytes));
    for (:(long_block ~= NULL):(long_block = (long_block-->(BLK_NEXT)))) {
        (chunk_size_in_bytes = (FlexSize(long_block) - header_size_in_bytes));
        if ((((seek_byte_position >= 0)) && ((seek_byte_position < chunk_size_in_bytes)))) {
            (long_block = ((long_block + header_size_in_bytes) + seek_byte_position));
            switch (entry_size_in_bytes) {
                1:
                    ((long_block->(0)) = val);
                    ;
                2:
                    ((long_block->(0)) = ((val/256)%256));
                    ((long_block->(1)) = (val%256));
                    ;
                4:
                    ((long_block-->(0)) = val);
                    ;
            }
            rtrue;
        }
        (seek_byte_position = (seek_byte_position - chunk_size_in_bytes));
    }
    print "*** BlkValueWrite: writing to index out of range: ";
    print pos;
    print " in ";
    print to;
    print " ***";
    print "^";
    rtrue;
];
[ BlkValueSeekZeroEntry from long_block chunk_size_in_bytes header_size_in_bytes flags entry_size_in_bytes byte_position addr from_addr to_addr;
    if ((from == 0)) {
        return (-(1));
    }
    (long_block = BlkValueGetLongBlock(from));
    (flags = (long_block->(BLK_HEADER_FLAGS)));
    (entry_size_in_bytes = 1);
    if (((flags)&(BLK_FLAG_16_BIT))) {
        (entry_size_in_bytes = 2);
    } else {
        if (((flags)&(BLK_FLAG_WORD))) {
            (entry_size_in_bytes = WORDSIZE);
        }
    }
    if (((flags)&(BLK_FLAG_MULTIPLE))) {
        (header_size_in_bytes = BLK_DATA_MULTI_OFFSET);
    } else {
        (header_size_in_bytes = BLK_DATA_OFFSET);
    }
    (byte_position = 0);
    for (:(long_block ~= NULL):(long_block = (long_block-->(BLK_NEXT)))) {
        (chunk_size_in_bytes = (FlexSize(long_block) - header_size_in_bytes));
        (from_addr = (long_block + header_size_in_bytes));
        (to_addr = (from_addr + chunk_size_in_bytes));
        switch (entry_size_in_bytes) {
            1:
                for ((addr = from_addr):(addr < to_addr):(addr)++) {
                    if (((addr->(0)) == 0)) {
                        return ((byte_position + addr) - from_addr);
                    }
                }
                ;
            2:
                for ((addr = from_addr):(addr < to_addr):(addr = (addr + 2))) {
                    if (((((addr->(0)) == 0)) && (((addr->(1)) == 0)))) {
                        return (((byte_position + addr) - from_addr)/2);
                    }
                }
                ;
            4:
                for ((addr = from_addr):(addr < to_addr):(addr = (addr + 4))) {
                    if (((addr-->(0)) == 0)) {
                        return (((byte_position + addr) - from_addr)/4);
                    }
                }
                ;
        }
        (byte_position = (byte_position + chunk_size_in_bytes));
    }
    return (-(1));
];
[ BlkValueMassCopyEntries to_bv from_bv no_entries_to_copy from_long_block from_addr from_bytes_left from_header_size_in_bytes to_long_block to_addr to_bytes_left to_header_size_in_bytes bytes_to_copy flags entry_size_in_bytes min;
    BlkMakeMutable(to_bv);
    (from_long_block = BlkValueGetLongBlock(from_bv));
    (to_long_block = BlkValueGetLongBlock(to_bv));
    (flags = (from_long_block->(BLK_HEADER_FLAGS)));
    (entry_size_in_bytes = 1);
    if (((flags)&(BLK_FLAG_16_BIT))) {
        (entry_size_in_bytes = 2);
    } else {
        if (((flags)&(BLK_FLAG_WORD))) {
            (entry_size_in_bytes = WORDSIZE);
        }
    }
    if (((((flags)&((BLK_FLAG_MULTIPLE + BLK_FLAG_TRUNCMULT)))) && ((BlkValueSetLBCapacity(to_bv, no_entries_to_copy) == 0)))) {
        BlkValueError("copy resizing failed");
    }
    if (((flags)&(BLK_FLAG_MULTIPLE))) {
        (from_header_size_in_bytes = BLK_DATA_MULTI_OFFSET);
    } else {
        (from_header_size_in_bytes = BLK_DATA_OFFSET);
    }
    (flags = (to_long_block->(BLK_HEADER_FLAGS)));
    if (((flags)&(BLK_FLAG_MULTIPLE))) {
        (to_header_size_in_bytes = BLK_DATA_MULTI_OFFSET);
    } else {
        (to_header_size_in_bytes = BLK_DATA_OFFSET);
    }
    (from_addr = (from_long_block + from_header_size_in_bytes));
    (from_bytes_left = (FlexSize(from_long_block) - from_header_size_in_bytes));
    (to_addr = (to_long_block + to_header_size_in_bytes));
    (to_bytes_left = (FlexSize(to_long_block) - to_header_size_in_bytes));
    (bytes_to_copy = (entry_size_in_bytes*no_entries_to_copy));
    while (1) {
        if ((from_bytes_left == 0)) {
            (from_long_block = (from_long_block-->(BLK_NEXT)));
            if ((from_long_block == 0)) {
                BlkValueError("copy destination exhausted");
            }
            (from_addr = (from_long_block + from_header_size_in_bytes));
            (from_bytes_left = (FlexSize(from_long_block) - from_header_size_in_bytes));
        } else {
            if ((to_bytes_left == 0)) {
                (to_long_block = (to_long_block-->(BLK_NEXT)));
                if ((to_long_block == 0)) {
                    BlkValueError("copy source exhausted");
                }
                (to_addr = (to_long_block + to_header_size_in_bytes));
                (to_bytes_left = (FlexSize(to_long_block) - to_header_size_in_bytes));
            } else {
                (min = from_bytes_left);
                if ((to_bytes_left < min)) {
                    (min = to_bytes_left);
                }
                if ((bytes_to_copy <= min)) {
                    Memcpy(to_addr, from_addr, bytes_to_copy);
                    rtrue;
                }
                Memcpy(to_addr, from_addr, min);
                (bytes_to_copy = (bytes_to_copy - min));
                (from_addr = (from_addr + min));
                (from_bytes_left = (from_bytes_left - min));
                (to_addr = (to_addr + min));
                (to_bytes_left = (to_bytes_left - min));
            }
        }
    }
];
[ BlkValueMassCopyFromArray to_bv from_array from_entry_size no_entries_to_copy to_long_block to_addr to_entries_left to_header_size to_entry_size flags;
    BlkMakeMutable(to_bv);
    (to_long_block = BlkValueGetLongBlock(to_bv));
    (flags = (to_long_block->(BLK_HEADER_FLAGS)));
    (to_entry_size = 1);
    if (((flags)&(BLK_FLAG_16_BIT))) {
        (to_entry_size = 2);
    } else {
        if (((flags)&(BLK_FLAG_WORD))) {
            (to_entry_size = WORDSIZE);
        }
    }
    if (((((flags)&((BLK_FLAG_MULTIPLE + BLK_FLAG_TRUNCMULT)))) && ((BlkValueSetLBCapacity(to_bv, no_entries_to_copy) == 0)))) {
        BlkValueError("copy resizing failed");
    }
    if (((flags)&(BLK_FLAG_MULTIPLE))) {
        (to_header_size = BLK_DATA_MULTI_OFFSET);
    } else {
        (to_header_size = BLK_DATA_OFFSET);
    }
    (to_addr = (to_long_block + to_header_size));
    (to_entries_left = ((FlexSize(to_long_block) - to_header_size)/to_entry_size));
    while ((no_entries_to_copy > to_entries_left)) {
        Arrcpy(to_addr, to_entry_size, from_array, from_entry_size, to_entries_left);
        (no_entries_to_copy = (no_entries_to_copy - to_entries_left));
        (from_array = (from_array + (to_entries_left*from_entry_size)));
        (to_long_block = (to_long_block-->(BLK_NEXT)));
        if ((to_long_block == 0)) {
            BlkValueError("copy source exhausted");
        }
        (to_addr = (to_long_block + to_header_size));
        (to_entries_left = ((FlexSize(to_long_block) - to_header_size)/to_entry_size));
    }
    if ((no_entries_to_copy > 0)) {
        Arrcpy(to_addr, to_entry_size, from_array, from_entry_size, no_entries_to_copy);
    }
];
[ BlkValueCreate strong_kind short_block kovs;
    (kovs = KOVSupportFunction(strong_kind, "impossible allocation"));
    (short_block = (kovs)(CREATE_KOVS,strong_kind,short_block));
    return short_block;
];
[ BlkValueError reason;
    print "*** Value handling failed: ";
    print (string) reason;
    print " ***^";
    RunTimeProblem(RTP_HEAPERROR);
    @quit;
];
[ BlkValueCreateSB1 short_block val;
    if ((short_block == 0)) {
        (short_block = (FlexAllocate(WORDSIZE, 0, BLK_FLAG_WORD) + BLK_DATA_OFFSET));
    }
    ((short_block-->(0)) = val);
    return short_block;
];
[ BlkValueCreateSB2 short_block val1 val2;
    if ((short_block == 0)) {
        (short_block = (FlexAllocate((2*WORDSIZE), 0, BLK_FLAG_WORD) + BLK_DATA_OFFSET));
    }
    ((short_block-->(0)) = val1);
    ((short_block-->(1)) = val2);
    return short_block;
];
[ StackFramingInitialise;
    (I7SFRAME = (blockv_stack + (WORDSIZE*BLOCKV_STACK_SIZE)));
];
[ StackFrameCreate size new;
    (new = (I7SFRAME - (WORDSIZE*size)));
    if ((new < blockv_stack)) {
        RunTimeProblem(RTP_HEAPERROR);
        @quit;
    }
    (I7SFRAME = new);
];
[ BlkValueCreateOnStack offset strong_kind;
    BlkValueCreate(strong_kind, (I7SFRAME + (WORDSIZE*offset)));
];
[ BlkValueFreeOnStack offset;
    BlkValueFree((I7SFRAME + (WORDSIZE*offset)));
];
[ BlkValueFree bv kovs d;
    if ((bv == 0)) {
        rtrue;
    }
    (kovs = KOVSupportFunction(BlkValueWeakKind(bv), "impossible deallocation"));
    BlkValueDestroyPrimitive(bv, kovs);
    (d = (bv - Flex_Heap));
    if ((((d >= 0)) && ((d < (MEMORY_HEAP_SIZE + 16))))) {
        FlexFree((bv - BLK_DATA_OFFSET));
    }
];
[ BlkValueQuickCopyPrimitive to_bv from_bv kovs;
    BlkValueDestroyPrimitive(to_bv, kovs);
    (kovs)(COPYSB_KOVS,to_bv,from_bv);
    BlkValueIncRefCountPrimitive(from_bv);
];
[ BlkValueCopySB1 to_bv from_bv;
    ((to_bv-->(0)) = (from_bv-->(0)));
    if (((to_bv-->(0)) == 0)) {
        ((to_bv-->(0)) = (from_bv + WORDSIZE));
    }
];
[ BlkValueCopySB2 to_bv from_bv;
    ((to_bv-->(0)) = (from_bv-->(0)));
    ((to_bv-->(1)) = (from_bv-->(1)));
    if (((to_bv-->(1)) == 0)) {
        ((to_bv-->(1)) = (from_bv + (2*WORDSIZE)));
    }
];
[ BlkValueSlowCopyPrimitive to_bv from_bv kovs recycling k from_long_block no_entries_to_copy;
    (k = (kovs)(KINDDATA_KOVS,to_bv,from_bv));
    (from_long_block = BlkValueGetLongBlock(from_bv));
    if (from_long_block) {
        if (recycling) {
            BlkValueRecyclePrimitive(to_bv, kovs);
        }
        (no_entries_to_copy = (kovs)(EXTENT_KOVS,from_bv));
        if ((no_entries_to_copy == -1)) {
            (no_entries_to_copy = BlkValueLBCapacity(from_bv));
        }
        BlkValueMassCopyEntries(to_bv, from_bv, no_entries_to_copy);
    }
    (kovs)(COPY_KOVS,to_bv,from_bv,k);
];
[ BlkValueCopy to_bv from_bv to_kind from_kind kovs;
    if ((to_bv == 0)) {
        BlkValueError("copy to null value");
    }
    if ((from_bv == 0)) {
        BlkValueError("copy from null value");
    }
    if ((to_bv == from_bv)) {
        rtrue;
    }
    (to_kind = BlkValueWeakKind(to_bv));
    (from_kind = BlkValueWeakKind(from_bv));
    if ((to_kind ~= from_kind)) {
        BlkValueError("copy incompatible kinds");
    }
    (kovs = KOVSupportFunction(to_kind, "impossible copy"));
    if ((kovs)(COPYQUICK_KOVS,to_bv,from_bv)) {
        BlkValueQuickCopyPrimitive(to_bv, from_bv, kovs);
    } else {
        BlkValueSlowCopyPrimitive(to_bv, from_bv, kovs, 1);
    }
    return to_bv;
];
[ BlkValueCopyAZ to_bv from_bv;
    if (from_bv) {
        return BlkValueCopy(to_bv, from_bv);
    }
    return to_bv;
];
[ BlkValueDestroyPrimitive bv kovs long_block;
    if ((BlkValueDecRefCountPrimitive(bv) == 0)) {
        (kovs)(DESTROY_KOVS,bv);
        (long_block = BlkValueGetLongBlock(bv));
        if (long_block) {
            FlexFree(long_block);
        }
    }
];
[ BlkValueRecyclePrimitive bv kovs;
    if ((BlkValueDecRefCountPrimitive(bv) == 0)) {
        (kovs)(DESTROY_KOVS,bv);
        BlkValueIncRefCountPrimitive(bv);
    } else {
        BlkValueCreate(BlkValueWeakKind(bv), bv);
    }
];
[ BlkMakeMutable bv block bv_kind kovs sb_size;
    if ((bv == 0)) {
        BlkValueError("tried to make null block mutable");
    }
    if ((BlkValueGetRefCountPrimitive(bv) > 1)) {
        BlkValueDecRefCountPrimitive(bv);
        (bv_kind = BlkValueWeakKind(bv));
        (kovs = KOVSupportFunction(bv_kind, "impossible mutability"));
        (sb_size = (kovs)(MAKEMUTABLE_KOVS,bv));
        if ((sb_size > 0)) {
            @push I7SFRAME;
            StackFrameCreate(sb_size);
            BlkValueCreateOnStack(0, bv_kind);
            (kovs)(COPYKIND_KOVS,I7SFRAME,bv);
            BlkValueSlowCopyPrimitive(I7SFRAME, bv, kovs, 0);
            (kovs)(COPYSB_KOVS,bv,I7SFRAME);
            @pull I7SFRAME;
        }
    }
];
[ BlkValueCast to_bv original_kind original_value kovs;
    (kovs = KOVSupportFunction(BlkValueWeakKind(to_bv), "impossible cast"));
    (kovs)(CAST_KOVS,to_bv,original_kind,original_value);
    return to_bv;
];
[ BlkValueCompare bv_left bv_right kind_left kind_right kovs;
    if ((((bv_left == 0)) && ((bv_right == 0)))) {
        rfalse;
    }
    if ((bv_left == 0)) {
        rtrue;
    }
    if ((bv_right == 0)) {
        return (-(1));
    }
    (kind_left = BlkValueWeakKind(bv_left));
    (kind_right = BlkValueWeakKind(bv_right));
    if ((kind_left ~= kind_right)) {
        return (kind_left - kind_right);
    }
    (kovs = KOVSupportFunction(kind_left, "impossible comparison"));
    return (kovs)(COMPARE_KOVS,bv_left,bv_right);
];
[ GetHashValue kind value;
    if (KOVIsBlockValue(kind)) {
        return BlkValueHash(value);
    }
    return value;
];
[ BlkValueHash bv bv_kind kovs;
    if ((bv == 0)) {
        rfalse;
    }
    (bv_kind = BlkValueWeakKind(bv));
    (kovs = KOVSupportFunction(bv_kind, "impossible hashing"));
    return (kovs)(HASH_KOVS,bv);
];
[ BlkValueReadFromFile bv auxf ch bv_kind kovs;
    (kovs = KOVSupportFunction(bv_kind));
    if (kovs) {
        return (kovs)(READ_FILE_KOVS,bv,auxf,ch);
    }
    rfalse;
];
[ BlkValueWriteToFile bv bv_kind kovs;
    (kovs = KOVSupportFunction(bv_kind));
    if (kovs) {
        return (kovs)(WRITE_FILE_KOVS,bv);
    }
    rfalse;
];
[ BlkValueDebug bv flag refc long_block kovs;
    print "(BV";
    if (bv) {
        BlkDebugAddress(bv, flag);
        (long_block = BlkValueGetLongBlock(bv));
        if (long_block) {
            if (((bv-->(0)) == 0)) {
                print "...";
            } else {
                print "-->";
            }
            print "L";
            BlkDebugAddress(long_block, flag);
            print " 2**";
            print (long_block->(BLK_HEADER_N));
            (refc = BlkValueGetRefCountPrimitive(bv));
            if ((refc == RC_INFINITY)) {
                print " resident";
            } else {
                print " ";
                print refc;
                print " ref";
                if ((refc ~= 1)) {
                    print "s";
                }
            }
        }
        (kovs = KOVSupportFunction(BlkValueWeakKind(bv)));
        if (kovs) {
            (kovs)(DEBUG_KOVS,bv);
        }
    }
    print ")";
];
[ BlkDebugAddress addr flag d;
    if (flag) {
        print "###";
        rtrue;
    }
    (d = (addr - blockv_stack));
    if ((((d >= 0)) && ((d <= (WORDSIZE*BLOCKV_STACK_SIZE))))) {
        print "s+";
        BlkPrintHexadecimal(d);
        (d = (addr - I7SFRAME));
        print "=f";
        if ((d >= 0)) {
            print "+";
        }
        print d;
        rtrue;
    }
    (d = (addr - Flex_Heap));
    if ((((d >= 0)) && ((d < (MEMORY_HEAP_SIZE + 16))))) {
        print "h+";
        BlkPrintHexadecimal(d);
        rtrue;
    }
    BlkPrintHexadecimal(addr);
];
[ BlkPrintHexadecimal v;
    if (((v)&(-65536))) {
        if (((v)&(-16777216))) {
            BlkPrintHexDigit((v/268435456));
            BlkPrintHexDigit((v/16777216));
        }
        BlkPrintHexDigit((v/1048576));
        BlkPrintHexDigit((v/65536));
    }
    BlkPrintHexDigit((v/4096));
    BlkPrintHexDigit((v/256));
    BlkPrintHexDigit((v/16));
    BlkPrintHexDigit(v);
];
[ BlkPrintHexDigit v;
    (v = ((v)&(15)));
    if ((v < 10)) {
        print v;
    } else {
        print (char) ((65 + v) - 10);
    }
];
[ TEXT_TY_Extent arg1 x;
    (x = BlkValueSeekZeroEntry(arg1));
    if ((x < 0)) {
        return (-(1));
    }
    return (x + 1);
];
[ TEXT_TY_Support task arg1 arg2 arg3;
    switch (task) {
        CREATE_KOVS:
            return TEXT_TY_Create(arg2);
            ;
        CAST_KOVS:
            TEXT_TY_Cast(arg1, arg2, arg3);
            ;
        MAKEMUTABLE_KOVS:
            return TEXT_TY_Mutable(arg1);
            ;
        COPYQUICK_KOVS:
            rtrue;
            ;
        COPYSB_KOVS:
            TEXT_TY_CopySB(arg1, arg2);
            ;
        KINDDATA_KOVS:
            rfalse;
            ;
        EXTENT_KOVS:
            return TEXT_TY_Extent(arg1);
            ;
        COMPARE_KOVS:
            return TEXT_TY_Compare(arg1, arg2);
            ;
        READ_FILE_KOVS:
            if ((arg3 == -1)) {
                rtrue;
            }
            return TEXT_TY_ReadFile(arg1, arg2, arg3);
            ;
        WRITE_FILE_KOVS:
            return TEXT_TY_WriteFile(arg1);
            ;
        HASH_KOVS:
            return TEXT_TY_Hash(arg1);
            ;
        DEBUG_KOVS:
            TEXT_TY_Debug(arg1);
            ;
    }
    rfalse;
];
[ TEXT_TY_Debug txt;
    switch ((txt-->(0))) {
        CONSTANT_PACKED_TEXT_STORAGE:
            print " = cp~";
            PrintI6Text((txt-->(1)));
            print "~";
            ;
        CONSTANT_PERISHABLE_TEXT_STORAGE:
            print " = cp~";
            PrintI6Text((txt-->(1)));
            print "~";
            ;
        PACKED_TEXT_STORAGE:
            print " = p~";
            PrintI6Text((txt-->(1)));
            print "~";
            ;
        UNPACKED_TEXT_STORAGE:
            print " = ~";
            TEXT_TY_Say(txt);
            print "~";
            ;
        default:
            print " broken?";
            ;
    }
];
[ TEXT_TY_Create short_block x;
    return BlkValueCreateSB2(short_block, PACKED_TEXT_STORAGE, EMPTY_TEXT_PACKED);
];
[ TEXT_TY_CopySB to_bv from_bv;
    BlkValueCopySB2(to_bv, from_bv);
    if ((((to_bv-->(0)))&(BLK_BVBITMAP_CONSTANTMASK))) {
        ((to_bv-->(0)) = PACKED_TEXT_STORAGE);
    }
];
[ TEXT_TY_Transmute txt;
    TEXT_TY_Temporarily_Transmute(txt);
];
[ TEXT_TY_Temporarily_Transmute txt x;
    if (((txt) && (((((txt-->(0)))&(BLK_BVBITMAP_LONGBLOCKMASK)) == 0)))) {
        (x = (txt-->(1)));
        ((txt-->(0)) = UNPACKED_TEXT_STORAGE);
        ((txt-->(1)) = FlexAllocate(32, TEXT_TY, TEXT_TY_Storage_Flags));
        if ((x ~= EMPTY_TEXT_PACKED)) {
            TEXT_TY_CastPrimitive(txt, 0, x);
        }
        return x;
    }
    rfalse;
];
[ TEXT_TY_Untransmute txt pk cp x;
    if (((pk) && (((txt-->(0)) == UNPACKED_TEXT_STORAGE)))) {
        (x = (txt-->(1)));
        FlexFree(x);
        ((txt-->(0)) = cp);
        ((txt-->(1)) = pk);
    }
    return txt;
];
[ TEXT_TY_Mutable txt;
    if (((((txt-->(0)))&(BLK_BVBITMAP_LONGBLOCKMASK)) == 0)) {
        TEXT_TY_Transmute(txt);
        rfalse;
    }
    return 2;
];
[ TEXT_TY_Cast to_txt from_kind from_value;
    if ((from_kind == TEXT_TY)) {
        BlkValueCopy(to_txt, from_value);
    } else {
        if ((from_kind == SNIPPET_TY)) {
            TEXT_TY_Transmute(to_txt);
            TEXT_TY_CastPrimitive(to_txt, 1, from_value);
        } else {
            BlkValueError("impossible cast to text");
        }
    }
];
[ SNIPPET_TY_to_TEXT_TY to_txt snippet;
    return BlkValueCast(to_txt, SNIPPET_TY, snippet);
];
[ TEXT_TY_CastPrimitive to_txt from_snippet from_value len i stream saved_stream news buffer buffer_size memory_to_free results;
    if ((to_txt == 0)) {
        BlkValueError("no destination for cast");
    }
    (buffer_size = ((TEXT_TY_BufferSize + 2)*WORDSIZE));
    (RawBufferSize = TEXT_TY_BufferSize);
    (buffer = (RawBufferAddress + (TEXT_TY_CastPrimitiveNesting*buffer_size)));
    (TEXT_TY_CastPrimitiveNesting)++;
    if ((TEXT_TY_CastPrimitiveNesting > TEXT_TY_NoBuffers)) {
        (buffer = VM_AllocateMemory(buffer_size));
        (memory_to_free = buffer);
        if ((buffer == 0)) {
            FlexError("ran out with too many simultaneous text conversions");
        }
    }
    if (unicode_gestalt_ok) {
        SuspendRTP();
        .RetryWithLargerBuffer;
        (saved_stream = glk_stream_get_current());
        (stream = glk_stream_open_memory_uni(buffer, RawBufferSize, filemode_Write, 0));
        glk_stream_set_current(stream);
        @push say__p;
        @push say__pc;
        ClearParagraphing(7);
        if (from_snippet) {
            PrintSnippet(from_value);
        } else {
            PrintI6Text(from_value);
        }
        @pull say__pc;
        @pull say__p;
        (results = ((buffer + buffer_size) - (2*WORDSIZE)));
        glk_stream_close(stream, results);
        if (saved_stream) {
            glk_stream_set_current(saved_stream);
        }
        ResumeRTP();
        (len = (results-->(1)));
        if ((len > (RawBufferSize - 1))) {
            (news = RawBufferSize);
            while ((news < len)) {
                (news = (news*2));
            }
            (i = VM_AllocateMemory((news*WORDSIZE)));
            if ((i ~= 0)) {
                if (memory_to_free) {
                    VM_FreeMemory(memory_to_free);
                }
                (memory_to_free = i);
                (buffer = i);
                (RawBufferSize = news);
                (buffer_size = ((RawBufferSize + 2)*WORDSIZE));
                jump RetryWithLargerBuffer;
            }
            (len = (RawBufferSize - 1));
        }
        ((buffer-->(len)) = 0);
        (TEXT_TY_CastPrimitiveNesting)--;
        BlkValueMassCopyFromArray(to_txt, buffer, 4, (len + 1));
    } else {
        RunTimeProblem(RTP_NOGLULXUNICODE);
    }
    if (memory_to_free) {
        VM_FreeMemory(memory_to_free);
    }
];
[ TEXT_TY_Compare left_txt right_txt rv;
    @push say__comp;
    (say__comp = 1);
    (rv = TEXT_TY_Compare_Inner(left_txt, right_txt));
    @pull say__comp;
    return rv;
];
[ TEXT_TY_Compare_Inner left_txt right_txt pos ch1 ch2 capacity_left capacity_right fl fr cl cr cpl cpr;
    if (((((left_txt-->(0)))&(BLK_BVBITMAP_LONGBLOCKMASK)) == 0)) {
        (fl = 1);
    }
    if (((((right_txt-->(0)))&(BLK_BVBITMAP_LONGBLOCKMASK)) == 0)) {
        (fr = 1);
    }
    if (((fl) && (fr))) {
        if (((((left_txt-->(1)) ofclass String)) && (((right_txt-->(1)) ofclass String)))) {
            return ((left_txt-->(1)) - (right_txt-->(1)));
        }
        if (((((left_txt-->(1)) ofclass Routine)) && (((right_txt-->(1)) ofclass Routine)))) {
            if (((left_txt-->(1)) == (right_txt-->(1)))) {
                rfalse;
            }
        }
        (cpl = (left_txt-->(0)));
        (cl = TEXT_TY_Temporarily_Transmute(left_txt));
        (cpr = (right_txt-->(0)));
        (cr = TEXT_TY_Temporarily_Transmute(right_txt));
    } else {
        if (fl) {
            (cpl = (left_txt-->(0)));
            (cl = TEXT_TY_Temporarily_Transmute(left_txt));
        } else {
            if (fr) {
                (cpr = (right_txt-->(0)));
                (cr = TEXT_TY_Temporarily_Transmute(right_txt));
            }
        }
    }
    if (((cl) || (cr))) {
        (pos = TEXT_TY_Compare(left_txt, right_txt));
        TEXT_TY_Untransmute(left_txt, cl, cpl);
        TEXT_TY_Untransmute(right_txt, cr, cpr);
        return pos;
    }
    (capacity_left = BlkValueLBCapacity(left_txt));
    (capacity_right = BlkValueLBCapacity(right_txt));
    for ((pos = 0):(((pos < capacity_left)) && ((pos < capacity_right))):(pos)++) {
        (ch1 = BlkValueRead(left_txt, pos));
        (ch2 = BlkValueRead(right_txt, pos));
        if ((ch1 ~= ch2)) {
            return (ch1 - ch2);
        }
        if ((ch1 == 0)) {
            rfalse;
        }
    }
    if ((pos == capacity_left)) {
        return (-(1));
    }
    rtrue;
];
[ TEXT_TY_Distinguish left_txt right_txt;
    if ((TEXT_TY_Compare(left_txt, right_txt) == 0)) {
        rfalse;
    }
    rtrue;
];
[ TEXT_TY_Hash txt rv len i p cp;
    (cp = (txt-->(0)));
    (p = TEXT_TY_Temporarily_Transmute(txt));
    (rv = 0);
    (len = BlkValueLBCapacity(txt));
    for ((i = 0):(i < len):(i)++) {
        (rv = ((rv*33) + BlkValueRead(txt, i)));
    }
    TEXT_TY_Untransmute(txt, p, cp);
    return rv;
];
[ TEXT_TY_Say txt ch i dsize;
    if ((txt == 0)) {
        rfalse;
    }
    if (((((txt-->(0)))&(BLK_BVBITMAP_LONGBLOCKMASK)) == 0)) {
        return PrintI6Text((txt-->(1)));
    }
    (dsize = BlkValueLBCapacity(txt));
    for ((i = 0):(i < dsize):(i)++) {
        (ch = BlkValueRead(txt, i));
        if ((ch == 0)) {
            break;
        }
        @streamunichar ch;
    }
    if ((i == 0)) {
        rfalse;
    }
    rtrue;
];
[ TEXT_TY_Say_Capitalised txt mod rc;
    (mod = BlkValueCreate(TEXT_TY));
    TEXT_TY_SubstitutedForm(mod, txt);
    if ((TEXT_TY_CharacterLength(mod) > 0)) {
        BlkValueWrite(mod, 0, CharToCase(BlkValueRead(mod, 0), 1));
        TEXT_TY_Say(mod);
        (rc = 1);
        (say__p = 1);
    }
    BlkValueFree(mod);
    return rc;
];
[ TEXT_TY_WriteFile txt len pos ch p cp;
    (cp = (txt-->(0)));
    (p = TEXT_TY_Temporarily_Transmute(txt));
    (len = BlkValueLBCapacity(txt));
    print "S";
    for ((pos = 0):(pos <= len):(pos)++) {
        if ((pos == len)) {
            (ch = 0);
        } else {
            (ch = BlkValueRead(txt, pos));
        }
        if ((ch == 0)) {
            print "0;";
            break;
        } else {
            print ch;
            print ",";
        }
    }
    TEXT_TY_Untransmute(txt, p, cp);
];
[ TEXT_TY_ReadFile txt auxf ch i v dg pos tsize p;
    TEXT_TY_Transmute(txt);
    (tsize = BlkValueLBCapacity(txt));
    while ((ch ~= 32 or 9 or 10 or 13 or 0 or -1)) {
        (ch = FileIO_GetC(auxf));
        if ((ch == 44 or 59)) {
            if (((pos + 1) >= tsize)) {
                if ((BlkValueSetLBCapacity(txt, (2*pos)) == 0)) {
                    break;
                }
                (tsize = BlkValueLBCapacity(txt));
            }
            BlkValueWrite(txt, (pos)++, v);
            (v = 0);
            if ((ch == 59)) {
                break;
            }
        } else {
            (dg = (ch - 48));
            (v = ((v*10) + dg));
        }
    }
    BlkValueWrite(txt, pos, 0);
    return txt;
];
[ TEXT_TY_SubstitutedForm to txt;
    if (txt) {
        BlkValueCopy(to, txt);
        TEXT_TY_Transmute(to);
    }
    return to;
];
[ TEXT_TY_IsSubstituted txt;
    if (((((txt) && (((((txt-->(0)))&(BLK_BVBITMAP_LONGBLOCKMASK)) == 0)))) && (((txt-->(1)) ofclass Routine)))) {
        rfalse;
    }
    rtrue;
];
[ TEXT_TY_ExpandIfPerishable to from;
    if (((from) && (((from-->(0)) == CONSTANT_PERISHABLE_TEXT_STORAGE)))) {
        return TEXT_TY_SubstitutedForm(to, from);
    }
    return from;
];
[ TEXT_TY_BlobAccess txt blobtype ctxt wanted rtxt p1 p2 cp1 cp2 r;
    if ((txt == 0)) {
        rfalse;
    }
    if ((blobtype == CHR_BLOB)) {
        return TEXT_TY_CharacterLength(txt);
    }
    (cp1 = (txt-->(0)));
    (p1 = TEXT_TY_Temporarily_Transmute(txt));
    (cp2 = (rtxt-->(0)));
    (p2 = TEXT_TY_Temporarily_Transmute(rtxt));
    TEXT_TY_Transmute(ctxt);
    if (ctxt) {
        BlkMakeMutable(ctxt);
    }
    (r = TEXT_TY_BlobAccessI(txt, blobtype, ctxt, wanted, rtxt));
    TEXT_TY_Untransmute(txt, p1, cp1);
    TEXT_TY_Untransmute(rtxt, p2, cp2);
    return r;
];
[ TEXT_TY_BlobAccessI txt blobtype ctxt wanted rtxt brm oldbrm ch i dsize blobcount gp cl j;
    (dsize = BlkValueLBCapacity(txt));
    if (((rtxt) && ((ctxt == 0)))) {
        print "*** rtxt without ctxt ***";
        new_line;
        rtrue;
    }
    (brm = WS_BRM);
    for ((i = 0):(i < dsize):(i)++) {
        (ch = BlkValueRead(txt, i));
        if ((ch == 0)) {
            break;
        }
        (oldbrm = brm);
        if ((ch == 10 or 13 or 32 or 9)) {
            if ((oldbrm ~= WS_BRM)) {
                (gp = 0);
                for ((j = i):(j < dsize):(j)++) {
                    (ch = BlkValueRead(txt, j));
                    if ((ch == 0)) {
                        (brm = WS_BRM);
                        break;
                    }
                    if ((ch == 10 or 13)) {
                        (gp)++;
                        continue;
                    }
                    if ((ch ~= 32 or 9)) {
                        break;
                    }
                }
                (ch = BlkValueRead(txt, i));
                if ((j == dsize)) {
                    (brm = WS_BRM);
                }
                switch (blobtype) {
                    PARA_BLOB:
                        if ((gp >= 2)) {
                            (brm = WS_BRM);
                        }
                        ;
                    LINE_BLOB:
                        if ((gp >= 1)) {
                            (brm = WS_BRM);
                        }
                        ;
                    default:
                        (brm = WS_BRM);
                        ;
                }
            }
        } else {
            (gp = 0);
            if ((((blobtype == WORD_BLOB or PWORD_BLOB or UWORD_BLOB)) && ((ch == 46 or 44 or 33 or 63 or 45 or 47 or 34 or 58 or 59 or 40 or 41 or 91 or 93 or 123 or 125)))) {
                (gp = 1);
            }
            switch (oldbrm) {
                WS_BRM:
                    (brm = ACCEPTED_BRM);
                    if ((blobtype == WORD_BLOB)) {
                        if (gp) {
                            (brm = SKIPPED_BRM);
                        }
                    }
                    if ((blobtype == PWORD_BLOB)) {
                        if (gp) {
                            (brm = ACCEPTEDP_BRM);
                        }
                    }
                    ;
                SKIPPED_BRM:
                    if ((blobtype == WORD_BLOB)) {
                        if ((gp == 0)) {
                            (brm = ACCEPTED_BRM);
                        }
                    }
                    ;
                ACCEPTED_BRM:
                    if ((blobtype == WORD_BLOB)) {
                        if (gp) {
                            (brm = SKIPPED_BRM);
                        }
                    }
                    if ((blobtype == PWORD_BLOB)) {
                        if (gp) {
                            (brm = ACCEPTEDP_BRM);
                        }
                    }
                    ;
                ACCEPTEDP_BRM:
                    if ((blobtype == PWORD_BLOB)) {
                        if ((gp == 0)) {
                            (brm = ACCEPTED_BRM);
                        } else {
                            if ((((ch == BlkValueRead(txt, (i - 1)))) && ((ch == 45 or 46)))) {
                                (blobcount)--;
                            }
                            (blobcount)++;
                        }
                    }
                    ;
                ACCEPTEDN_BRM:
                    if ((blobtype == WORD_BLOB)) {
                        if (gp) {
                            (brm = SKIPPED_BRM);
                        }
                    }
                    if ((blobtype == PWORD_BLOB)) {
                        if (gp) {
                            (brm = ACCEPTEDP_BRM);
                        }
                    }
                    ;
                ACCEPTEDPN_BRM:
                    if ((blobtype == PWORD_BLOB)) {
                        if ((gp == 0)) {
                            (brm = ACCEPTED_BRM);
                        } else {
                            if ((((ch == BlkValueRead(txt, (i - 1)))) && ((ch == 45 or 46)))) {
                                (blobcount)--;
                            }
                            (blobcount)++;
                        }
                    }
                    ;
            }
        }
        if ((brm == ACCEPTED_BRM or ACCEPTEDP_BRM)) {
            if ((oldbrm ~= brm)) {
                (blobcount)++;
            }
            if (((ctxt) && ((blobcount == wanted)))) {
                if (rtxt) {
                    if (((cl + 1) >= BlkValueLBCapacity(ctxt))) {
                        if ((BlkValueSetLBCapacity(ctxt, (2*cl)) == 0)) {
                            break;
                        }
                    }
                    BlkValueWrite(ctxt, cl, 0);
                    TEXT_TY_Concatenate(ctxt, rtxt, CHR_BLOB);
                    (cl = TEXT_TY_CharacterLength(ctxt));
                    if ((brm == ACCEPTED_BRM)) {
                        (brm = ACCEPTEDN_BRM);
                    }
                    if ((brm == ACCEPTEDP_BRM)) {
                        (brm = ACCEPTEDPN_BRM);
                    }
                } else {
                    if (((cl + 1) >= BlkValueLBCapacity(ctxt))) {
                        if ((BlkValueSetLBCapacity(ctxt, (2*cl)) == 0)) {
                            break;
                        }
                    }
                    BlkValueWrite(ctxt, (cl)++, ch);
                }
            } else {
                if (rtxt) {
                    if (((cl + 1) >= BlkValueLBCapacity(ctxt))) {
                        if ((BlkValueSetLBCapacity(ctxt, (2*cl)) == 0)) {
                            break;
                        }
                    }
                    BlkValueWrite(ctxt, (cl)++, ch);
                }
            }
        } else {
            if (((rtxt) && ((brm ~= ACCEPTEDN_BRM or ACCEPTEDPN_BRM)))) {
                if (((cl + 1) >= BlkValueLBCapacity(ctxt))) {
                    if ((BlkValueSetLBCapacity(ctxt, (2*cl)) == 0)) {
                        break;
                    }
                }
                BlkValueWrite(ctxt, (cl)++, ch);
            }
        }
    }
    if (ctxt) {
        if (((cl + 1) >= BlkValueLBCapacity(ctxt))) {
            BlkValueSetLBCapacity(ctxt, (2*cl));
        }
        BlkValueWrite(ctxt, (cl)++, 0);
    }
    return blobcount;
];
[ TEXT_TY_GetBlob ctxt txt wanted blobtype;
    if ((txt == 0)) {
        rtrue;
    }
    if ((blobtype == CHR_BLOB)) {
        return TEXT_TY_GetCharacter(ctxt, txt, wanted);
    }
    TEXT_TY_BlobAccess(txt, blobtype, ctxt, wanted);
    return ctxt;
];
[ TEXT_TY_ReplaceBlob blobtype txt wanted rtxt ctxt ilen rlen i p cp;
    TEXT_TY_Transmute(txt);
    (cp = (rtxt-->(0)));
    (p = TEXT_TY_Temporarily_Transmute(rtxt));
    if ((blobtype == CHR_BLOB)) {
        (ilen = TEXT_TY_CharacterLength(txt));
        (rlen = TEXT_TY_CharacterLength(rtxt));
        (wanted)--;
        if ((((wanted >= 0)) && ((wanted < ilen)))) {
            if ((rlen == 1)) {
                BlkValueWrite(txt, wanted, BlkValueRead(rtxt, 0));
            } else {
                (ctxt = BlkValueCreate(TEXT_TY));
                TEXT_TY_Transmute(ctxt);
                if (BlkValueSetLBCapacity(ctxt, ((ilen + rlen) + 1))) {
                    for ((i = 0):(i < wanted):(i)++) {
                        BlkValueWrite(ctxt, i, BlkValueRead(txt, i));
                    }
                    for ((i = 0):(i < rlen):(i)++) {
                        BlkValueWrite(ctxt, (wanted + i), BlkValueRead(rtxt, i));
                    }
                    for ((i = (wanted + 1)):(i < ilen):(i)++) {
                        BlkValueWrite(ctxt, ((rlen + i) - 1), BlkValueRead(txt, i));
                    }
                    BlkValueWrite(ctxt, (rlen + ilen), 0);
                    BlkValueCopy(txt, ctxt);
                }
                BlkValueFree(ctxt);
            }
        }
    } else {
        (ctxt = BlkValueCreate(TEXT_TY));
        TEXT_TY_BlobAccess(txt, blobtype, ctxt, wanted, rtxt);
        BlkValueCopy(txt, ctxt);
        BlkValueFree(ctxt);
    }
    TEXT_TY_Untransmute(rtxt, p, cp);
];
[ TEXT_TY_ReplaceText blobtype txt ftxt rtxt r p1 p2 cp1 cp2;
    TEXT_TY_Transmute(txt);
    (cp1 = (ftxt-->(0)));
    (p1 = TEXT_TY_Temporarily_Transmute(ftxt));
    (cp2 = (rtxt-->(0)));
    (p2 = TEXT_TY_Temporarily_Transmute(rtxt));
    (r = TEXT_TY_ReplaceTextI(blobtype, txt, ftxt, rtxt));
    TEXT_TY_Untransmute(ftxt, p1, cp1);
    TEXT_TY_Untransmute(rtxt, p2, cp2);
    return r;
];
[ TEXT_TY_ReplaceTextI blobtype txt ftxt rtxt ctxt csize ilen flen i cl mpos ch chm whitespace punctuation;
    if ((blobtype == REGEXP_BLOB or CHR_BLOB)) {
        return TEXT_TY_Replace_RE(blobtype, txt, ftxt, rtxt);
    }
    (ilen = TEXT_TY_CharacterLength(txt));
    (flen = TEXT_TY_CharacterLength(ftxt));
    (ctxt = BlkValueCreate(TEXT_TY));
    TEXT_TY_Transmute(ctxt);
    (csize = BlkValueLBCapacity(ctxt));
    (mpos = 0);
    (whitespace = 1);
    (punctuation = 0);
    for ((i = 0):(i <= ilen):(i)++) {
        (ch = BlkValueRead(txt, i));
        (chm = BlkValueRead(ftxt, (mpos)++));
        if ((mpos == 1)) {
            switch (blobtype) {
                WORD_BLOB:
                    if ((((whitespace == 0)) && ((punctuation == 0)))) {
                        (chm = -1);
                    }
                    ;
            }
        }
        (whitespace = 0);
        if ((ch == 10 or 13 or 32 or 9)) {
            (whitespace = 1);
        }
        (punctuation = 0);
        if ((ch == 46 or 44 or 33 or 63 or 45 or 47 or 34 or 58 or 59 or 40 or 41 or 91 or 93 or 123 or 125)) {
            if ((blobtype == WORD_BLOB)) {
                (chm = -1);
            }
            (punctuation = 1);
        }
        if ((ch == chm)) {
            if ((mpos == flen)) {
                if ((i == ilen)) {
                    (chm = 0);
                } else {
                    (chm = BlkValueRead(txt, (i + 1)));
                }
                if ((((((blobtype == CHR_BLOB)) || ((chm == 0 or 10 or 13 or 32 or 9)))) || ((chm == 46 or 44 or 33 or 63 or 45 or 47 or 34 or 58 or 59 or 40 or 41 or 91 or 93 or 123 or 125)))) {
                    (mpos = 0);
                    (cl = (cl - (flen - 1)));
                    BlkValueWrite(ctxt, cl, 0);
                    TEXT_TY_Concatenate(ctxt, rtxt, CHR_BLOB);
                    (csize = BlkValueLBCapacity(ctxt));
                    (cl = TEXT_TY_CharacterLength(ctxt));
                    continue;
                }
            }
        } else {
            (mpos = 0);
        }
        if (((cl + 1) >= csize)) {
            if ((BlkValueSetLBCapacity(ctxt, (2*cl)) == 0)) {
                break;
            }
            (csize = BlkValueLBCapacity(ctxt));
        }
        BlkValueWrite(ctxt, (cl)++, ch);
    }
    BlkValueCopy(txt, ctxt);
    BlkValueFree(ctxt);
];
[ TEXT_TY_CharacterLength txt ch i dsize p cp r;
    if ((txt == 0)) {
        rfalse;
    }
    (cp = (txt-->(0)));
    (p = TEXT_TY_Temporarily_Transmute(txt));
    (dsize = BlkValueLBCapacity(txt));
    (r = dsize);
    for ((i = 0):(i < dsize):(i)++) {
        (ch = BlkValueRead(txt, i));
        if ((ch == 0)) {
            (r = i);
            break;
        }
    }
    TEXT_TY_Untransmute(txt, p, cp);
    return r;
];
[ TEXT_TY_Empty txt;
    if ((txt == 0)) {
        rtrue;
    }
    if (((((txt-->(0)))&(BLK_BVBITMAP_LONGBLOCKMASK)) == 0)) {
        if (((txt-->(1)) == EMPTY_TEXT_PACKED)) {
            rtrue;
        }
        rfalse;
    }
    if ((TEXT_TY_CharacterLength(txt) == 0)) {
        rtrue;
    }
    rfalse;
];
[ TEXT_TY_GetCharacter ctxt txt i ch p cp;
    if ((txt == 0)) {
        rfalse;
    }
    (cp = (txt-->(0)));
    (p = TEXT_TY_Temporarily_Transmute(txt));
    TEXT_TY_Transmute(ctxt);
    if ((((i <= 0)) || ((i > TEXT_TY_CharacterLength(txt))))) {
        (ch = 0);
    } else {
        (ch = BlkValueRead(txt, (i - 1)));
    }
    BlkValueWrite(ctxt, 0, ch);
    BlkValueWrite(ctxt, 1, 0);
    TEXT_TY_Untransmute(txt, p, cp);
    return ctxt;
];
[ TEXT_TY_CharactersOfCase txt case i ch len p cp r;
    if ((txt == 0)) {
        rfalse;
    }
    (cp = (txt-->(0)));
    (p = TEXT_TY_Temporarily_Transmute(txt));
    (len = TEXT_TY_CharacterLength(txt));
    (r = 1);
    for ((i = 0):(i < len):(i)++) {
        (ch = BlkValueRead(txt, i));
        if (((ch) && ((CharIsOfCase(ch, case) == 0)))) {
            (r = 0);
            break;
        }
    }
    TEXT_TY_Untransmute(txt, p, cp);
    return r;
];
[ TEXT_TY_CharactersToCase ctxt txt case i ch len bnd pk cp;
    if ((txt == 0)) {
        rfalse;
    }
    (cp = (txt-->(0)));
    (pk = TEXT_TY_Temporarily_Transmute(txt));
    TEXT_TY_Transmute(ctxt);
    (len = TEXT_TY_CharacterLength(txt));
    if (BlkValueSetLBCapacity(ctxt, (len + 1))) {
        (bnd = 1);
        for ((i = 0):(i < len):(i)++) {
            (ch = BlkValueRead(txt, i));
            if ((case < 2)) {
                BlkValueWrite(ctxt, i, CharToCase(ch, case));
            } else {
                BlkValueWrite(ctxt, i, CharToCase(ch, bnd));
                if ((case == 2)) {
                    (bnd = 0);
                    if ((ch == 0 or 10 or 13 or 32 or 9 or 46 or 44 or 33 or 63 or 45 or 47 or 34 or 58 or 59 or 40 or 41 or 91 or 93 or 123 or 125)) {
                        (bnd = 1);
                    }
                }
                if ((case == 3)) {
                    if ((ch ~= 0 or 10 or 13 or 32 or 9)) {
                        if ((bnd == 1)) {
                            (bnd = 0);
                        } else {
                            if ((ch == 46 or 33 or 63)) {
                                (bnd = 1);
                            }
                        }
                    }
                }
            }
        }
        BlkValueWrite(ctxt, len, 0);
    }
    TEXT_TY_Untransmute(txt, pk, cp);
    return ctxt;
];
[ TEXT_TY_Concatenate to_txt from_txt blobtype ref_txt p cp r;
    if ((to_txt == 0)) {
        rfalse;
    }
    if ((from_txt == 0)) {
        return to_txt;
    }
    TEXT_TY_Transmute(to_txt);
    (cp = (from_txt-->(0)));
    (p = TEXT_TY_Temporarily_Transmute(from_txt));
    (r = TEXT_TY_ConcatenateI(to_txt, from_txt, blobtype, ref_txt));
    TEXT_TY_Untransmute(from_txt, p, cp);
    return r;
];
[ TEXT_TY_ConcatenateI to_txt from_txt blobtype ref_txt pos len ch i tosize x y case;
    switch (blobtype) {
        CHR_BLOB, 0:
            (pos = TEXT_TY_CharacterLength(to_txt));
            (len = TEXT_TY_CharacterLength(from_txt));
            if ((BlkValueSetLBCapacity(to_txt, ((pos + len) + 1)) == 0)) {
                return to_txt;
            }
            for ((i = 0):(i < len):(i)++) {
                (ch = BlkValueRead(from_txt, i));
                BlkValueWrite(to_txt, (i + pos), ch);
            }
            BlkValueWrite(to_txt, (len + pos), 0);
            return to_txt;
            ;
        REGEXP_BLOB:
            return TEXT_TY_RE_Concatenate(to_txt, from_txt, blobtype, ref_txt);
            ;
    }
    print "*** TEXT_TY_Concatenate used on impossible blob type ***^";
    rfalse;
];
[ CharIsOfCase c case i tab min max len par;
    if ((c < 65)) {
        rfalse;
    }
    if ((case == 0)) {
        if ((((c >= 97)) && ((c <= 122)))) {
            rtrue;
        }
        (tab = CharCasingChart0);
    } else {
        if ((((c >= 65)) && ((c <= 90)))) {
            rtrue;
        }
        (tab = CharCasingChart1);
    }
    if ((c < 128)) {
        rfalse;
    }
    while ((tab-->(i))) {
        (min = (tab-->(i)));
        (i)++;
        (len = (tab-->(i)));
        (i)++;
        (i)++;
        (par = 0);
        if ((len < 0)) {
            (par = 1);
            (len = (-(len)));
        }
        if ((c < min)) {
            rfalse;
        }
        if ((c < (min + len))) {
            if (par) {
                if ((((c - min)%2) == 0)) {
                    rtrue;
                }
            } else {
                rtrue;
            }
        }
    }
    rfalse;
];
[ CharToCase c case i tab min max len par del f;
    if ((c < 65)) {
        return c;
    }
    if ((case == 1)) {
        if ((((c >= 97)) && ((c <= 122)))) {
            return (c - 32);
        }
        (tab = CharCasingChart0);
    } else {
        if ((((c >= 65)) && ((c <= 90)))) {
            return (c + 32);
        }
        (tab = CharCasingChart1);
    }
    if ((c < 128)) {
        return c;
    }
    while ((tab-->(i))) {
        (min = (tab-->(i)));
        (i)++;
        (len = (tab-->(i)));
        (i)++;
        (del = (tab-->(i)));
        (i)++;
        (par = 0);
        if ((len < 0)) {
            (par = 1);
            (len = (-(len)));
        }
        if ((c < min)) {
            return c;
        }
        if ((c < (min + len))) {
            (f = 0);
            if (par) {
                if ((((c - min)%2) == 0)) {
                    (f = 1);
                }
            } else {
                (f = 1);
            }
            if (f) {
                if ((del == UNIC_NCT)) {
                    return c;
                }
                return (c + del);
            }
        }
    }
    return c;
];
[ TEXT_TY_RevCase ch;
    if ((ch < 65)) {
        return ch;
    }
    if ((((ch >= 97)) && ((ch <= 122)))) {
        return ((ch - 97) + 65);
    }
    if ((((ch >= 65)) && ((ch <= 90)))) {
        return ((ch - 65) + 97);
    }
    if ((ch < 128)) {
        return ch;
    }
    if (CharIsOfCase(ch, 0)) {
        return CharToCase(ch, 1);
    }
    if (CharIsOfCase(ch, 1)) {
        return CharToCase(ch, 0);
    }
    return ch;
];
[ DigitToValue c n;
    (n = (c - 48));
    if ((((n < 0)) || ((n > 9)))) {
        return (-(1));
    }
    return n;
];
[ CharTestCases case i j;
    for ((i = 32):(i < 224):(i)++) {
        if ((((i >= 127)) && ((i < 155)))) {
            continue;
        }
        print i;
        print " - ";
        print (char) i;
        print " -";
        if (CharIsOfCase(i, 0)) {
            print "  lower";
        }
        if (CharIsOfCase(i, 1)) {
            print "  upper";
        }
        (j = CharToCase(i, 0));
        if ((j ~= i)) {
            print "  tolower: ";
            print (char) j;
        }
        (j = CharToCase(i, 1));
        if ((j ~= i)) {
            print "  toupper: ";
            print (char) j;
        }
        print "^";
    }
];
[ TEXT_TY_RE_SetTrace F;
    (TEXT_TY_RE_Trace = F);
];
[ TEXT_TY_RE_Node n cc par1 par2 par3 offset;
    if ((((n < 0)) || ((n >= RE_MAX_PACKETS)))) {
        rfalse;
    }
    (offset = (RE_PACKET_space + (n*RE_PACKET_SIZE_IN_BYTES)));
    ((offset-->(RE_CCLASS)) = cc);
    ((offset-->(RE_PAR1)) = par1);
    ((offset-->(RE_PAR2)) = par2);
    ((offset-->(RE_PAR3)) = par3);
    ((offset-->(RE_NEXT)) = NULL);
    ((offset-->(RE_PREVIOUS)) = NULL);
    ((offset-->(RE_DOWN)) = NULL);
    ((offset-->(RE_UP)) = NULL);
    ((offset-->(RE_DATA1)) = -1);
    ((offset-->(RE_DATA2)) = -1);
    ((offset-->(RE_CONSTRAINT)) = -1);
    return offset;
];
[ TEXT_TY_RE_NodeAddress n;
    if ((((n < 0)) || ((n >= RE_MAX_PACKETS)))) {
        return (-(1));
    }
    return (RE_PACKET_space + (n*RE_PACKET_SIZE_IN_BYTES));
];
[ TEXT_TY_RE_DebugMatchVars txt offset n i;
    print (RE_Subexpressions-->(10));
    print " collecting subexps^";
    for ((n = 0):(((n < (RE_Subexpressions-->(10)))) && ((n < 10))):(n)++) {
        (offset = (RE_Subexpressions-->(n)));
        print "Subexp ";
        print (offset-->(RE_PAR1));
        print " = [";
        print (offset-->(RE_DATA1));
        print ",";
        print (offset-->(RE_DATA2));
        print "] = ";
        for ((i = (offset-->(RE_DATA1))):(i < (offset-->(RE_DATA2))):(i)++) {
            print (char) BlkValueRead(txt, i);
        }
        print "^";
    }
];
[ TEXT_TY_RE_CreateMatchVars txt offset n i ch ctxt cl csize;
    for ((n = 0):(((n < (RE_Subexpressions-->(10)))) && ((n < 10))):(n)++) {
        (offset = (RE_Subexpressions-->(n)));
        if ((Allocated_Match_Vars-->(n))) {
            BlkValueFree((Allocated_Match_Vars-->(n)));
        }
        ((Allocated_Match_Vars-->(n)) = BlkValueCreate(TEXT_TY));
        TEXT_TY_Transmute((Allocated_Match_Vars-->(n)));
        (ctxt = (Allocated_Match_Vars-->(n)));
        (csize = BlkValueLBCapacity(ctxt));
        (cl = 0);
        for ((i = (offset-->(RE_DATA1))):(i < (offset-->(RE_DATA2))):(i)++) {
            (ch = BlkValueRead(txt, i));
            if (((cl + 1) >= csize)) {
                if ((BlkValueSetLBCapacity(ctxt, (2*cl)) == 0)) {
                    break;
                }
                (csize = BlkValueLBCapacity(ctxt));
            }
            BlkValueWrite(ctxt, (cl)++, ch);
        }
        BlkValueWrite(ctxt, cl, 0);
    }
];
[ TEXT_TY_RE_EmptyMatchVars txt n;
    for ((n = 0):(((n < (RE_Subexpressions-->(10)))) && ((n < 10))):(n)++) {
        if (((Allocated_Match_Vars-->(n)) ~= 0)) {
            BlkValueWrite((Allocated_Match_Vars-->(n)), 0, 0);
        }
    }
];
[ TEXT_TY_RE_GetMatchVar vn offset;
    if ((((((vn < 0)) || ((vn >= 10)))) || ((vn >= (RE_Subexpressions-->(10)))))) {
        return EMPTY_TEXT_VALUE;
    }
    (offset = (RE_Subexpressions-->(vn)));
    if ((offset == 0)) {
        return EMPTY_TEXT_VALUE;
    }
    if (((offset-->(RE_DATA1)) < 0)) {
        return EMPTY_TEXT_VALUE;
    }
    if (((Allocated_Match_Vars-->(vn)) == 0)) {
        print "*** ";
        print vn;
        print " unallocated! ***^";
        return EMPTY_TEXT_VALUE;
    }
    return (Allocated_Match_Vars-->(vn));
];
[ TEXT_TY_MV_End n end offset;
    (offset = (RE_Subexpressions-->(n)));
    if ((end == 0)) {
        return (offset-->(RE_DATA1));
    }
    return (offset-->(RE_DATA2));
];
[ TEXT_TY_RE_Clear_Markers token;
    for (:(token ~= NULL):(token = (token-->(RE_NEXT)))) {
        if (((token-->(RE_DOWN)) ~= NULL)) {
            TEXT_TY_RE_Clear_Markers((token-->(RE_DOWN)));
        }
        ((token-->(RE_DATA1)) = -1);
        ((token-->(RE_DATA2)) = -1);
        ((token-->(RE_CONSTRAINT)) = -1);
    }
];
[ TEXT_TY_RE_DebugTree ftxt detail;
    print "Pattern: ";
    TEXT_TY_Say(ftxt);
    print "^";
    TEXT_TY_RE_DebugSubtree(ftxt, 1, RE_PACKET_space, detail);
];
[ TEXT_TY_RE_DebugSubtree ftxt depth offset detail cup;
    if ((offset ~= NULL)) {
        (cup = (offset-->(RE_UP)));
        if (((offset-->(RE_PREVIOUS)) ~= NULL)) {
            print "*** broken initial previous ***^";
        }
    }
    while ((offset ~= NULL)) {
        if (((offset-->(RE_UP)) ~= cup)) {
            print "*** broken up matching ***^";
        }
        spaces (depth*2);
        TEXT_TY_RE_DebugNode(offset, ftxt, detail);
        if (((offset-->(RE_DOWN)) ~= NULL)) {
            if ((((offset-->(RE_DOWN))-->(RE_UP)) ~= offset)) {
                print "*** broken down/up ***^";
            }
            TEXT_TY_RE_DebugSubtree(ftxt, (depth + 1), (offset-->(RE_DOWN)), detail);
        }
        if (((offset-->(RE_NEXT)) ~= NULL)) {
            if ((((offset-->(RE_NEXT))-->(RE_PREVIOUS)) ~= offset)) {
                print "*** broken next/previous ***^";
            }
        }
        (offset = (offset-->(RE_NEXT)));
    }
];
[ TEXT_TY_RE_DebugNode offset ftxt detail i par1 par2 par3;
    if ((offset == NULL)) {
        print "[NULL]";
        new_line;
        rtrue;
    }
    print "[";
    print ((offset - RE_PACKET_space)/RE_PACKET_SIZE_IN_BYTES);
    print "] ";
    (par1 = (offset-->(RE_PAR1)));
    (par2 = (offset-->(RE_PAR2)));
    (par3 = (offset-->(RE_PAR3)));
    switch ((offset-->(RE_CCLASS))) {
        DIGIT_RE_CC:
            print "DIGIT";
            ;
        NONDIGIT_RE_CC:
            print "NONDIGIT";
            ;
        UCASE_RE_CC:
            print "UCASE";
            ;
        NONUCASE_RE_CC:
            print "NONUCASE";
            ;
        LCASE_RE_CC:
            print "LCASE";
            ;
        NONLCASE_RE_CC:
            print "NONLCASE";
            ;
        WHITESPACE_RE_CC:
            print "WHITESPACE";
            ;
        NONWHITESPACE_RE_CC:
            print "NONWHITESPACE";
            ;
        PUNCTUATION_RE_CC:
            print "PUNCTUATION";
            ;
        NONPUNCTUATION_RE_CC:
            print "NONPUNCTUATION";
            ;
        WORD_RE_CC:
            print "WORD";
            ;
        NONWORD_RE_CC:
            print "NONWORD";
            ;
        ALWAYS_RE_CC:
            print "ALWAYS";
            ;
        NEVER_RE_CC:
            print "NEVER";
            ;
        START_RE_CC:
            print "START";
            ;
        END_RE_CC:
            print "END";
            ;
        BOUNDARY_RE_CC:
            print "BOUNDARY";
            ;
        NONBOUNDARY_RE_CC:
            print "NONBOUNDARY";
            ;
        ANYTHING_RE_CC:
            print "ANYTHING";
            ;
        NOTHING_RE_CC:
            print "NOTHING";
            ;
        RANGE_RE_CC:
            print "RANGE";
            if ((par3 == 1)) {
                print " (negated)";
            }
            print " ";
            for ((i = par1):(i < par2):(i)++) {
                print (char) BlkValueRead(ftxt, i);
            }
            ;
        VARIABLE_RE_CC:
            print "VARIABLE ";
            print par1;
            ;
        SUBEXP_RE_CC:
            if ((par1 == 0)) {
                print "EXP";
            } else {
                print "SUBEXP ";
            }
            if ((par1 >= 0)) {
                print "= V";
                print par1;
            }
            if ((par2 == 1)) {
                if ((par3 == 0)) {
                    print " (?=...) lookahead";
                } else {
                    print " (?<=...) lookbehind of width ";
                    print par3;
                }
            }
            if ((par2 == 2)) {
                if ((par3 == 0)) {
                    print " (?!...) negated lookahead";
                } else {
                    print " (?<!...) negated lookbehind of width ";
                    print par3;
                }
            }
            if ((par2 == 3)) {
                print " uncollecting";
            }
            if ((par2 == 0 or 3)) {
                if ((par3 == 1)) {
                    print " forcing case sensitivity";
                }
                if ((par3 == 2)) {
                    print " forcing case insensitivity";
                }
            }
            if ((par2 == 4)) {
                print " (?>...) possessive";
            }
            ;
        NEWLINE_RE_CC:
            print "NEWLINE";
            ;
        TAB_RE_CC:
            print "TAB";
            ;
        QUANTIFIER_RE_CC:
            print "QUANTIFIER min=";
            print par1;
            print " max=";
            print par2;
            if (par3) {
                print " (lazy)";
            } else {
                print " (greedy)";
            }
            ;
        LITERAL_RE_CC:
            print "LITERAL";
            print " ";
            for ((i = par1):(i < par2):(i)++) {
                print (char) BlkValueRead(ftxt, i);
            }
            ;
        DISJUNCTION_RE_CC:
            print "DISJUNCTION of ";
            print par1;
            print " choices";
            ;
        CHOICE_RE_CC:
            print "CHOICE no ";
            print par1;
            ;
        SENSITIVITY_RE_CC:
            print "SENSITIVITY";
            if (par1) {
                print " off";
            } else {
                print " on";
            }
            ;
        IF_RE_CC:
            print "IF";
            if ((par1 >= 1)) {
                print " = V";
                print par1;
            }
            ;
        CONDITION_RE_CC:
            print "CONDITION";
            if ((par1 >= 1)) {
                print " = V";
                print par1;
            }
            ;
        THEN_RE_CC:
            print "THEN";
            ;
        ELSE_RE_CC:
            print "ELSE";
            ;
    }
    if (detail) {
        print ": ";
        print (offset-->(RE_DATA1));
        print ", ";
        print (offset-->(RE_DATA2));
        print ", ";
        print (offset-->(RE_CONSTRAINT));
    }
    print "^";
];
[ TEXT_TY_CHR_CompileTree ftxt exactly root literal fto no_packets token attach_to;
    (fto = TEXT_TY_CharacterLength(ftxt));
    (root = TEXT_TY_RE_Node(0, SUBEXP_RE_CC, 0, 0, 0));
    (literal = TEXT_TY_RE_Node(1, LITERAL_RE_CC, 0, fto, 0));
    ((root-->(RE_DOWN)) = literal);
    ((literal-->(RE_UP)) = root);
    if (exactly) {
        (no_packets = 2);
        if (((no_packets + 3) > RE_MAX_PACKETS)) {
            return "regexp too complex";
        }
        (exactly = (RE_PACKET_space-->(RE_DOWN)));
        (token = TEXT_TY_RE_Node((no_packets)++, START_RE_CC, 0, 0, 0));
        ((RE_PACKET_space-->(RE_DOWN)) = token);
        ((token-->(RE_UP)) = RE_PACKET_space);
        (attach_to = TEXT_TY_RE_Node((no_packets)++, SUBEXP_RE_CC, (-(1)), 3, 0));
        ((token-->(RE_NEXT)) = attach_to);
        ((attach_to-->(RE_PREVIOUS)) = token);
        ((attach_to-->(RE_UP)) = RE_PACKET_space);
        ((attach_to-->(RE_NEXT)) = TEXT_TY_RE_Node((no_packets)++, END_RE_CC, 0, 0, 0));
        (((attach_to-->(RE_NEXT))-->(RE_PREVIOUS)) = attach_to);
        (((attach_to-->(RE_NEXT))-->(RE_UP)) = RE_PACKET_space);
        ((attach_to-->(RE_DOWN)) = exactly);
        while ((exactly ~= NULL)) {
            ((exactly-->(RE_UP)) = attach_to);
            (exactly = (exactly-->(RE_NEXT)));
        }
    }
    (no_packets = TEXT_TY_RE_ExpandChoices(RE_PACKET_space, no_packets));
];
[ TEXT_TY_RE_CompileTree ftxt exactly no_packets ffrom fto cc par1 par2 par3 quantifiable token attach_to no_subs blevel bits;
    (fto = TEXT_TY_CharacterLength(ftxt));
    if ((fto == 0)) {
        TEXT_TY_RE_Node((no_packets)++, NEVER_RE_CC, 0, 0, 0);
        rtrue;
    }
    (attach_to = TEXT_TY_RE_Node((no_packets)++, SUBEXP_RE_CC, 0, 0, 0));
    ((RE_Subexpressions-->(0)) = attach_to);
    ((RE_Subexpressions-->(10)) = 1);
    (no_subs = 1);
    (quantifiable = 0);
    (blevel = 0);
    for ((ffrom = 0):(ffrom < fto):) {
        (cc = BlkValueRead(ftxt, (ffrom)++));
        (par1 = 0);
        (par2 = 0);
        (par3 = 0);
        if ((cc == 92)) {
            if ((ffrom == fto)) {
                return "Search pattern not terminated";
            }
            (cc = BlkValueRead(ftxt, (ffrom)++));
            switch (cc) {
                98:
                    (cc = BOUNDARY_RE_CC);
                    ;
                66:
                    (cc = NONBOUNDARY_RE_CC);
                    ;
                100:
                    (cc = DIGIT_RE_CC);
                    ;
                68:
                    (cc = NONDIGIT_RE_CC);
                    ;
                108:
                    (cc = LCASE_RE_CC);
                    ;
                76:
                    (cc = NONLCASE_RE_CC);
                    ;
                110:
                    (cc = NEWLINE_RE_CC);
                    ;
                112:
                    (cc = PUNCTUATION_RE_CC);
                    ;
                80:
                    (cc = NONPUNCTUATION_RE_CC);
                    ;
                115:
                    (cc = WHITESPACE_RE_CC);
                    ;
                83:
                    (cc = NONWHITESPACE_RE_CC);
                    ;
                116:
                    (cc = TAB_RE_CC);
                    ;
                117:
                    (cc = UCASE_RE_CC);
                    ;
                85:
                    (cc = NONUCASE_RE_CC);
                    ;
                119:
                    (cc = WORD_RE_CC);
                    ;
                87:
                    (cc = NONWORD_RE_CC);
                    ;
                default:
                    if ((((cc >= 49)) && ((cc <= 57)))) {
                        (par1 = (cc - 48));
                        (cc = VARIABLE_RE_CC);
                    } else {
                        if ((((((cc >= 97)) && ((cc <= 122)))) || ((((cc >= 65)) && ((cc <= 90)))))) {
                            return "unknown escape";
                        }
                        (cc = LITERAL_RE_CC);
                        (par1 = (ffrom - 1));
                        (par2 = ffrom);
                    }
                    ;
            }
            (quantifiable = 1);
        } else {
            switch (cc) {
                40:
                    (par2 = 0);
                    if ((BlkValueRead(ftxt, ffrom) == 63)) {
                        (ffrom)++;
                        (bits = 1);
                        if ((BlkValueRead(ftxt, ffrom) == 45)) {
                            (ffrom)++;
                            (bits = 0);
                        } else {
                            if ((BlkValueRead(ftxt, ffrom) == 60)) {
                                (ffrom)++;
                                (bits = 0);
                            }
                        }
                        switch ((cc = BlkValueRead(ftxt, (ffrom)++))) {
                            35:
                                while ((BlkValueRead(ftxt, (ffrom)++) ~= 0 or 41)) {
                                }
                                if ((BlkValueRead(ftxt, (ffrom - 1)) == 0)) {
                                    return "comment never ends";
                                }
                                continue;
                                ;
                            40:
                                (cc = BlkValueRead(ftxt, ffrom));
                                if ((((cc == 49 or 50 or 51 or 52 or 53 or 54 or 55 or 56 or 57)) && ((BlkValueRead(ftxt, (ffrom + 1)) == 41)))) {
                                    (ffrom = (ffrom + 2));
                                    (par1 = (cc - 48));
                                } else {
                                    (ffrom)--;
                                }
                                (cc = IF_RE_CC);
                                (quantifiable = 0);
                                if ((blevel == 20)) {
                                    return "subexpressions too deep";
                                }
                                ((Subexp_Posns-->((blevel)++)) = TEXT_TY_RE_NodeAddress(no_packets));
                                jump CClassKnown;
                                ;
                            61:
                                (par2 = 1);
                                (par3 = 0);
                                if ((bits == 0)) {
                                    (par3 = -1);
                                }
                                ;
                            33:
                                (par2 = 2);
                                (par3 = 0);
                                if ((bits == 0)) {
                                    (par3 = -1);
                                }
                                ;
                            58:
                                (par2 = 3);
                                ;
                            62:
                                (par2 = 4);
                                ;
                            default:
                                if ((BlkValueRead(ftxt, ffrom) == 41)) {
                                    if ((cc == 105)) {
                                        (cc = SENSITIVITY_RE_CC);
                                        (par1 = bits);
                                        (ffrom)++;
                                        jump CClassKnown;
                                    }
                                }
                                if ((BlkValueRead(ftxt, ffrom) == 58)) {
                                    if ((cc == 105)) {
                                        (par1 = bits);
                                        (par2 = 3);
                                        (par3 = (bits + 1));
                                        (ffrom)++;
                                        jump AllowForm;
                                    }
                                }
                                return "unknown (?...) form";
                                ;
                        }
                    }
                    .AllowForm;
                    if ((par2 == 0)) {
                        (par1 = (no_subs)++);
                    } else {
                        (par1 = -1);
                    }
                    (cc = SUBEXP_RE_CC);
                    (quantifiable = 0);
                    if ((blevel == 20)) {
                        return "subexpressions too deep";
                    }
                    ((Subexp_Posns-->((blevel)++)) = TEXT_TY_RE_NodeAddress(no_packets));
                    ;
                41:
                    if ((blevel == 0)) {
                        return "subexpression bracket mismatch";
                    }
                    (blevel)--;
                    (attach_to = (Subexp_Posns-->(blevel)));
                    if (((attach_to-->(RE_DOWN)) == NULL)) {
                        if ((no_packets >= RE_MAX_PACKETS)) {
                            return "regexp too complex";
                        }
                        ((attach_to-->(RE_DOWN)) = TEXT_TY_RE_Node((no_packets)++, ALWAYS_RE_CC, 0, 0, 0));
                        (((attach_to-->(RE_DOWN))-->(RE_UP)) = attach_to);
                    }
                    (quantifiable = 1);
                    continue;
                    ;
                46:
                    (cc = ANYTHING_RE_CC);
                    (quantifiable = 1);
                    ;
                124:
                    (cc = CHOICE_RE_CC);
                    (quantifiable = 0);
                    ;
                94:
                    (cc = START_RE_CC);
                    (quantifiable = 0);
                    ;
                36:
                    (cc = END_RE_CC);
                    (quantifiable = 0);
                    ;
                123:
                    if ((quantifiable == 0)) {
                        return "quantifier misplaced";
                    }
                    (par1 = 0);
                    (par2 = -1);
                    (bits = 1);
                    while (((cc = BlkValueRead(ftxt, (ffrom)++)) ~= 0 or 125)) {
                        if ((cc == 44)) {
                            (bits)++;
                            if ((bits >= 3)) {
                                return "too many colons in ?{...}";
                            }
                            continue;
                        }
                        if ((((cc >= 48)) || ((cc <= 57)))) {
                            if ((bits == 1)) {
                                if ((par1 < 0)) {
                                    (par1 = 0);
                                }
                                (par1 = ((par1*10) + (cc - 48)));
                            } else {
                                if ((par2 < 0)) {
                                    (par2 = 0);
                                }
                                (par2 = ((par2*10) + (cc - 48)));
                            }
                        } else {
                            return "non-digit in ?{...}";
                        }
                    }
                    if ((cc ~= 125)) {
                        return "{x,y} quantifier never ends";
                    }
                    (cc = QUANTIFIER_RE_CC);
                    if ((par2 == -1)) {
                        if ((bits == 2)) {
                            (par2 = 30000);
                        } else {
                            (par2 = par1);
                        }
                    }
                    if ((par1 > par2)) {
                        return "{x,y} with x greater than y";
                    }
                    if ((BlkValueRead(ftxt, ffrom) == 63)) {
                        (ffrom)++;
                        (par3 = 1);
                    }
                    (quantifiable = 0);
                    ;
                60, 91:
                    (par3 = 0);
                    if ((cc == 60)) {
                        (bits = 62);
                    } else {
                        (bits = 93);
                    }
                    if ((BlkValueRead(ftxt, ffrom) == 94)) {
                        (ffrom)++;
                        (par3 = 1);
                    }
                    (par1 = ffrom);
                    if ((BlkValueRead(ftxt, ffrom) == bits)) {
                        (ffrom)++;
                    }
                    while ((cc ~= bits or 0)) {
                        (cc = BlkValueRead(ftxt, (ffrom)++));
                        if ((cc == 92)) {
                            (cc = BlkValueRead(ftxt, (ffrom)++));
                            if ((cc ~= 0)) {
                                (cc = BlkValueRead(ftxt, (ffrom)++));
                            }
                        }
                    }
                    if ((cc == 0)) {
                        return "Character range never ends";
                    }
                    (par2 = (ffrom - 1));
                    if ((((((((par2 > (par1 + 1))) && ((BlkValueRead(ftxt, par1) == 58)))) && ((BlkValueRead(ftxt, (par2 - 1)) == 58)))) && ((BlkValueRead(ftxt, (par2 - 2)) ~= 92)))) {
                        return "POSIX named character classes unsupported";
                    }
                    (bits = TEXT_TY_RE_RangeSyntaxCorrect(ftxt, par1, par2));
                    if (bits) {
                        return bits;
                    }
                    if ((par1 < par2)) {
                        (cc = RANGE_RE_CC);
                    } else {
                        (cc = NOTHING_RE_CC);
                    }
                    (quantifiable = 1);
                    ;
                42:
                    if ((quantifiable == 0)) {
                        return "quantifier misplaced";
                    }
                    (cc = QUANTIFIER_RE_CC);
                    (par1 = 0);
                    (par2 = 30000);
                    if ((BlkValueRead(ftxt, ffrom) == 63)) {
                        (ffrom)++;
                        (par3 = 1);
                    }
                    (quantifiable = 0);
                    ;
                43:
                    if ((quantifiable == 0)) {
                        return "quantifier misplaced";
                    }
                    (cc = QUANTIFIER_RE_CC);
                    (par1 = 1);
                    (par2 = 30000);
                    if ((BlkValueRead(ftxt, ffrom) == 63)) {
                        (ffrom)++;
                        (par3 = 1);
                    }
                    (quantifiable = 0);
                    ;
                63:
                    if ((quantifiable == 0)) {
                        return "quantifier misplaced";
                    }
                    (cc = QUANTIFIER_RE_CC);
                    (par1 = 0);
                    (par2 = 1);
                    if ((BlkValueRead(ftxt, ffrom) == 63)) {
                        (ffrom)++;
                        (par3 = 1);
                    }
                    (quantifiable = 0);
                    ;
            }
        }
        .CClassKnown;
        if ((cc >= 0)) {
            (quantifiable = 1);
            if (((((attach_to-->(RE_CCLASS)) == LITERAL_RE_CC)) && ((BlkValueRead(ftxt, ffrom) ~= 42 or 43 or 63 or 123)))) {
                ((attach_to-->(RE_PAR2)))++;
                if ((TEXT_TY_RE_Trace == 2)) {
                    print "Extending literal by ";
                    print cc;
                    print "=";
                    print (char) cc;
                    print "^";
                }
                continue;
            }
            (cc = LITERAL_RE_CC);
            (par1 = (ffrom - 1));
            (par2 = ffrom);
        }
        if ((no_packets >= RE_MAX_PACKETS)) {
            return "regexp too complex";
        }
        if ((TEXT_TY_RE_Trace == 2)) {
            print "Attaching packet ";
            print (no_packets + 1);
            print " to ";
            TEXT_TY_RE_DebugNode(attach_to, ftxt);
            TEXT_TY_RE_DebugTree(ftxt);
        }
        (token = TEXT_TY_RE_Node((no_packets)++, cc, par1, par2, par3));
        if (((((token-->(RE_CCLASS)) == SUBEXP_RE_CC)) && (((token-->(RE_PAR2)) == 0)))) {
            ((RE_Subexpressions-->((token-->(RE_PAR1)))) = token);
            ((RE_Subexpressions-->(10)))++;
        }
        if (((((attach_to-->(RE_CCLASS)) == SUBEXP_RE_CC or CHOICE_RE_CC or IF_RE_CC)) && (((attach_to-->(RE_DOWN)) == NULL)))) {
            ((attach_to-->(RE_DOWN)) = token);
            ((token-->(RE_UP)) = attach_to);
        } else {
            if (((((token-->(RE_CCLASS)) == CHOICE_RE_CC)) && ((((attach_to-->(RE_UP))-->(RE_CCLASS)) == CHOICE_RE_CC)))) {
                (no_packets)--;
                (token = (attach_to-->(RE_UP)));
            } else {
                if (((token-->(RE_CCLASS)) == CHOICE_RE_CC)) {
                    while (((attach_to-->(RE_PREVIOUS)) ~= NULL)) {
                        (attach_to = (attach_to-->(RE_PREVIOUS)));
                    }
                }
                if (((token-->(RE_CCLASS)) == QUANTIFIER_RE_CC or CHOICE_RE_CC)) {
                    ((token-->(RE_PREVIOUS)) = (attach_to-->(RE_PREVIOUS)));
                    ((token-->(RE_UP)) = (attach_to-->(RE_UP)));
                    if (((((attach_to-->(RE_UP)) ~= NULL)) && (((attach_to-->(RE_PREVIOUS)) == NULL)))) {
                        (((attach_to-->(RE_UP))-->(RE_DOWN)) = token);
                    }
                    ((token-->(RE_DOWN)) = attach_to);
                    (bits = attach_to);
                    while ((bits ~= NULL)) {
                        ((bits-->(RE_UP)) = token);
                        (bits = (bits-->(RE_NEXT)));
                    }
                    ((attach_to-->(RE_PREVIOUS)) = NULL);
                    if (((token-->(RE_PREVIOUS)) ~= NULL)) {
                        (((token-->(RE_PREVIOUS))-->(RE_NEXT)) = token);
                    }
                } else {
                    ((attach_to-->(RE_NEXT)) = token);
                    ((token-->(RE_PREVIOUS)) = attach_to);
                    ((token-->(RE_UP)) = (attach_to-->(RE_UP)));
                }
            }
        }
        if (((token-->(RE_CCLASS)) == CHOICE_RE_CC)) {
            if ((no_packets >= RE_MAX_PACKETS)) {
                return "regexp too complex";
            }
            ((token-->(RE_NEXT)) = TEXT_TY_RE_Node((no_packets)++, CHOICE_RE_CC, 0, 0, 0));
            (((token-->(RE_NEXT))-->(RE_PREVIOUS)) = token);
            (((token-->(RE_NEXT))-->(RE_UP)) = (token-->(RE_UP)));
            (token = (token-->(RE_NEXT)));
        }
        (attach_to = token);
        if ((TEXT_TY_RE_Trace == 2)) {
            print "Result:^";
            TEXT_TY_RE_DebugTree(ftxt);
        }
    }
    if ((blevel ~= 0)) {
        return "subexpression bracket mismatch";
    }
    if (exactly) {
        if (((no_packets + 3) > RE_MAX_PACKETS)) {
            return "regexp too complex";
        }
        (exactly = (RE_PACKET_space-->(RE_DOWN)));
        (token = TEXT_TY_RE_Node((no_packets)++, START_RE_CC, 0, 0, 0));
        ((RE_PACKET_space-->(RE_DOWN)) = token);
        ((token-->(RE_UP)) = RE_PACKET_space);
        (attach_to = TEXT_TY_RE_Node((no_packets)++, SUBEXP_RE_CC, (-(1)), 3, 0));
        ((token-->(RE_NEXT)) = attach_to);
        ((attach_to-->(RE_PREVIOUS)) = token);
        ((attach_to-->(RE_UP)) = RE_PACKET_space);
        ((attach_to-->(RE_NEXT)) = TEXT_TY_RE_Node((no_packets)++, END_RE_CC, 0, 0, 0));
        (((attach_to-->(RE_NEXT))-->(RE_PREVIOUS)) = attach_to);
        (((attach_to-->(RE_NEXT))-->(RE_UP)) = RE_PACKET_space);
        ((attach_to-->(RE_DOWN)) = exactly);
        while ((exactly ~= NULL)) {
            ((exactly-->(RE_UP)) = attach_to);
            (exactly = (exactly-->(RE_NEXT)));
        }
    }
    (no_packets = TEXT_TY_RE_ExpandChoices(RE_PACKET_space, no_packets));
    if (TEXT_TY_RE_Trace) {
        print "Compiled pattern:^";
        TEXT_TY_RE_DebugTree(ftxt);
    }
    (bits = TEXT_TY_RE_CheckTree(RE_PACKET_space, no_subs));
    if (bits) {
        return bits;
    }
    return no_packets;
];
[ TEXT_TY_RE_RangeSyntaxCorrect ftxt rf rt i chm;
    for ((i = rf):(i < rt):(i)++) {
        (chm = BlkValueRead(ftxt, i));
        if ((((chm == 92)) && (((i + 1) < rt)))) {
            (chm = BlkValueRead(ftxt, ++(i)));
            if ((((((chm >= 97)) && ((chm <= 122)))) || ((((chm >= 65)) && ((chm <= 90)))))) {
                if ((chm ~= 115 or 83 or 112 or 80 or 119 or 87 or 100 or 68 or 110 or 116 or 108 or 76 or 117 or 85)) {
                    return "Invalid escape in {} range";
                }
            }
        }
        if (((((i + 2) < rt)) && ((BlkValueRead(ftxt, (i + 1)) == 45)))) {
            if ((chm > BlkValueRead(ftxt, (i + 2)))) {
                return "Invalid {} range";
            }
            (i = (i + 2));
        }
    }
    rfalse;
];
[ TEXT_TY_RE_ExpandChoices token no_packets rv prev nex holder new ct n cond_node then_node else_node;
    while ((token ~= NULL)) {
        if (((token-->(RE_CCLASS)) == IF_RE_CC)) {
            if ((((token-->(RE_DOWN))-->(RE_CCLASS)) == CHOICE_RE_CC)) {
                for (((nex = (token-->(RE_DOWN))),(n = 0)):(nex ~= NULL):(nex = (nex-->(RE_NEXT)))) {
                    (n)++;
                }
                if ((n ~= 2)) {
                    return "conditional has too many clauses";
                }
                if ((no_packets >= RE_MAX_PACKETS)) {
                    return "regexp too complex";
                }
                (cond_node = TEXT_TY_RE_Node((no_packets)++, CONDITION_RE_CC, 0, 0, 0));
                if (((token-->(RE_PAR1)) >= 1)) {
                    ((cond_node-->(RE_PAR1)) = (token-->(RE_PAR1)));
                }
                (then_node = (token-->(RE_DOWN)));
                ((then_node-->(RE_CCLASS)) = THEN_RE_CC);
                (else_node = (then_node-->(RE_NEXT)));
                ((else_node-->(RE_CCLASS)) = ELSE_RE_CC);
                if (((cond_node-->(RE_PAR1)) < 1)) {
                    ((cond_node-->(RE_DOWN)) = (then_node-->(RE_DOWN)));
                    ((then_node-->(RE_DOWN)) = ((then_node-->(RE_DOWN))-->(RE_NEXT)));
                    if (((then_node-->(RE_DOWN)) ~= NULL)) {
                        (((then_node-->(RE_DOWN))-->(RE_PREVIOUS)) = NULL);
                    }
                    (((cond_node-->(RE_DOWN))-->(RE_NEXT)) = NULL);
                    (((cond_node-->(RE_DOWN))-->(RE_UP)) = cond_node);
                }
                ((token-->(RE_DOWN)) = cond_node);
                ((cond_node-->(RE_UP)) = token);
                ((cond_node-->(RE_NEXT)) = then_node);
                ((then_node-->(RE_PREVIOUS)) = cond_node);
            } else {
                if ((no_packets >= RE_MAX_PACKETS)) {
                    return "regexp too complex";
                }
                (cond_node = TEXT_TY_RE_Node((no_packets)++, CONDITION_RE_CC, 0, 0, 0));
                if ((no_packets >= RE_MAX_PACKETS)) {
                    return "regexp too complex";
                }
                (then_node = TEXT_TY_RE_Node((no_packets)++, THEN_RE_CC, 0, 0, 0));
                if (((token-->(RE_PAR1)) >= 1)) {
                    ((cond_node-->(RE_PAR1)) = (token-->(RE_PAR1)));
                    ((then_node-->(RE_DOWN)) = (token-->(RE_DOWN)));
                } else {
                    ((cond_node-->(RE_DOWN)) = (token-->(RE_DOWN)));
                    ((then_node-->(RE_DOWN)) = ((token-->(RE_DOWN))-->(RE_NEXT)));
                    (((cond_node-->(RE_DOWN))-->(RE_NEXT)) = NULL);
                    (((cond_node-->(RE_DOWN))-->(RE_UP)) = cond_node);
                }
                ((token-->(RE_DOWN)) = cond_node);
                ((cond_node-->(RE_UP)) = token);
                ((cond_node-->(RE_NEXT)) = then_node);
                ((then_node-->(RE_PREVIOUS)) = cond_node);
                ((then_node-->(RE_UP)) = token);
                ((then_node-->(RE_NEXT)) = NULL);
                if (((then_node-->(RE_DOWN)) ~= NULL)) {
                    (((then_node-->(RE_DOWN))-->(RE_PREVIOUS)) = NULL);
                }
                for ((nex = (then_node-->(RE_DOWN))):(nex ~= NULL):(nex = (nex-->(RE_NEXT)))) {
                    ((nex-->(RE_UP)) = then_node);
                }
            }
            if (((cond_node-->(RE_DOWN)) ~= NULL)) {
                (nex = (cond_node-->(RE_DOWN)));
                if (((((((nex-->(RE_CCLASS)) ~= SUBEXP_RE_CC)) || (((nex-->(RE_NEXT)) ~= NULL)))) || (((nex-->(RE_PAR2)) ~= 1 or 2)))) {
                    return "condition not lookahead/behind";
                }
            }
        }
        if (((((token-->(RE_CCLASS)) == CHOICE_RE_CC)) && (((token-->(RE_PAR1)) < 1)))) {
            (prev = (token-->(RE_PREVIOUS)));
            (nex = (token-->(RE_NEXT)));
            while ((((nex ~= NULL)) && (((nex-->(RE_CCLASS)) == CHOICE_RE_CC)))) {
                (nex = (nex-->(RE_NEXT)));
            }
            (holder = (token-->(RE_UP)));
            if ((holder == NULL)) {
                return "bang";
            }
            if ((no_packets >= RE_MAX_PACKETS)) {
                return "regexp too complex";
            }
            (new = TEXT_TY_RE_Node((no_packets)++, DISJUNCTION_RE_CC, 0, 0, 0));
            ((holder-->(RE_DOWN)) = new);
            ((new-->(RE_UP)) = holder);
            if ((prev ~= NULL)) {
                ((prev-->(RE_NEXT)) = new);
                ((new-->(RE_PREVIOUS)) = prev);
            }
            if ((nex ~= NULL)) {
                ((nex-->(RE_PREVIOUS)) = new);
                ((new-->(RE_NEXT)) = nex);
            }
            ((new-->(RE_DOWN)) = token);
            ((token-->(RE_PREVIOUS)) = NULL);
            (ct = 1);
            while ((token ~= NULL)) {
                ((token-->(RE_PAR1)) = (ct)++);
                ((token-->(RE_UP)) = new);
                if (((((token-->(RE_NEXT)) ~= NULL)) && ((((token-->(RE_NEXT))-->(RE_CCLASS)) ~= CHOICE_RE_CC)))) {
                    ((token-->(RE_NEXT)) = NULL);
                }
                (token = (token-->(RE_NEXT)));
            }
            ((new-->(RE_PAR1)) = (ct - 1));
            if ((token ~= NULL)) {
                ((token-->(RE_NEXT)) = NULL);
            }
            (token = new);
            continue;
        }
        if (((token-->(RE_DOWN)) ~= NULL)) {
            (no_packets = TEXT_TY_RE_ExpandChoices((token-->(RE_DOWN)), no_packets));
            if ((((no_packets < 0)) || ((no_packets >= RE_MAX_PACKETS)))) {
                break;
            }
        }
        (token = (token-->(RE_NEXT)));
    }
    return no_packets;
];
[ TEXT_TY_RE_CheckTree token no_subs rv;
    while ((token ~= NULL)) {
        if (((token-->(RE_CCLASS)) == VARIABLE_RE_CC)) {
            if (((token-->(RE_PAR1)) >= no_subs)) {
                return "reference to nonexistent group";
            }
        }
        if (((((((token-->(RE_CCLASS)) == SUBEXP_RE_CC)) && (((token-->(RE_PAR2)) == 1 or 2)))) && (((token-->(RE_PAR3)) == -1)))) {
            ((token-->(RE_PAR3)) = TEXT_TY_RE_Width((token-->(RE_DOWN))));
            if (((token-->(RE_PAR3)) == -1)) {
                return "variable length lookbehind not implemented";
            }
        }
        if (((token-->(RE_DOWN)) ~= NULL)) {
            (rv = TEXT_TY_RE_CheckTree((token-->(RE_DOWN)), no_subs));
            if (rv) {
                return rv;
            }
        }
        (token = (token-->(RE_NEXT)));
    }
    rfalse;
];
[ TEXT_TY_RE_Width token downwards w rv aw choice;
    while ((token ~= NULL)) {
        switch ((token-->(RE_CCLASS))) {
            DIGIT_RE_CC, NONDIGIT_RE_CC, WHITESPACE_RE_CC, NONWHITESPACE_RE_CC, PUNCTUATION_RE_CC, NONPUNCTUATION_RE_CC, WORD_RE_CC, NONWORD_RE_CC, ANYTHING_RE_CC, NOTHING_RE_CC, RANGE_RE_CC, NEWLINE_RE_CC, TAB_RE_CC, UCASE_RE_CC, NONUCASE_RE_CC, LCASE_RE_CC, NONLCASE_RE_CC:
                (w)++;
                ;
            START_RE_CC, END_RE_CC, BOUNDARY_RE_CC, NONBOUNDARY_RE_CC, ALWAYS_RE_CC:
                ;
            LITERAL_RE_CC:
                (w = ((w + (token-->(RE_PAR2))) - (token-->(RE_PAR1))));
                ;
            VARIABLE_RE_CC:
                return (-(1));
                ;
            IF_RE_CC:
                (rv = TEXT_TY_RE_Width(((token-->(RE_DOWN))-->(RE_NEXT))));
                if ((rv == -1)) {
                    return (-(1));
                }
                if ((rv ~= TEXT_TY_RE_Width((((token-->(RE_DOWN))-->(RE_NEXT))-->(RE_NEXT))))) {
                    return (-(1));
                }
                (w = (w + rv));
                ;
            SUBEXP_RE_CC:
                if (((token-->(RE_PAR2)) == 1 or 2)) {
                    (rv = 0);
                } else {
                    (rv = TEXT_TY_RE_Width((token-->(RE_DOWN))));
                    if ((rv == -1)) {
                        return (-(1));
                    }
                }
                (w = (w + rv));
                ;
            QUANTIFIER_RE_CC:
                if (((token-->(RE_PAR1)) ~= (token-->(RE_PAR2)))) {
                    return (-(1));
                }
                (rv = TEXT_TY_RE_Width((token-->(RE_DOWN))));
                if ((rv == -1)) {
                    return (-(1));
                }
                (w = (w + (rv*(token-->(RE_PAR1)))));
                ;
            DISJUNCTION_RE_CC:
                (aw = -1);
                for ((choice = (token-->(RE_DOWN))):(choice ~= NULL):(choice = (choice-->(RE_NEXT)))) {
                    (rv = TEXT_TY_RE_Width((choice-->(RE_DOWN))));
                    if ((rv == -1)) {
                        return (-(1));
                    }
                    if ((((aw >= 0)) && ((aw ~= rv)))) {
                        return (-(1));
                    }
                    (aw = rv);
                }
                (w = (w + aw));
                ;
            SENSITIVITY_RE_CC:
                ;
        }
        if (downwards) {
            return w;
        }
        if ((token ~= NULL)) {
            (token = (token-->(RE_NEXT)));
        }
    }
    return w;
];
[ TEXT_TY_RE_PrintNoRewinds;
    print TEXT_TY_RE_RewindCount;
];
[ TEXT_TY_RE_Parse ftxt txt ipos insens ilen rv root i initial_mode;
    (ilen = TEXT_TY_CharacterLength(txt));
    if ((((ipos < 0)) || ((ipos > ilen)))) {
        return (-(1));
    }
    (root = RE_PACKET_space);
    (initial_mode = 0);
    if (insens) {
        (initial_mode = CIS_MFLAG);
    }
    TEXT_TY_RE_Clear_Markers(RE_PACKET_space);
    for (:(ipos <= ilen):(ipos)++) {
        if (((((((RE_PACKET_space-->(RE_DOWN)) ~= NULL)) && ((((RE_PACKET_space-->(RE_DOWN))-->(RE_CCLASS)) == START_RE_CC)))) && ((ipos > 0)))) {
            (rv = -1);
            break;
        }
        if ((ipos > 0)) {
            TEXT_TY_RE_EraseConstraints(RE_PACKET_space);
        }
        (TEXT_TY_RE_RewindCount = 0);
        (rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, ipos, ilen, RE_PACKET_space, initial_mode));
        if ((rv >= 0)) {
            break;
        }
    }
    if ((rv == -1)) {
        ((root-->(RE_DATA1)) = -1);
        ((root-->(RE_DATA2)) = -1);
    } else {
        ((root-->(RE_DATA1)) = ipos);
        ((root-->(RE_DATA2)) = (ipos + rv));
    }
    return rv;
];
[ TEXT_TY_RE_ParseAtPosition ftxt txt ifrom ito token mode_flags outcome ipos npos rv i ch edge rewind_this;
    if ((ifrom > ito)) {
        return (-(1));
    }
    (ipos = ifrom);
    .Rewind;
    while ((token ~= NULL)) {
        (outcome = 0);
        if (TEXT_TY_RE_Trace) {
            print "Matching at ";
            print ipos;
            print ": ";
            TEXT_TY_RE_DebugNode(token, ftxt, 1);
        }
        if ((ipos < ito)) {
            (ch = BlkValueRead(txt, ipos));
        } else {
            (ch = 0);
        }
        ((token-->(RE_MODES)) = mode_flags);
        switch ((token-->(RE_CCLASS))) {
            CHOICE_RE_CC:
                return "internal error";
                ;
            SENSITIVITY_RE_CC:
                if ((token-->(RE_PAR1))) {
                    (mode_flags = ((mode_flags)|(CIS_MFLAG)));
                } else {
                    (mode_flags = ((mode_flags)&((~(CIS_MFLAG)))));
                }
                (outcome = 1);
                ;
            ALWAYS_RE_CC:
                (outcome = 1);
                ;
            NEVER_RE_CC:
                ;
            START_RE_CC:
                if ((ipos == 0)) {
                    (outcome = 1);
                }
                ;
            END_RE_CC:
                if ((BlkValueRead(txt, ipos) == 0)) {
                    (outcome = 1);
                }
                ;
            BOUNDARY_RE_CC:
                (rv = 0);
                if ((BlkValueRead(txt, ipos) == 0 or 10 or 13 or 32 or 9 or 46 or 44 or 33 or 63 or 45 or 47 or 34 or 58 or 59 or 40 or 41 or 91 or 93 or 123 or 125)) {
                    (rv)++;
                }
                if ((ipos == 0)) {
                    (ch = 0);
                } else {
                    (ch = BlkValueRead(txt, (ipos - 1)));
                }
                if ((ch == 0 or 10 or 13 or 32 or 9 or 46 or 44 or 33 or 63 or 45 or 47 or 34 or 58 or 59 or 40 or 41 or 91 or 93 or 123 or 125)) {
                    (rv)++;
                }
                if ((rv == 1)) {
                    (outcome = 1);
                }
                ;
            NONBOUNDARY_RE_CC:
                (rv = 0);
                if ((BlkValueRead(txt, ipos) == 0 or 10 or 13 or 32 or 9 or 46 or 44 or 33 or 63 or 45 or 47 or 34 or 58 or 59 or 40 or 41 or 91 or 93 or 123 or 125)) {
                    (rv)++;
                }
                if ((ipos == 0)) {
                    (ch = 0);
                } else {
                    (ch = BlkValueRead(txt, (ipos - 1)));
                }
                if ((ch == 0 or 10 or 13 or 32 or 9 or 46 or 44 or 33 or 63 or 45 or 47 or 34 or 58 or 59 or 40 or 41 or 91 or 93 or 123 or 125)) {
                    (rv)++;
                }
                if ((rv ~= 1)) {
                    (outcome = 1);
                }
                ;
            IF_RE_CC:
                (i = (token-->(RE_PAR1)));
                (ch = 0);
                if (TEXT_TY_RE_Trace) {
                    print "Trying conditional from ";
                    print ipos;
                    print ": ";
                    TEXT_TY_RE_DebugNode(token, ftxt, 1);
                }
                if ((i >= 1)) {
                    if ((((i < (RE_Subexpressions-->(10)))) && ((((RE_Subexpressions-->(i))-->(RE_DATA1)) >= 0)))) {
                        (ch = 1);
                    }
                } else {
                    (rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, ipos, ito, ((token-->(RE_DOWN))-->(RE_DOWN)), mode_flags));
                    if ((rv >= 0)) {
                        (ch = 1);
                    }
                }
                if (TEXT_TY_RE_Trace) {
                    print "Condition found to be ";
                    print ch;
                    print "^";
                }
                if (ch) {
                    (rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, ipos, ito, (((token-->(RE_DOWN))-->(RE_NEXT))-->(RE_DOWN)), mode_flags));
                } else {
                    if (((((token-->(RE_DOWN))-->(RE_NEXT))-->(RE_NEXT)) == NULL)) {
                        (rv = 0);
                    } else {
                        (rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, ipos, ito, ((((token-->(RE_DOWN))-->(RE_NEXT))-->(RE_NEXT))-->(RE_DOWN)), mode_flags));
                    }
                }
                if ((rv >= 0)) {
                    (outcome = 1);
                    (ipos = (ipos + rv));
                }
                ;
            DISJUNCTION_RE_CC:
                if (TEXT_TY_RE_Trace) {
                    print "Trying disjunction from ";
                    print ipos;
                    print ": ";
                    TEXT_TY_RE_DebugNode(token, ftxt, 1);
                }
                for ((ch = (token-->(RE_DOWN))):(ch ~= NULL):(ch = (ch-->(RE_NEXT)))) {
                    if (((ch-->(RE_PAR1)) <= (token-->(RE_CONSTRAINT)))) {
                        continue;
                    }
                    if (TEXT_TY_RE_Trace) {
                        print "Trying choice at ";
                        print ipos;
                        print ": ";
                        TEXT_TY_RE_DebugNode(ch, ftxt, 1);
                    }
                    (rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, ipos, ito, (ch-->(RE_DOWN)), mode_flags));
                    if ((rv >= 0)) {
                        ((token-->(RE_DATA1)) = ipos);
                        ((token-->(RE_DATA2)) = (ch-->(RE_PAR1)));
                        (ipos = (ipos + rv));
                        (outcome = 1);
                        if (TEXT_TY_RE_Trace) {
                            print "Choice worked with width ";
                            print rv;
                            print ": ";
                            TEXT_TY_RE_DebugNode(ch, ftxt, 1);
                        }
                        break;
                    } else {
                        if ((((mode_flags)&(ACCUM_MFLAG)) == 0)) {
                            TEXT_TY_RE_FailSubexpressions((ch-->(RE_DOWN)));
                        }
                    }
                }
                if ((outcome == 0)) {
                    if (TEXT_TY_RE_Trace) {
                        print "Failed disjunction from ";
                        print ipos;
                        print ": ";
                        TEXT_TY_RE_DebugNode(token, ftxt, 1);
                    }
                    ((token-->(RE_DATA1)) = ipos);
                    ((token-->(RE_DATA2)) = -1);
                }
                ;
            SUBEXP_RE_CC:
                if (((token-->(RE_PAR2)) == 1 or 2)) {
                    (npos = (ipos - (token-->(RE_PAR3))));
                    if ((npos < 0)) {
                        (rv = -1);
                    } else {
                        (rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, npos, ito, (token-->(RE_DOWN)), mode_flags));
                    }
                } else {
                    switch ((token-->(RE_PAR3))) {
                        0:
                            (rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, ipos, ito, (token-->(RE_DOWN)), mode_flags));
                            ;
                        1:
                            (rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, ipos, ito, (token-->(RE_DOWN)), ((mode_flags)&((~(CIS_MFLAG))))));
                            ;
                        2:
                            (rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, ipos, ito, (token-->(RE_DOWN)), ((mode_flags)|(CIS_MFLAG))));
                            ;
                    }
                }
                (npos = ipos);
                if ((rv >= 0)) {
                    (npos = (ipos + rv));
                }
                switch ((token-->(RE_PAR2))) {
                    1:
                        if ((rv >= 0)) {
                            (rv = 0);
                        }
                        ;
                    2:
                        if ((rv >= 0)) {
                            (rv = -1);
                        } else {
                            (rv = 0);
                        }
                        ;
                }
                if ((rv >= 0)) {
                    ((token-->(RE_DATA1)) = ipos);
                    (ipos = (ipos + rv));
                    ((token-->(RE_DATA2)) = npos);
                    (outcome = 1);
                } else {
                    if ((((mode_flags)&(ACCUM_MFLAG)) == 0)) {
                        ((token-->(RE_DATA1)) = -1);
                        ((token-->(RE_DATA2)) = -1);
                    }
                }
                if (((token-->(RE_PAR2)) == 2)) {
                    TEXT_TY_RE_FailSubexpressions(token, 1);
                }
                ;
            QUANTIFIER_RE_CC:
                ((token-->(RE_DATA1)) = ipos);
                if ((((token-->(RE_DOWN))-->(RE_CCLASS)) == SUBEXP_RE_CC)) {
                    (((token-->(RE_DOWN))-->(RE_CACHE1)) = -1);
                    (((token-->(RE_DOWN))-->(RE_CACHE2)) = -1);
                }
                if (TEXT_TY_RE_Trace) {
                    print "Trying quantifier from ";
                    print ipos;
                    print ": ";
                    TEXT_TY_RE_DebugNode(token, ftxt, 1);
                }
                if (((token-->(RE_PAR3)) == 0)) {
                    (edge = (token-->(RE_PAR2)));
                    if (((token-->(RE_CONSTRAINT)) >= 0)) {
                        (edge = (token-->(RE_CONSTRAINT)));
                    }
                    (rv = -1);
                    for (((i = 0),(npos = ipos)):(i < edge):(i)++) {
                        if (TEXT_TY_RE_Trace) {
                            print "Trying quant rep ";
                            print (i + 1);
                            print " at ";
                            print npos;
                            print ": ";
                            TEXT_TY_RE_DebugNode(token, ftxt, 1);
                        }
                        (rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, npos, ito, (token-->(RE_DOWN)), ((mode_flags)|(ACCUM_MFLAG))));
                        if ((rv < 0)) {
                            break;
                        }
                        if ((((token-->(RE_DOWN))-->(RE_CCLASS)) == SUBEXP_RE_CC)) {
                            (((token-->(RE_DOWN))-->(RE_CACHE1)) = ((token-->(RE_DOWN))-->(RE_DATA1)));
                            (((token-->(RE_DOWN))-->(RE_CACHE2)) = ((token-->(RE_DOWN))-->(RE_DATA2)));
                        }
                        if ((((((rv == 0)) && (((token-->(RE_PAR2)) == 30000)))) && ((i >= 1)))) {
                            (i)++;
                            break;
                        }
                        (npos = (npos + rv));
                    }
                    if ((((i >= (token-->(RE_PAR1)))) && ((i <= (token-->(RE_PAR2)))))) {
                        (outcome = 1);
                    }
                } else {
                    (edge = (token-->(RE_PAR1)));
                    if (((token-->(RE_CONSTRAINT)) > edge)) {
                        (edge = (token-->(RE_CONSTRAINT)));
                    }
                    for (((i = 0),(npos = ipos)):(((npos < ito)) && ((i < (token-->(RE_PAR2))))):(i)++) {
                        if ((i >= edge)) {
                            break;
                        }
                        if (TEXT_TY_RE_Trace) {
                            print "Trying quant rep ";
                            print (i + 1);
                            print " at ";
                            print npos;
                            print ": ";
                            TEXT_TY_RE_DebugNode(token, ftxt, 1);
                        }
                        (rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, npos, ito, (token-->(RE_DOWN)), ((mode_flags)|(ACCUM_MFLAG))));
                        if ((rv < 0)) {
                            break;
                        }
                        if ((((token-->(RE_DOWN))-->(RE_CCLASS)) == SUBEXP_RE_CC)) {
                            (((token-->(RE_DOWN))-->(RE_CACHE1)) = ((token-->(RE_DOWN))-->(RE_DATA1)));
                            (((token-->(RE_DOWN))-->(RE_CACHE2)) = ((token-->(RE_DOWN))-->(RE_DATA2)));
                        }
                        if ((((((rv == 0)) && (((token-->(RE_PAR2)) == 30000)))) && ((i >= 1)))) {
                            (i)++;
                            break;
                        }
                        (npos = (npos + rv));
                    }
                    if ((((i >= edge)) && ((i <= (token-->(RE_PAR2)))))) {
                        (outcome = 1);
                    }
                }
                if (outcome) {
                    if (((token-->(RE_PAR3)) == 0)) {
                        if ((i > (token-->(RE_PAR1)))) {
                            ((token-->(RE_DATA2)) = (i - 1));
                        } else {
                            ((token-->(RE_DATA2)) = -1);
                        }
                    } else {
                        if ((i < (token-->(RE_PAR2)))) {
                            ((token-->(RE_DATA2)) = (i + 1));
                        } else {
                            ((token-->(RE_DATA2)) = -1);
                        }
                    }
                    (ipos = npos);
                    if ((((i == 0)) && ((((mode_flags)&(ACCUM_MFLAG)) == 0)))) {
                        TEXT_TY_RE_FailSubexpressions((token-->(RE_DOWN)));
                    }
                    if ((((token-->(RE_DOWN))-->(RE_CCLASS)) == SUBEXP_RE_CC)) {
                        (((token-->(RE_DOWN))-->(RE_DATA1)) = ((token-->(RE_DOWN))-->(RE_CACHE1)));
                        (((token-->(RE_DOWN))-->(RE_DATA2)) = ((token-->(RE_DOWN))-->(RE_CACHE2)));
                    }
                    if (TEXT_TY_RE_Trace) {
                        print "Successful quant reps ";
                        print i;
                        print ": ";
                        TEXT_TY_RE_DebugNode(token, ftxt, 1);
                    }
                } else {
                    if ((((mode_flags)&(ACCUM_MFLAG)) == 0)) {
                        TEXT_TY_RE_FailSubexpressions((token-->(RE_DOWN)));
                    }
                    if (TEXT_TY_RE_Trace) {
                        print "Failed quant reps ";
                        print i;
                        print ": ";
                        TEXT_TY_RE_DebugNode(token, ftxt, 1);
                    }
                }
                ;
            NOTHING_RE_CC:
                ;
            ANYTHING_RE_CC:
                if (ch) {
                    (outcome = 1);
                }
                (ipos)++;
                ;
            WHITESPACE_RE_CC:
                if ((ch == 10 or 13 or 32 or 9)) {
                    (outcome = 1);
                    (ipos)++;
                }
                ;
            NONWHITESPACE_RE_CC:
                if (((ch) && ((ch ~= 10 or 13 or 32 or 9)))) {
                    (outcome = 1);
                    (ipos)++;
                }
                ;
            PUNCTUATION_RE_CC:
                if ((ch == 46 or 44 or 33 or 63 or 45 or 47 or 34 or 58 or 59 or 40 or 41 or 91 or 93 or 123 or 125)) {
                    (outcome = 1);
                    (ipos)++;
                }
                ;
            NONPUNCTUATION_RE_CC:
                if (((ch) && ((ch ~= 46 or 44 or 33 or 63 or 45 or 47 or 34 or 58 or 59 or 40 or 41 or 91 or 93 or 123 or 125)))) {
                    (outcome = 1);
                    (ipos)++;
                }
                ;
            WORD_RE_CC:
                if (((ch) && ((ch ~= 10 or 13 or 32 or 9 or 46 or 44 or 33 or 63 or 45 or 47 or 34 or 58 or 59 or 40 or 41 or 91 or 93 or 123 or 125)))) {
                    (outcome = 1);
                    (ipos)++;
                }
                ;
            NONWORD_RE_CC:
                if ((ch == 10 or 13 or 32 or 9 or 46 or 44 or 33 or 63 or 45 or 47 or 34 or 58 or 59 or 40 or 41 or 91 or 93 or 123 or 125)) {
                    (outcome = 1);
                    (ipos)++;
                }
                ;
            DIGIT_RE_CC:
                if ((ch == 48 or 49 or 50 or 51 or 52 or 53 or 54 or 55 or 56 or 57)) {
                    (outcome = 1);
                    (ipos)++;
                }
                ;
            NONDIGIT_RE_CC:
                if (((ch) && ((ch ~= 48 or 49 or 50 or 51 or 52 or 53 or 54 or 55 or 56 or 57)))) {
                    (outcome = 1);
                    (ipos)++;
                }
                ;
            LCASE_RE_CC:
                if (CharIsOfCase(ch, 0)) {
                    (outcome = 1);
                    (ipos)++;
                }
                ;
            NONLCASE_RE_CC:
                if (((ch) && ((CharIsOfCase(ch, 0) == 0)))) {
                    (outcome = 1);
                    (ipos)++;
                }
                ;
            UCASE_RE_CC:
                if (CharIsOfCase(ch, 1)) {
                    (outcome = 1);
                    (ipos)++;
                }
                ;
            NONUCASE_RE_CC:
                if (((ch) && ((CharIsOfCase(ch, 1) == 0)))) {
                    (outcome = 1);
                    (ipos)++;
                }
                ;
            NEWLINE_RE_CC:
                if ((ch == 10)) {
                    (outcome = 1);
                    (ipos)++;
                }
                ;
            TAB_RE_CC:
                if ((ch == 9)) {
                    (outcome = 1);
                    (ipos)++;
                }
                ;
            RANGE_RE_CC:
                if (TEXT_TY_RE_Range(ch, ftxt, (token-->(RE_PAR1)), (token-->(RE_PAR2)), (token-->(RE_PAR3)), ((mode_flags)&(CIS_MFLAG)))) {
                    (outcome = 1);
                    (ipos)++;
                }
                ;
            LITERAL_RE_CC:
                (rv = TEXT_TY_RE_MatchSubstring(txt, ipos, ftxt, (token-->(RE_PAR1)), (token-->(RE_PAR2)), ((mode_flags)&(CIS_MFLAG))));
                if ((rv >= 0)) {
                    (ipos = (ipos + rv));
                    (outcome = 1);
                }
                ;
            VARIABLE_RE_CC:
                (i = (token-->(RE_PAR1)));
                if ((((RE_Subexpressions-->(i))-->(RE_DATA1)) >= 0)) {
                    (rv = TEXT_TY_RE_MatchSubstring(txt, ipos, txt, ((RE_Subexpressions-->(i))-->(RE_DATA1)), ((RE_Subexpressions-->(i))-->(RE_DATA2)), ((mode_flags)&(CIS_MFLAG))));
                    if ((rv >= 0)) {
                        (ipos = (ipos + rv));
                        (outcome = 1);
                    }
                }
                ;
        }
        if ((outcome == 0)) {
            if (((TEXT_TY_RE_RewindCount)++ >= 10000)) {
                if ((TEXT_TY_RE_RewindCount == 10001)) {
                    style bold;
                    print "OVERFLOW^";
                    style roman;
                }
                return (-(1));
            }
            if (TEXT_TY_RE_Trace) {
                print "Rewind sought from failure at pos ";
                print ipos;
                print " with: ";
                TEXT_TY_RE_DebugNode(token, ftxt, 1);
            }
            if (((((token-->(RE_CCLASS)) == QUANTIFIER_RE_CC)) && (TEXT_TY_RE_SeekBacktrack((token-->(RE_DOWN)), ftxt, 0, ito, 0)))) {
                jump RewindFound;
            }
            if ((((mode_flags)&(ACCUM_MFLAG)) == 0)) {
                TEXT_TY_RE_FailSubexpressions(token);
            }
            (token = (token-->(RE_PREVIOUS)));
            while ((token ~= NULL)) {
                if (TEXT_TY_RE_SeekBacktrack(token, ftxt, 1, ito, 0)) {
                    .RewindFound;
                    (ipos = (token-->(RE_DATA1)));
                    (mode_flags = (token-->(RE_MODES)));
                    if ((((mode_flags)&(ACCUM_MFLAG)) == 0)) {
                        TEXT_TY_RE_FailSubexpressions(token, 1);
                    }
                    if ((ipos == -1)) {
                        TEXT_TY_RE_DebugTree(ftxt, 1);
                    }
                    if (TEXT_TY_RE_Trace) {
                        print "^[";
                        print ifrom;
                        print ",";
                        print ito;
                        print "] rewinding to ";
                        print ipos;
                        print " at ";
                        TEXT_TY_RE_DebugNode(token, ftxt, 1);
                    }
                    jump Rewind;
                }
                (token = (token-->(RE_PREVIOUS)));
            }
            if (TEXT_TY_RE_Trace) {
                print "^Rewind impossible^";
            }
            return (-(1));
        }
        (token = (token-->(RE_NEXT)));
    }
    return (ipos - ifrom);
];
[ TEXT_TY_RE_SeekBacktrack token ftxt downwards ito report_only untried;
    for (:(token ~= NULL):(token = (token-->(RE_NEXT)))) {
        if (((TEXT_TY_RE_Trace) && ((report_only == 0)))) {
            print "Scan for rewind: ";
            TEXT_TY_RE_DebugNode(token, ftxt, 1);
        }
        if (((((token-->(RE_CCLASS)) == SUBEXP_RE_CC)) && (((token-->(RE_PAR2)) == 1 or 2 or 4)))) {
            if (downwards) {
                rfalse;
            }
            continue;
        }
        if (((token-->(RE_DOWN)) ~= NULL)) {
            if (((TEXT_TY_RE_Trace) && ((report_only == 0)))) {
                print "Descend^";
            }
            if (TEXT_TY_RE_SeekBacktrack((token-->(RE_DOWN)), ftxt, 0, ito, report_only)) {
                rtrue;
            }
        }
        (untried = 0);
        switch ((token-->(RE_CCLASS))) {
            DISJUNCTION_RE_CC:
                if (((((((token-->(RE_DATA2)) >= 1)) && (((token-->(RE_DATA2)) < (token-->(RE_PAR1)))))) && (((token-->(RE_CONSTRAINT)) < (token-->(RE_PAR1)))))) {
                    if (report_only) {
                        rtrue;
                    }
                    if (((token-->(RE_CONSTRAINT)) == -1)) {
                        ((token-->(RE_CONSTRAINT)) = 1);
                    } else {
                        ((token-->(RE_CONSTRAINT)))++;
                    }
                    (untried = 1);
                }
                ;
            QUANTIFIER_RE_CC:
                if (((token-->(RE_CONSTRAINT)) ~= -2)) {
                    if (((TEXT_TY_RE_Trace) && ((report_only == 0)))) {
                        print "Quant with cons not -2: ";
                        TEXT_TY_RE_DebugNode(token, ftxt, 1);
                    }
                    if (((token-->(RE_DATA2)) >= 0)) {
                        if (report_only) {
                            rtrue;
                        }
                        ((token-->(RE_CONSTRAINT)) = (token-->(RE_DATA2)));
                        (untried = 1);
                    }
                }
                ;
        }
        if (untried) {
            if (TEXT_TY_RE_Trace) {
                print "Grounds for rewind at: ";
                TEXT_TY_RE_DebugNode(token, ftxt, 1);
            }
            TEXT_TY_RE_EraseConstraints((token-->(RE_NEXT)));
            TEXT_TY_RE_EraseConstraints((token-->(RE_DOWN)));
            rtrue;
        }
        if (downwards) {
            rfalse;
        }
    }
    rfalse;
];
[ TEXT_TY_RE_FailSubexpressions token downwards;
    for (:(token ~= NULL):(token = (token-->(RE_NEXT)))) {
        if (((token-->(RE_DOWN)) ~= NULL)) {
            TEXT_TY_RE_FailSubexpressions((token-->(RE_DOWN)));
        }
        if (((token-->(RE_CCLASS)) == SUBEXP_RE_CC)) {
            ((token-->(RE_DATA1)) = -1);
            ((token-->(RE_DATA2)) = -1);
        }
        if (downwards) {
            break;
        }
    }
];
[ TEXT_TY_RE_EraseConstraints token;
    while ((token ~= NULL)) {
        switch ((token-->(RE_CCLASS))) {
            DISJUNCTION_RE_CC:
                ((token-->(RE_CONSTRAINT)) = -1);
                ;
            QUANTIFIER_RE_CC:
                ((token-->(RE_CONSTRAINT)) = -1);
                ;
        }
        if ((token-->(RE_DOWN))) {
            TEXT_TY_RE_EraseConstraints((token-->(RE_DOWN)));
        }
        (token = (token-->(RE_NEXT)));
    }
];
[ TEXT_TY_RE_MatchSubstring txt ipos mtxt mfrom mto insens i ch;
    if ((mfrom < 0)) {
        rfalse;
    }
    if (insens) {
        for ((i = mfrom):(i < mto):(i)++) {
            (ch = BlkValueRead(mtxt, i));
            if ((BlkValueRead(txt, (ipos)++) ~= ch or TEXT_TY_RevCase(ch))) {
                return (-(1));
            }
        }
    } else {
        for ((i = mfrom):(i < mto):(i)++) {
            if ((BlkValueRead(txt, (ipos)++) ~= BlkValueRead(mtxt, i))) {
                return (-(1));
            }
        }
    }
    return (mto - mfrom);
];
[ TEXT_TY_RE_Range ch ftxt rf rt negate insens i chm upper crev;
    if ((ch == 0)) {
        rfalse;
    }
    if ((negate == 1)) {
        if (TEXT_TY_RE_Range(ch, ftxt, rf, rt, 0, insens)) {
            rfalse;
        }
        rtrue;
    }
    for ((i = rf):(i < rt):(i)++) {
        (chm = BlkValueRead(ftxt, i));
        if ((((chm == 92)) && (((i + 1) < rt)))) {
            (chm = BlkValueRead(ftxt, ++(i)));
            switch (chm) {
                115:
                    if ((ch == 10 or 13 or 32 or 9)) {
                        rtrue;
                    }
                    ;
                83:
                    if (((ch) && ((ch ~= 10 or 13 or 32 or 9)))) {
                        rtrue;
                    }
                    ;
                112:
                    if ((ch == 46 or 44 or 33 or 63 or 45 or 47 or 34 or 58 or 59 or 40 or 41 or 91 or 93 or 123 or 125)) {
                        rtrue;
                    }
                    ;
                80:
                    if (((ch) && ((ch ~= 46 or 44 or 33 or 63 or 45 or 47 or 34 or 58 or 59 or 40 or 41 or 91 or 93 or 123 or 125)))) {
                        rtrue;
                    }
                    ;
                119:
                    if (((ch) && ((ch ~= 10 or 13 or 32 or 9 or 46 or 44 or 33 or 63 or 45 or 47 or 34 or 58 or 59 or 40 or 41 or 91 or 93 or 123 or 125)))) {
                        rtrue;
                    }
                    ;
                87:
                    if ((ch == 10 or 13 or 32 or 9 or 46 or 44 or 33 or 63 or 45 or 47 or 34 or 58 or 59 or 40 or 41 or 91 or 93 or 123 or 125)) {
                        rtrue;
                    }
                    ;
                100:
                    if ((ch == 48 or 49 or 50 or 51 or 52 or 53 or 54 or 55 or 56 or 57)) {
                        rtrue;
                    }
                    ;
                68:
                    if (((ch) && ((ch ~= 48 or 49 or 50 or 51 or 52 or 53 or 54 or 55 or 56 or 57)))) {
                        rtrue;
                    }
                    ;
                108:
                    if (CharIsOfCase(ch, 0)) {
                        rtrue;
                    }
                    ;
                76:
                    if ((CharIsOfCase(ch, 0) == 0)) {
                        rtrue;
                    }
                    ;
                117:
                    if (CharIsOfCase(ch, 1)) {
                        rtrue;
                    }
                    ;
                85:
                    if ((CharIsOfCase(ch, 1) == 0)) {
                        rtrue;
                    }
                    ;
                110:
                    if ((ch == 10)) {
                        rtrue;
                    }
                    ;
                116:
                    if ((ch == 9)) {
                        rtrue;
                    }
                    ;
            }
        } else {
            if (((((i + 2) < rt)) && ((BlkValueRead(ftxt, (i + 1)) == 45)))) {
                (upper = BlkValueRead(ftxt, (i + 2)));
                if ((((ch >= chm)) && ((ch <= upper)))) {
                    rtrue;
                }
                if (insens) {
                    (crev = TEXT_TY_RevCase(ch));
                    if ((((crev >= chm)) && ((crev <= upper)))) {
                        rtrue;
                    }
                }
                (i = (i + 2));
            } else {
                if ((chm == ch)) {
                    rtrue;
                }
                if (((insens) && ((chm == TEXT_TY_RevCase(ch))))) {
                    rtrue;
                }
            }
        }
    }
    rfalse;
];
[ TEXT_TY_Replace_RE ftxtype txt ftxt rtxt insens exactly r p p1 p2 cp cp1 cp2;
    if ((rtxt == 0 or 1)) {
        (cp = (txt-->(0)));
        (p = TEXT_TY_Temporarily_Transmute(txt));
    } else {
        TEXT_TY_Transmute(txt);
    }
    (cp1 = (ftxt-->(0)));
    (p1 = TEXT_TY_Temporarily_Transmute(ftxt));
    (cp2 = (rtxt-->(0)));
    (p2 = TEXT_TY_Temporarily_Transmute(rtxt));
    (r = TEXT_TY_Replace_REI(ftxtype, txt, ftxt, rtxt, insens, exactly));
    TEXT_TY_Untransmute(ftxt, p1, cp1);
    TEXT_TY_Untransmute(rtxt, p2, cp2);
    if ((rtxt == 0 or 1)) {
        TEXT_TY_Untransmute(txt, p, cp);
    }
    return r;
];
[ TEXT_TY_Replace_REI ftxtype txt ftxt rtxt insens exactly ctxt csize ilen i cl mpos cpos ch chm;
    (ilen = TEXT_TY_CharacterLength(txt));
    (TEXT_TY_RE_Err = 0);
    switch (ftxtype) {
        REGEXP_BLOB:
            (i = TEXT_TY_RE_CompileTree(ftxt, exactly));
            ;
        CHR_BLOB:
            (i = TEXT_TY_CHR_CompileTree(ftxt, exactly));
            ;
        default:
            print "*** bad ftxtype ***";
            new_line;
            rtrue;
            ;
    }
    if ((((i < 0)) || ((i > RE_MAX_PACKETS)))) {
        (TEXT_TY_RE_Err = i);
        print "*** Regular expression error: ";
        print (string) TEXT_TY_RE_Err;
        print " ***^";
        RunTimeProblem(RTP_REGEXPSYNTAXERROR);
        rfalse;
    }
    if (TEXT_TY_RE_Trace) {
        TEXT_TY_RE_DebugTree(ftxt);
        print "(compiled to ";
        print i;
        print " packets)^";
    }
    if ((ftxtype == REGEXP_BLOB)) {
        TEXT_TY_RE_EmptyMatchVars();
    }
    (mpos = 0);
    (chm = 0);
    (cpos = 0);
    while ((TEXT_TY_RE_Parse(ftxt, txt, mpos, insens) >= 0)) {
        (chm)++;
        if (TEXT_TY_RE_Trace) {
            print "^*** Match ";
            print chm;
            print " found (";
            print (RE_PACKET_space-->(RE_DATA1));
            print ",";
            print (RE_PACKET_space-->(RE_DATA2));
            print "): ";
            if (((RE_PACKET_space-->(RE_DATA1)) == (RE_PACKET_space-->(RE_DATA2)))) {
                print "<empty>";
            }
            for ((i = (RE_PACKET_space-->(RE_DATA1))):(i < (RE_PACKET_space-->(RE_DATA2))):(i)++) {
                print (char) BlkValueRead(txt, i);
            }
            print " ***^";
        }
        if ((rtxt == 0)) {
            break;
        }
        if ((rtxt ~= 0 or 1)) {
            if ((chm == 1)) {
                (ctxt = BlkValueCreate(TEXT_TY));
                TEXT_TY_Transmute(ctxt);
                (csize = BlkValueLBCapacity(ctxt));
            }
            for ((i = cpos):(i < (RE_PACKET_space-->(RE_DATA1))):(i)++) {
                (ch = BlkValueRead(txt, i));
                if (((cl + 1) >= csize)) {
                    if ((BlkValueSetLBCapacity(ctxt, (2*cl)) == 0)) {
                        break;
                    }
                    (csize = BlkValueLBCapacity(ctxt));
                }
                BlkValueWrite(ctxt, (cl)++, ch);
            }
            BlkValueWrite(ctxt, cl, 0);
            TEXT_TY_Concatenate(ctxt, rtxt, ftxtype, txt);
            (csize = BlkValueLBCapacity(ctxt));
            (cl = TEXT_TY_CharacterLength(ctxt));
        }
        (mpos = (RE_PACKET_space-->(RE_DATA2)));
        (cpos = mpos);
        if (((RE_PACKET_space-->(RE_DATA1)) == (RE_PACKET_space-->(RE_DATA2)))) {
            (mpos)++;
        }
        if (TEXT_TY_RE_Trace) {
            if ((chm == 100)) {
                print "(Stopping after 100 matches.)^";
                break;
            }
        }
    }
    if ((chm > 0)) {
        if ((rtxt ~= 0 or 1)) {
            for ((i = cpos):(i < ilen):(i)++) {
                (ch = BlkValueRead(txt, i));
                if (((cl + 1) >= csize)) {
                    if ((BlkValueSetLBCapacity(ctxt, (2*cl)) == 0)) {
                        break;
                    }
                    (csize = BlkValueLBCapacity(ctxt));
                }
                BlkValueWrite(ctxt, (cl)++, ch);
            }
        }
        if ((ftxtype == REGEXP_BLOB)) {
            TEXT_TY_RE_CreateMatchVars(txt);
            if (TEXT_TY_RE_Trace) {
                TEXT_TY_RE_DebugMatchVars(txt);
            }
        }
        if ((rtxt ~= 0 or 1)) {
            BlkValueWrite(ctxt, cl, 0);
            BlkValueCopy(txt, ctxt);
            BlkValueFree(ctxt);
        }
    }
    return chm;
];
[ TEXT_TY_RE_Concatenate txt_to txt_from blobtype txt_ref pos len ch i tosize x y case;
    if ((((txt_to == 0)) || ((BlkValueWeakKind(txt_to) ~= TEXT_TY)))) {
        rfalse;
    }
    if ((((txt_from == 0)) || ((BlkValueWeakKind(txt_from) ~= TEXT_TY)))) {
        return txt_to;
    }
    (pos = TEXT_TY_CharacterLength(txt_to));
    (tosize = BlkValueLBCapacity(txt_to));
    (len = TEXT_TY_CharacterLength(txt_from));
    for ((i = 0):(i < len):(i)++) {
        (ch = BlkValueRead(txt_from, i));
        if ((((ch == 92)) && ((i < (len - 1))))) {
            (ch = BlkValueRead(txt_from, ++(i)));
            if ((ch == 110)) {
                (ch = 10);
            }
            if ((ch == 116)) {
                (ch = 9);
            }
            (case = -1);
            if ((ch == 108)) {
                (case = 0);
            }
            if ((ch == 117)) {
                (case = 1);
            }
            if ((case >= 0)) {
                (ch = BlkValueRead(txt_from, ++(i)));
            }
            if ((((ch >= 48)) && ((ch <= 57)))) {
                (ch = (ch - 48));
                if ((ch < (RE_Subexpressions-->(10)))) {
                    (x = ((RE_Subexpressions-->(ch))-->(RE_DATA1)));
                    (y = ((RE_Subexpressions-->(ch))-->(RE_DATA2)));
                    if ((x >= 0)) {
                        for (:(x < y):(x)++) {
                            (ch = BlkValueRead(txt_ref, x));
                            if (((pos + 1) >= tosize)) {
                                if ((BlkValueSetLBCapacity(txt_to, (2*tosize)) == 0)) {
                                    break;
                                }
                                (tosize = BlkValueLBCapacity(txt_to));
                            }
                            if ((case >= 0)) {
                                BlkValueWrite(txt_to, (pos)++, CharToCase(ch, case));
                            } else {
                                BlkValueWrite(txt_to, (pos)++, ch);
                            }
                        }
                    }
                }
                continue;
            }
        }
        if (((pos + 1) >= tosize)) {
            if ((BlkValueSetLBCapacity(txt_to, (2*tosize)) == 0)) {
                break;
            }
            (tosize = BlkValueLBCapacity(txt_to));
        }
        BlkValueWrite(txt_to, (pos)++, ch);
    }
    BlkValueWrite(txt_to, pos, 0);
    return txt_to;
];
[ LIST_OF_TY_Support task arg1 arg2 arg3;
    switch (task) {
        CREATE_KOVS:
            return LIST_OF_TY_Create(arg1, arg2);
            ;
        DESTROY_KOVS:
            LIST_OF_TY_Destroy(arg1);
            ;
        MAKEMUTABLE_KOVS:
            rtrue;
            ;
        COPYKIND_KOVS:
            return LIST_OF_TY_CopyKind(arg1, arg2);
            ;
        COPYQUICK_KOVS:
            return LIST_OF_TY_QuickCopy(arg1, arg2);
            ;
        COPYSB_KOVS:
            BlkValueCopySB1(arg1, arg2);
            ;
        KINDDATA_KOVS:
            return LIST_OF_TY_KindData(arg1, arg2);
            ;
        EXTENT_KOVS:
            return (BlkValueRead(arg1, LIST_LENGTH_F) + LIST_ITEM_BASE);
            ;
        COPY_KOVS:
            LIST_OF_TY_Copy(arg1, arg2, arg3);
            ;
        COMPARE_KOVS:
            return LIST_OF_TY_Compare(arg1, arg2);
            ;
        HASH_KOVS:
            return LIST_OF_TY_Hash(arg1);
            ;
        DEBUG_KOVS:
            print " = {";
            LIST_OF_TY_Say(arg1);
            print "} of kind ";
            print BlkValueRead(arg1, LIST_ITEM_KOV_F);
            ;
    }
    rfalse;
];
[ LIST_OF_TY_Create skov sb list;
    (skov = KindBaseTerm(skov, 0));
    (list = FlexAllocate((27*WORDSIZE), LIST_OF_TY, (BLK_FLAG_MULTIPLE + BLK_FLAG_WORD)));
    BlkValueWrite(list, LIST_ITEM_KOV_F, skov, 1);
    BlkValueWrite(list, LIST_LENGTH_F, 0, 1);
    (sb = BlkValueCreateSB1(sb, list));
    return sb;
];
[ LIST_OF_TY_Destroy list no_items i k;
    (k = BlkValueRead(list, LIST_ITEM_KOV_F));
    if (KOVIsBlockValue(k)) {
        (no_items = BlkValueRead(list, LIST_LENGTH_F));
        for ((i = 0):(i < no_items):(i)++) {
            BlkValueFree(BlkValueRead(list, (i + LIST_ITEM_BASE)));
        }
    }
];
[ LIST_OF_TY_CopyKind to from;
    BlkValueWrite(to, LIST_ITEM_KOV_F, BlkValueRead(from, LIST_ITEM_KOV_F));
];
[ LIST_OF_TY_QuickCopy to from;
    if ((BlkValueRead(to, LIST_ITEM_KOV_F) ~= BlkValueRead(from, LIST_ITEM_KOV_F))) {
        rfalse;
    }
    rtrue;
];
[ LIST_OF_TY_KindData list dummy;
    return BlkValueRead(list, LIST_ITEM_KOV_F);
];
[ LIST_OF_TY_Copy lto lfrom precopied_list_kov no_items i nv bk val splk;
    (no_items = BlkValueRead(lfrom, LIST_LENGTH_F));
    (bk = BlkValueRead(lfrom, LIST_ITEM_KOV_F));
    if ((precopied_list_kov ~= 0 or UNKNOWN_TY)) {
        BlkValueWrite(lto, LIST_ITEM_KOV_F, precopied_list_kov);
    } else {
        BlkValueWrite(lto, LIST_ITEM_KOV_F, bk);
    }
    if (KOVIsBlockValue(bk)) {
        for ((i = 0):(i < no_items):(i)++) {
            (val = BlkValueRead(lfrom, (i + LIST_ITEM_BASE)));
            if ((precopied_list_kov ~= 0 or UNKNOWN_TY)) {
                (nv = BlkValueCreate(precopied_list_kov));
            } else {
                (nv = BlkValueCreate(bk));
            }
            BlkValueCopy(nv, val);
            BlkValueWrite(lto, (i + LIST_ITEM_BASE), nv);
        }
    }
];
[ LIST_OF_TY_Compare listleft listright delta no_items i cf;
    (delta = (BlkValueRead(listleft, LIST_LENGTH_F) - BlkValueRead(listright, LIST_LENGTH_F)));
    if (delta) {
        return delta;
    }
    (no_items = BlkValueRead(listleft, LIST_LENGTH_F));
    if ((no_items == 0)) {
        rfalse;
    }
    (delta = (BlkValueRead(listleft, LIST_ITEM_KOV_F) - BlkValueRead(listright, LIST_ITEM_KOV_F)));
    if (delta) {
        return delta;
    }
    (cf = LIST_OF_TY_ComparisonFn(listleft));
    if ((cf == 0 or UnsignedCompare)) {
        for ((i = 0):(i < no_items):(i)++) {
            (delta = (BlkValueRead(listleft, (i + LIST_ITEM_BASE)) - BlkValueRead(listright, (i + LIST_ITEM_BASE))));
            if (delta) {
                return delta;
            }
        }
    } else {
        for ((i = 0):(i < no_items):(i)++) {
            (delta = (cf)(BlkValueRead(listleft, (i + LIST_ITEM_BASE)),BlkValueRead(listright, (i + LIST_ITEM_BASE))));
            if (delta) {
                return delta;
            }
        }
    }
    rfalse;
];
[ LIST_OF_TY_ComparisonFn list;
    if ((((list == 0)) || ((BlkValueWeakKind(list) ~= LIST_OF_TY)))) {
        rfalse;
    }
    return KOVComparisonFunction(BlkValueRead(list, LIST_ITEM_KOV_F));
];
[ LIST_OF_TY_Distinguish txb1 txb2;
    if ((LIST_OF_TY_Compare(txb1, txb2) == 0)) {
        rfalse;
    }
    rtrue;
];
[ LIST_OF_TY_Hash list len kov rv i;
    (rv = 0);
    (len = BlkValueRead(list, LIST_LENGTH_F));
    (kov = BlkValueRead(list, LIST_ITEM_KOV_F));
    for ((i = 0):(i < len):(i)++) {
        (rv = ((rv*33) + GetHashValue(kov, BlkValueRead(list, (i + LIST_ITEM_BASE)))));
    }
    return rv;
];
[ LIST_OF_TY_Say list format no_items v i bk;
    if ((((list == 0)) || ((BlkValueWeakKind(list) ~= LIST_OF_TY)))) {
        rtrue;
    }
    (no_items = BlkValueRead(list, LIST_LENGTH_F));
    (bk = KindAtomic(BlkValueRead(list, LIST_ITEM_KOV_F)));
    if ((format == 1)) {
        print "{";
    }
    for ((i = 0):(i < no_items):(i)++) {
        (v = BlkValueRead(list, (i + LIST_ITEM_BASE)));
        switch (format) {
            2:
                DefArt(v);
                ;
            3:
                IndefArt(v);
                ;
            default:
                if ((bk == LIST_OF_TY)) {
                    LIST_OF_TY_Say(v, 1);
                } else {
                    if ((((bk == TEXT_TY)) && ((format == 1)))) {
                        print "~";
                        PrintKindValuePair(bk, v);
                        print "~";
                    } else {
                        PrintKindValuePair(bk, v);
                    }
                }
                ;
        }
        if ((i < (no_items - 2))) {
            print ", ";
        }
        if ((i == (no_items - 2))) {
            if ((format == 1)) {
                print ", ";
            } else {
                if (((KIT_CONFIGURATION_BITMAP)&(SERIAL_COMMA_TCBIT))) {
                    if ((no_items ~= 2)) {
                        print ",";
                    }
                }
                LIST_WRITER_INTERNAL_RM(67);
            }
        }
    }
    if ((format == 1)) {
        print "}";
    }
    (prior_named_list = no_items);
    (prior_named_list_gender = -1);
];
[ LIST_OF_TY_Desc list desc kov obj no_items ex len i;
    if ((((list == 0)) || ((BlkValueWeakKind(list) ~= LIST_OF_TY)))) {
        rfalse;
    }
    (ex = BlkValueLBCapacity(list));
    (len = (desc)(-3));
    if (((len + LIST_ITEM_BASE) > ex)) {
        if ((BlkValueSetLBCapacity(list, (len + LIST_ITEM_BASE)) == 0)) {
            rfalse;
        }
    }
    if (kov) {
        BlkValueWrite(list, LIST_ITEM_KOV_F, kov);
    } else {
        BlkValueWrite(list, LIST_ITEM_KOV_F, OBJECT_TY);
    }
    BlkValueWrite(list, LIST_LENGTH_F, len);
    (obj = 0);
    for ((i = 0):(i < len):(i)++) {
        (obj = (desc)(-2,obj,i));
        BlkValueWrite(list, (i + LIST_ITEM_BASE), obj);
    }
    return list;
];
[ LIST_OF_TY_FindItem list v i no_items cf;
    if ((((list == 0)) || ((BlkValueWeakKind(list) ~= LIST_OF_TY)))) {
        rfalse;
    }
    (cf = LIST_OF_TY_ComparisonFn(list));
    (no_items = BlkValueRead(list, LIST_LENGTH_F));
    if ((cf == 0 or UnsignedCompare)) {
        for ((i = 0):(i < no_items):(i)++) {
            if ((v == BlkValueRead(list, (i + LIST_ITEM_BASE)))) {
                rtrue;
            }
        }
    } else {
        for ((i = 0):(i < no_items):(i)++) {
            if (((cf)(v,BlkValueRead(list, (i + LIST_ITEM_BASE))) == 0)) {
                rtrue;
            }
        }
    }
    rfalse;
];
[ LIST_OF_TY_InsertItem list v posnflag posn nodups i no_items ex nv contents_kind;
    if ((((list == 0)) || ((BlkValueWeakKind(list) ~= LIST_OF_TY)))) {
        rfalse;
    }
    if (((nodups) && (LIST_OF_TY_FindItem(list, v)))) {
        return list;
    }
    (no_items = BlkValueRead(list, LIST_LENGTH_F));
    BlkValueWrite(list, LIST_LENGTH_F, no_items);
    (contents_kind = BlkValueRead(list, LIST_ITEM_KOV_F));
    if (((posnflag) && ((((posn < 1)) || ((posn > (no_items + 1))))))) {
        print "*** Couldn't add at entry ";
        print posn;
        print " in the list ";
        LIST_OF_TY_Say(list, 1);
        print ", which has entries in the range 1 to ";
        print no_items;
        print " ***^";
        RunTimeProblem(RTP_LISTRANGEERROR);
        rfalse;
    }
    (ex = BlkValueLBCapacity(list));
    if ((((no_items + LIST_ITEM_BASE) + 1) > ex)) {
        if ((BlkValueSetLBCapacity(list, (ex + 16)) == 0)) {
            rfalse;
        }
    }
    if (KOVIsBlockValue(contents_kind)) {
        (nv = BlkValueCreate(contents_kind));
        BlkValueCopy(nv, v);
        (v = nv);
    }
    if (posnflag) {
        (posn)--;
        for ((i = no_items):(i > posn):(i)--) {
            BlkValueWrite(list, (i + LIST_ITEM_BASE), BlkValueRead(list, ((i - 1) + LIST_ITEM_BASE)));
        }
        BlkValueWrite(list, (posn + LIST_ITEM_BASE), v);
    } else {
        BlkValueWrite(list, (no_items + LIST_ITEM_BASE), v);
    }
    BlkValueWrite(list, LIST_LENGTH_F, (no_items + 1));
    return list;
];
[ LIST_OF_TY_AppendList list more posnflag posn nodups v i j no_items msize ex nv;
    if ((((list == 0)) || ((BlkValueWeakKind(list) ~= LIST_OF_TY)))) {
        rfalse;
    }
    if ((((more == 0)) || ((BlkValueWeakKind(more) ~= LIST_OF_TY)))) {
        return list;
    }
    (no_items = BlkValueRead(list, LIST_LENGTH_F));
    BlkValueWrite(list, LIST_LENGTH_F, no_items);
    if (((posnflag) && ((((posn < 1)) || ((posn > (no_items + 1))))))) {
        print "*** Couldn't add at entry ";
        print posn;
        print " in the list ";
        LIST_OF_TY_Say(list, 1);
        print ", which has entries in the range 1 to ";
        print no_items;
        print " ***^";
        RunTimeProblem(RTP_LISTRANGEERROR);
        rfalse;
    }
    (msize = BlkValueRead(more, LIST_LENGTH_F));
    (ex = BlkValueLBCapacity(list));
    if ((((no_items + msize) + LIST_ITEM_BASE) > ex)) {
        if ((BlkValueSetLBCapacity(list, (((no_items + msize) + LIST_ITEM_BASE) + 8)) == 0)) {
            rfalse;
        }
    }
    if (posnflag) {
        (posn)--;
        for ((i = (no_items + msize)):(i >= (posn + msize)):(i)--) {
            BlkValueWrite(list, (i + LIST_ITEM_BASE), BlkValueRead(list, ((i - msize) + LIST_ITEM_BASE)));
        }
        for ((j = 0):(j < msize):(j)++) {
            (v = BlkValueRead(more, (j + LIST_ITEM_BASE)));
            if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F))) {
                (nv = BlkValueCreate(BlkValueRead(list, LIST_ITEM_KOV_F)));
                BlkValueCopy(nv, v);
                (v = nv);
            }
            BlkValueWrite(list, ((posn + j) + LIST_ITEM_BASE), v);
        }
    } else {
        for (((i = 0),(j = 0)):(i < msize):(i)++) {
            (v = BlkValueRead(more, (i + LIST_ITEM_BASE)));
            if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F))) {
                (nv = BlkValueCreate(BlkValueRead(list, LIST_ITEM_KOV_F)));
                BlkValueCopy(nv, v);
                (v = nv);
            }
            if ((((nodups == 0)) || ((LIST_OF_TY_FindItem(list, v) == 0)))) {
                BlkValueWrite(list, ((no_items + j) + LIST_ITEM_BASE), v);
                (j)++;
            }
        }
    }
    BlkValueWrite(list, LIST_LENGTH_F, (no_items + j));
    return list;
];
[ LIST_OF_TY_RemoveValue list v forgive i j no_items odsize f cf delendum;
    if ((((list == 0)) || ((BlkValueWeakKind(list) ~= LIST_OF_TY)))) {
        rfalse;
    }
    (cf = LIST_OF_TY_ComparisonFn(list));
    (no_items = BlkValueRead(list, LIST_LENGTH_F));
    (odsize = no_items);
    BlkValueWrite(list, LIST_LENGTH_F, no_items);
    for ((i = 0):(i < no_items):(i)++) {
        (delendum = BlkValueRead(list, (i + LIST_ITEM_BASE)));
        if ((cf == 0 or UnsignedCompare)) {
            (f = (v == delendum));
        } else {
            (f = ((cf)(v,delendum) == 0));
        }
        if (f) {
            if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F))) {
                BlkValueFree(delendum);
            }
            for ((j = (i + 1)):(j < no_items):(j)++) {
                BlkValueWrite(list, ((j - 1) + LIST_ITEM_BASE), BlkValueRead(list, (j + LIST_ITEM_BASE)));
            }
            (no_items)--;
            (i)--;
            BlkValueWrite(list, LIST_LENGTH_F, no_items);
        }
    }
    if ((odsize ~= no_items)) {
        rfalse;
    }
    if (forgive) {
        rfalse;
    }
    print "*** Couldn't remove: the value ";
    PrintKindValuePair(BlkValueRead(list, LIST_ITEM_KOV_F), v);
    print " was not present in the list ";
    LIST_OF_TY_Say(list, 1);
    print " ***^";
    RunTimeProblem(RTP_LISTRANGEERROR);
];
[ LIST_OF_TY_RemoveItemRange list from to forgive i d no_items;
    if ((((list == 0)) || ((BlkValueWeakKind(list) ~= LIST_OF_TY)))) {
        rfalse;
    }
    (no_items = BlkValueRead(list, LIST_LENGTH_F));
    if ((((((from > to)) || ((from <= 0)))) || ((to > no_items)))) {
        if (forgive) {
            if ((from <= 0)) {
                (from = 1);
            }
            if ((to >= no_items)) {
                (to = no_items);
            }
            if ((from > to)) {
                return list;
            }
        } else {
            print "*** Couldn't remove entries ";
            print from;
            print " to ";
            print to;
            print " from the list ";
            LIST_OF_TY_Say(list, 1);
            print ", which has entries in the range 1 to ";
            print no_items;
            print " ***^";
            RunTimeProblem(RTP_LISTRANGEERROR);
            rfalse;
        }
    }
    (to)--;
    (from)--;
    (d = ((to - from) + 1));
    if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F))) {
        for ((i = 0):(i < d):(i)++) {
            BlkValueFree(BlkValueRead(list, ((from + i) + LIST_ITEM_BASE)));
        }
    }
    for ((i = from):(i < (no_items - d)):(i)++) {
        BlkValueWrite(list, (i + LIST_ITEM_BASE), BlkValueRead(list, ((i + d) + LIST_ITEM_BASE)));
    }
    BlkValueWrite(list, LIST_LENGTH_F, (no_items - d));
    return list;
];
[ LIST_OF_TY_Remove_List list rlist i j k v w no_items odsize rsize cf f;
    if ((((list == 0)) || ((BlkValueWeakKind(list) ~= LIST_OF_TY)))) {
        rfalse;
    }
    (no_items = BlkValueRead(list, LIST_LENGTH_F));
    (odsize = no_items);
    (rsize = BlkValueRead(rlist, LIST_LENGTH_F));
    (cf = LIST_OF_TY_ComparisonFn(list));
    for ((i = 0):(i < no_items):(i)++) {
        (v = BlkValueRead(list, (i + LIST_ITEM_BASE)));
        for ((k = 0):(k < rsize):(k)++) {
            (w = BlkValueRead(rlist, (k + LIST_ITEM_BASE)));
            if ((cf == 0 or UnsignedCompare)) {
                (f = (v == w));
            } else {
                (f = ((cf)(v,w) == 0));
            }
            if (f) {
                if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F))) {
                    BlkValueFree(v);
                }
                for ((j = (i + 1)):(j < no_items):(j)++) {
                    BlkValueWrite(list, ((j + LIST_ITEM_BASE) - 1), BlkValueRead(list, (j + LIST_ITEM_BASE)));
                }
                (no_items)--;
                (i)--;
                BlkValueWrite(list, LIST_LENGTH_F, no_items);
                break;
            }
        }
    }
    rfalse;
];
[ LIST_OF_TY_GetLength list;
    if ((((list == 0)) || ((BlkValueWeakKind(list) ~= LIST_OF_TY)))) {
        rfalse;
    }
    return BlkValueRead(list, LIST_LENGTH_F);
];
[ LIST_OF_TY_Empty list;
    if ((((list == 0)) || ((BlkValueWeakKind(list) ~= LIST_OF_TY)))) {
        rfalse;
    }
    if ((BlkValueRead(list, LIST_LENGTH_F) == 0)) {
        rtrue;
    }
    rfalse;
];
[ LIST_OF_TY_SetLength list newsize this_way_only truncation_end no_items ex i dv;
    if ((((list == 0)) || ((BlkValueWeakKind(list) ~= LIST_OF_TY)))) {
        rfalse;
    }
    if ((newsize < 0)) {
        return RunTimeProblem(RTP_LISTSIZENEGATIVE, newsize);
    }
    BlkMakeMutable(list);
    (no_items = BlkValueRead(list, LIST_LENGTH_F));
    if ((no_items < newsize)) {
        if ((this_way_only == -1)) {
            return list;
        }
        (ex = BlkValueLBCapacity(list));
        if (((newsize + LIST_ITEM_BASE) > ex)) {
            if ((BlkValueSetLBCapacity(list, (newsize + LIST_ITEM_BASE)) == 0)) {
                rfalse;
            }
        }
        (dv = DefaultValueOfKOV(BlkValueRead(list, LIST_ITEM_KOV_F)));
        for ((i = no_items):(i < newsize):(i)++) {
            BlkValueWrite(list, (LIST_ITEM_BASE + i), dv);
        }
        BlkValueWrite(list, LIST_LENGTH_F, newsize);
    }
    if ((no_items > newsize)) {
        if ((this_way_only == 1)) {
            return list;
        }
        if ((truncation_end == -1)) {
            if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F))) {
                for ((i = 0):(i < (no_items - newsize)):(i)++) {
                    BlkValueFree(BlkValueRead(list, (LIST_ITEM_BASE + i)));
                }
            }
            for ((i = 0):(i < newsize):(i)++) {
                BlkValueWrite(list, (LIST_ITEM_BASE + i), BlkValueRead(list, (((LIST_ITEM_BASE + no_items) - newsize) + i)));
            }
        } else {
            if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F))) {
                for ((i = newsize):(i < no_items):(i)++) {
                    BlkValueFree(BlkValueRead(list, (LIST_ITEM_BASE + i)));
                }
            }
        }
        BlkValueWrite(list, LIST_LENGTH_F, newsize);
    }
    return list;
];
[ LIST_OF_TY_GetItem list i forgive no_items;
    if ((((list == 0)) || ((BlkValueWeakKind(list) ~= LIST_OF_TY)))) {
        rfalse;
    }
    (no_items = BlkValueRead(list, LIST_LENGTH_F));
    if ((((i <= 0)) || ((i > no_items)))) {
        if (forgive) {
            rfalse;
        }
        print "*** Couldn't read from entry ";
        print i;
        print " of a list which";
        switch (no_items) {
            0:
                print " is empty ***^";
                ;
            1:
                print " has only one entry, numbered 1 ***^";
                ;
            default:
                print " has entries numbered from 1 to ";
                print no_items;
                print " ***^";
                ;
        }
        RunTimeProblem(RTP_LISTRANGEERROR);
        if ((no_items >= 1)) {
            (i = 1);
        } else {
            rfalse;
        }
    }
    return BlkValueRead(list, ((LIST_ITEM_BASE + i) - 1));
];
[ WriteLIST_OF_TY_GetItem list i val no_items;
    if ((((list == 0)) || ((BlkValueWeakKind(list) ~= LIST_OF_TY)))) {
        rfalse;
    }
    (no_items = BlkValueRead(list, LIST_LENGTH_F));
    if ((((i <= 0)) || ((i > no_items)))) {
        print "*** Couldn't write to list entry ";
        print i;
        print " of a list which";
        switch (no_items) {
            0:
                print " is empty ***^";
                ;
            1:
                print " has only one entry, numbered 1 ***^";
                ;
            default:
                print " has entries numbered from 1 to ";
                print no_items;
                print " ***^";
                ;
        }
        return RunTimeProblem(RTP_LISTRANGEERROR);
    }
    BlkValueWrite(list, ((LIST_ITEM_BASE + i) - 1), val);
];
[ LIST_OF_TY_PutItem list i v no_items nv;
    if ((((list == 0)) || ((BlkValueWeakKind(list) ~= LIST_OF_TY)))) {
        rfalse;
    }
    (no_items = BlkValueRead(list, LIST_LENGTH_F));
    if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F))) {
        (nv = BlkValueCreate(BlkValueRead(list, LIST_ITEM_KOV_F)));
        BlkValueCopy(nv, v);
        (v = nv);
    }
    if ((((i <= 0)) || ((i > no_items)))) {
        rfalse;
    }
    BlkValueWrite(list, ((LIST_ITEM_BASE + i) - 1), v);
];
[ LIST_OF_TY_Reverse list no_items i v;
    if ((((list == 0)) || ((BlkValueWeakKind(list) ~= LIST_OF_TY)))) {
        rfalse;
    }
    (no_items = BlkValueRead(list, LIST_LENGTH_F));
    if ((no_items < 2)) {
        return list;
    }
    for ((i = 0):((i*2) < no_items):(i)++) {
        (v = BlkValueRead(list, (LIST_ITEM_BASE + i)));
        BlkValueWrite(list, (LIST_ITEM_BASE + i), BlkValueRead(list, (((LIST_ITEM_BASE + no_items) - 1) - i)));
        BlkValueWrite(list, (((LIST_ITEM_BASE + no_items) - 1) - i), v);
    }
    return list;
];
[ LIST_OF_TY_Rotate list backwards no_items i v;
    if ((((list == 0)) || ((BlkValueWeakKind(list) ~= LIST_OF_TY)))) {
        rfalse;
    }
    (no_items = BlkValueRead(list, LIST_LENGTH_F));
    if ((no_items < 2)) {
        return list;
    }
    if (backwards) {
        (v = BlkValueRead(list, LIST_ITEM_BASE));
        for ((i = 0):(i < (no_items - 1)):(i)++) {
            BlkValueWrite(list, (LIST_ITEM_BASE + i), BlkValueRead(list, ((LIST_ITEM_BASE + i) + 1)));
        }
        BlkValueWrite(list, ((no_items - 1) + LIST_ITEM_BASE), v);
    } else {
        (v = BlkValueRead(list, ((no_items - 1) + LIST_ITEM_BASE)));
        for ((i = (no_items - 1)):(i > 0):(i)--) {
            BlkValueWrite(list, (LIST_ITEM_BASE + i), BlkValueRead(list, ((LIST_ITEM_BASE + i) - 1)));
        }
        BlkValueWrite(list, LIST_ITEM_BASE, v);
    }
    return list;
];
[ LIST_OF_TY_Sort list dir prop cf i j no_items v;
    BlkMakeMutable(list);
    (no_items = BlkValueRead(list, LIST_LENGTH_F));
    if ((dir == 2)) {
        if ((no_items < 2)) {
            rtrue;
        }
        for ((i = 1):(i < no_items):(i)++) {
            (j = (random((i + 1)) - 1));
            (v = BlkValueRead(list, (LIST_ITEM_BASE + i)));
            BlkValueWrite(list, (LIST_ITEM_BASE + i), BlkValueRead(list, (LIST_ITEM_BASE + j)));
            BlkValueWrite(list, (LIST_ITEM_BASE + j), v);
        }
        rtrue;
    }
    SetSortDomain(ListSwapEntries, ListCompareEntries);
    if (cf) {
        (LIST_OF_TY_Sort_cf = BlkValueCompare);
    } else {
        (LIST_OF_TY_Sort_cf = 0);
    }
    SortArray(list, prop, dir, no_items, 0);
];
[ ListSwapEntries list i j v;
    if ((i == j)) {
        rtrue;
    }
    (v = BlkValueRead(list, ((LIST_ITEM_BASE + i) - 1)));
    BlkValueWrite(list, ((LIST_ITEM_BASE + i) - 1), BlkValueRead(list, ((LIST_ITEM_BASE + j) - 1)));
    BlkValueWrite(list, ((LIST_ITEM_BASE + j) - 1), v);
];
[ ListCompareEntries list col i j d cf;
    if ((i == j)) {
        rfalse;
    }
    (i = BlkValueRead(list, ((LIST_ITEM_BASE + i) - 1)));
    (j = BlkValueRead(list, ((LIST_ITEM_BASE + j) - 1)));
    if (I7S_Col) {
        if ((_final_propertyexists(OBJECT_TY, i, I7S_Col))) {
            (i = _final_propertyvalue(OBJECT_TY, i, I7S_Col));
        } else {
            (i = 0);
        }
        if ((_final_propertyexists(OBJECT_TY, j, I7S_Col))) {
            (j = _final_propertyvalue(OBJECT_TY, j, I7S_Col));
        } else {
            (j = 0);
        }
        (cf = LIST_OF_TY_Sort_cf);
    } else {
        (cf = LIST_OF_TY_ComparisonFn(list));
    }
    if ((cf == 0)) {
        if ((i > j)) {
            rtrue;
        }
        if ((i < j)) {
            return (-(1));
        }
        rfalse;
    } else {
        return (cf)(i,j);
    }
];
[ COMBINATION_TY_Support task arg1 arg2 arg3;
    switch (task) {
        CREATE_KOVS:
            return COMBINATION_TY_Create(arg1, arg2);
            ;
        DESTROY_KOVS:
            COMBINATION_TY_Destroy(arg1);
            ;
        MAKEMUTABLE_KOVS:
            rtrue;
            ;
        COPYKIND_KOVS:
            return COMBINATION_TY_CopyKind(arg1, arg2);
            ;
        COPYQUICK_KOVS:
            rtrue;
            ;
        COPYSB_KOVS:
            BlkValueCopySB1(arg1, arg2);
            ;
        KINDDATA_KOVS:
            return COMBINATION_TY_KindData(arg1);
            ;
        EXTENT_KOVS:
            return (-(1));
            ;
        COPY_KOVS:
            COMBINATION_TY_Copy(arg1, arg2, arg3);
            ;
        COMPARE_KOVS:
            return COMBINATION_TY_Compare(arg1, arg2);
            ;
        HASH_KOVS:
            return COMBINATION_TY_Hash(arg1);
            ;
        DEBUG_KOVS:
            print " = ";
            COMBINATION_TY_Say(arg1);
            ;
    }
    rfalse;
];
[ COMBINATION_TY_Create kind sb long_block N i bk v;
    (N = KindBaseArity(kind));
    (long_block = FlexAllocate(((COMBINATION_ITEM_BASE + N)*WORDSIZE), COMBINATION_TY, BLK_FLAG_WORD));
    BlkValueWrite(long_block, COMBINATION_KIND_F, kind, 1);
    for ((i = 0):(i < N):(i)++) {
        (bk = KindBaseTerm(kind, i));
        if (KOVIsBlockValue(bk)) {
            (v = BlkValueCreate(bk));
        } else {
            (v = DefaultValueOfKOV(bk));
        }
        BlkValueWrite(long_block, (COMBINATION_ITEM_BASE + i), v, 1);
    }
    return BlkValueCreateSB1(sb, long_block);
];
[ COMBINATION_TY_Destroy comb kind no_items i bk;
    (kind = BlkValueRead(comb, COMBINATION_KIND_F));
    (no_items = KindBaseArity(kind));
    for ((i = 0):(i < no_items):(i)++) {
        (bk = KindBaseTerm(kind, i));
        if (KOVIsBlockValue(bk)) {
            BlkValueFree(BlkValueRead(comb, (i + COMBINATION_ITEM_BASE)));
        }
    }
];
[ COMBINATION_TY_CopyKind to from;
    BlkValueWrite(to, COMBINATION_KIND_F, BlkValueRead(from, COMBINATION_KIND_F));
];
[ COMBINATION_TY_CopySB to from;
    BlkValueCopySB1(to, from);
];
[ COMBINATION_TY_KindData comb;
    return BlkValueRead(comb, COMBINATION_KIND_F);
];
[ COMBINATION_TY_Copy to_comb from_comb precopied_comb_kov no_items i nv kind bk;
    (no_items = KindBaseArity(precopied_comb_kov));
    BlkValueWrite(to_comb, COMBINATION_KIND_F, precopied_comb_kov);
    for ((i = 0):(i < no_items):(i)++) {
        (bk = KindBaseTerm(kind, i));
        if (KOVIsBlockValue(bk)) {
            (nv = BlkValueCreate(bk));
            BlkValueCopy(nv, BlkValueRead(from_comb, (i + COMBINATION_ITEM_BASE)));
            BlkValueWrite(to_comb, (i + COMBINATION_ITEM_BASE), nv);
        }
    }
];
[ COMBINATION_TY_Compare left_comb right_comb delta no_items i cf kind bk;
    (kind = BlkValueRead(left_comb, COMBINATION_KIND_F));
    (no_items = KindBaseArity(kind));
    for ((i = 0):(i < no_items):(i)++) {
        (bk = KindBaseTerm(kind, i));
        (cf = KOVComparisonFunction(bk));
        if ((cf == 0 or UnsignedCompare)) {
            (delta = (BlkValueRead(left_comb, (i + COMBINATION_ITEM_BASE)) - BlkValueRead(right_comb, (i + COMBINATION_ITEM_BASE))));
            if (delta) {
                return delta;
            }
        } else {
            (delta = (cf)(BlkValueRead(left_comb, (i + COMBINATION_ITEM_BASE)),BlkValueRead(right_comb, (i + COMBINATION_ITEM_BASE))));
            if (delta) {
                return delta;
            }
        }
    }
    rfalse;
];
[ COMBINATION_TY_Distinguish left_comb right_comb;
    if ((COMBINATION_TY_Compare(left_comb, right_comb) == 0)) {
        rfalse;
    }
    rtrue;
];
[ COMBINATION_TY_Hash comb kind rv no_items i bk;
    (rv = 0);
    (kind = BlkValueRead(comb, COMBINATION_KIND_F));
    (no_items = KindBaseArity(kind));
    for ((i = 0):(i < no_items):(i)++) {
        (bk = KindBaseTerm(kind, i));
        (rv = ((rv*33) + GetHashValue(bk, BlkValueRead(comb, (i + COMBINATION_ITEM_BASE)))));
    }
    return rv;
];
[ COMBINATION_TY_Say comb format no_items v i kind bk;
    if ((((comb == 0)) || ((BlkValueWeakKind(comb) ~= COMBINATION_TY)))) {
        rtrue;
    }
    (kind = BlkValueRead(comb, COMBINATION_KIND_F));
    (no_items = KindBaseArity(kind));
    print "(";
    for ((i = 0):(i < no_items):(i)++) {
        if ((i > 0)) {
            print ", ";
        }
        (bk = KindBaseTerm(kind, i));
        (v = BlkValueRead(comb, (i + COMBINATION_ITEM_BASE)));
        if ((bk == LIST_OF_TY)) {
            LIST_OF_TY_Say(v, 1);
        } else {
            PrintKindValuePair(bk, v);
        }
    }
    print ")";
];
[ RELATION_TY_Support task arg1 arg2 arg3;
    switch (task) {
        CREATE_KOVS:
            return RELATION_TY_Create(arg1, 0, arg2);
            ;
        DESTROY_KOVS:
            RELATION_TY_Destroy(arg1);
            ;
        MAKEMUTABLE_KOVS:
            rtrue;
            ;
        COPYQUICK_KOVS:
            rtrue;
            ;
        COPYSB_KOVS:
            BlkValueCopySB1(arg1, arg2);
            ;
        KINDDATA_KOVS:
            rfalse;
            ;
        EXTENT_KOVS:
            return (-(1));
            ;
        COPY_KOVS:
            RELATION_TY_Copy(arg1, arg2);
            ;
        COMPARE_KOVS:
            return RELATION_TY_Compare(arg1, arg2);
            ;
        HASH_KOVS:
            return arg1;
            ;
        DEBUG_KOVS:
            print " = ";
            RELATION_TY_Say(arg1);
            ;
    }
    rfalse;
];
[ RelationTest relation task X Y handler;
    (handler = RlnGetF(relation, RR_HANDLER));
    return (handler)(relation,task,X,Y);
];
[ RlnGetF rel fld i;
    (rel = BlkValueGetLongBlock(rel));
    return (rel-->(fld));
];
[ RlnSetF rel fld v;
    (rel = BlkValueGetLongBlock(rel));
    ((rel-->(fld)) = v);
];
[ EmptyRelationHandler relation task X Y;
    if ((task == RELS_EMPTY)) {
        rtrue;
    }
    rfalse;
];
[ RELATION_TY_Create kov from sb rel i skov handler;
    (rel = FlexAllocate(((RRV_DATA_BASE + (3*RRP_MIN_SIZE))*WORDSIZE), RELATION_TY, (BLK_FLAG_WORD + BLK_FLAG_MULTIPLE)));
    if ((((from == 0)) && ((kov ~= 0)))) {
        (from = DefaultValueFinder(kov));
    }
    if (from) {
        for ((i = 0):(i < RRV_DATA_BASE):(i)++) {
            BlkValueWrite(rel, i, BlkValueRead(from, i), 1);
        }
        if ((BlkValueRead(from, RRV_HANDLER) == EmptyRelationHandler)) {
            (handler = ChooseRelationHandler(BlkValueRead(rel, RRV_KIND, 1)));
            BlkValueWrite(rel, RRV_NAME, "anonymous relation", 1);
            BlkValueWrite(rel, RRV_PERMISSIONS, (((RELS_TEST + RELS_ASSERT_TRUE) + RELS_ASSERT_FALSE) + RELS_SHOW), 1);
            BlkValueWrite(rel, RRV_HANDLER, handler, 1);
            BlkValueWrite(rel, RRV_STORAGE, (RRP_MIN_SIZE - 1), 1);
            BlkValueWrite(rel, RRV_DESCRIPTION, "an anonymous relation", 1);
            BlkValueWrite(rel, RRV_USED, 0, 1);
            BlkValueWrite(rel, RRV_FILLED, 0, 1);
        }
    } else {
        (handler = ChooseRelationHandler(kov));
        BlkValueWrite(rel, RRV_NAME, "anonymous relation", 1);
        BlkValueWrite(rel, RRV_PERMISSIONS, (((RELS_TEST + RELS_ASSERT_TRUE) + RELS_ASSERT_FALSE) + RELS_SHOW), 1);
        BlkValueWrite(rel, RRV_STORAGE, (RRP_MIN_SIZE - 1), 1);
        BlkValueWrite(rel, RRV_KIND, kov, 1);
        BlkValueWrite(rel, RRV_HANDLER, handler, 1);
        BlkValueWrite(rel, RRV_DESCRIPTION, "an anonymous relation", 1);
        BlkValueWrite(rel, RRV_USED, 0, 1);
        BlkValueWrite(rel, RRV_FILLED, 0, 1);
    }
    return BlkValueCreateSB1(sb, rel);
];
[ RELATION_TY_Destroy rel handler;
    (handler = BlkValueRead(rel, RRV_HANDLER));
    (handler)(rel,RELS_DESTROY);
];
[ RELATION_TY_Copy lto lfrom handler;
    (handler = BlkValueRead(lto, RRV_HANDLER));
    (handler)(lto,RELS_COPY);
];
[ RELATION_TY_Compare rleft rright ind1 ind2;
    (ind1 = BlkValueRead(rleft, RRV_HANDLER));
    (ind2 = BlkValueRead(rright, RRV_HANDLER));
    if ((ind1 ~= ind2)) {
        return (ind1 - ind2);
    }
    if ((IsMutableRelationHandler(ind1) == 0)) {
        rfalse;
    }
    return (rleft - rright);
];
[ RELATION_TY_Distinguish rleft rright;
    if ((RELATION_TY_Compare(rleft, rright) == 0)) {
        rfalse;
    }
    rtrue;
];
[ RELATION_TY_Say rel;
    if ((rel == 0)) {
        print "(null relation)";
    } else {
        print (string) RlnGetF(rel, RR_NAME);
    }
];
[ RELATION_TY_Name rel txt;
    if (rel) {
        BlkValueWrite(rel, RRV_NAME, txt);
        BlkValueWrite(rel, RRV_DESCRIPTION, txt);
    }
];
[ ChooseRelationHandler kov sym;
    if (KOVIsBlockValue(KindBaseTerm(kov, 0))) {
        if (sym) {
            return SymHashListRelationHandler;
        }
        return HashListRelationHandler;
    }
    if (sym) {
        return SymDoubleHashSetRelationHandler;
    }
    return DoubleHashSetRelationHandler;
];
[ IsMutableRelationHandler h;
    if ((h == SymHashListRelationHandler or HashListRelationHandler or SymDoubleHashSetRelationHandler or DoubleHashSetRelationHandler)) {
        rtrue;
    }
    rfalse;
];
[ RELATION_TY_SetValency rel val kov filled cur handler ext;
    (filled = BlkValueRead(rel, RRV_FILLED));
    if (filled) {
        RunTimeProblem(RTP_RELATIONCHANGEIMPOSSIBLE);
        rfalse;
    }
    (kov = BlkValueRead(rel, RRV_KIND));
    if ((val == RRVAL_EQUIV or RRVAL_SYM_V_TO_V or RRVAL_SYM_O_TO_O)) {
        if ((KindBaseTerm(kov, 0) ~= KindBaseTerm(kov, 1))) {
            RunTimeProblem(RTP_RELATIONCHANGEIMPOSSIBLE);
            rfalse;
        }
    }
    (cur = BlkValueRead(rel, RRV_HANDLER));
    switch (val) {
        RRVAL_V_TO_V:
            (handler = ChooseRelationHandler(kov, 0));
            ;
        RRVAL_V_TO_O:
            (handler = HashTableRelationHandler);
            ;
        RRVAL_O_TO_V:
            (handler = ReversedHashTableRelationHandler);
            ;
        RRVAL_O_TO_O:
            (handler = TwoInOneHashTableRelationHandler);
            ;
        RRVAL_EQUIV:
            (handler = EquivHashTableRelationHandler);
            ;
        RRVAL_SYM_V_TO_V:
            (handler = ChooseRelationHandler(kov, 1));
            ;
        RRVAL_SYM_O_TO_O:
            (handler = Sym2in1HashTableRelationHandler);
            ;
        default:
            RunTimeProblem(RTP_RELATIONCHANGEIMPOSSIBLE);
            rfalse;
            ;
    }
    if ((cur == handler)) {
        rtrue;
    }
    if ((cur == TwoInOneHashTableRelationHandler)) {
        (ext = (BlkValueRead(rel, RRV_STORAGE) + 1));
        BlkValueSetLBCapacity(rel, (RRV_DATA_BASE + (3*ext)));
    } else {
        if ((handler == TwoInOneHashTableRelationHandler)) {
            (ext = (BlkValueRead(rel, RRV_STORAGE) + 1));
            BlkValueSetLBCapacity(rel, (RRV_DATA_BASE + (4*ext)));
        }
    }
    BlkValueWrite(rel, RRV_HANDLER, handler);
];
[ RELATION_TY_GetValency rel handler;
    return ((BlkValueRead(rel, RRV_PERMISSIONS))&(VALENCY_MASK));
];
[ DoubleHashSetRelationHandler rel task X Y sym kov kx ky at tmp v;
    (kov = BlkValueRead(rel, RRV_KIND));
    (kx = KindBaseTerm(kov, 0));
    (ky = KindBaseTerm(kov, 1));
    if ((task == RELS_SET_VALENCY)) {
        return RELATION_TY_SetValency(rel, X);
    } else {
        if ((task == RELS_DESTROY)) {
            (kx = KOVIsBlockValue(kx));
            (ky = KOVIsBlockValue(ky));
            if ((~~(((kx) || (ky))))) {
                rtrue;
            }
            for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                (tmp = BlkValueRead(rel, (RRV_DATA_BASE + (3*at))));
                if (((tmp)&(RRF_USED))) {
                    if (kx) {
                        BlkValueFree(BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 1)));
                    }
                    if (ky) {
                        BlkValueFree(BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 2)));
                    }
                }
                (at)--;
            }
            rtrue;
        } else {
            if ((task == RELS_COPY)) {
                (X = KOVIsBlockValue(kx));
                (Y = KOVIsBlockValue(ky));
                if ((~~(((X) || (Y))))) {
                    rtrue;
                }
                (at = BlkValueRead(rel, RRV_STORAGE));
                while ((at >= 0)) {
                    (tmp = BlkValueRead(rel, (RRV_DATA_BASE + (3*at))));
                    if (((tmp)&(RRF_USED))) {
                        if (X) {
                            (tmp = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 1)));
                            (tmp = BlkValueCopy(BlkValueCreate(kx), tmp));
                            BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 1), tmp);
                        }
                        if (Y) {
                            (tmp = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 2)));
                            (tmp = BlkValueCopy(BlkValueCreate(ky), tmp));
                            BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 2), tmp);
                        }
                    }
                    (at)--;
                }
                rtrue;
            } else {
                if ((task == RELS_SHOW)) {
                    print (string) BlkValueRead(rel, RRV_DESCRIPTION);
                    print ":^";
                    if (sym) {
                        (kov = KOVComparisonFunction(kx));
                        if ((~~(kov))) {
                            (kov = UnsignedCompare);
                        }
                    }
                    for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                        (tmp = BlkValueRead(rel, (RRV_DATA_BASE + (3*at))));
                        if (((tmp)&(RRF_USED))) {
                            (X = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 1)));
                            (Y = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 2)));
                            if (((sym) && (((kov)(X,Y) > 0)))) {
                                continue;
                            }
                            print "  ";
                            PrintKindValuePair(kx, X);
                            if (sym) {
                                print " <=> ";
                            } else {
                                print " >=> ";
                            }
                            PrintKindValuePair(ky, Y);
                            print "^";
                        }
                    }
                    rtrue;
                } else {
                    if ((task == RELS_EMPTY)) {
                        if ((BlkValueRead(rel, RRV_USED) == 0)) {
                            rtrue;
                        }
                        if ((X == 1)) {
                            DoubleHashSetRelationHandler(rel, RELS_DESTROY);
                            for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                                (tmp = (RRV_DATA_BASE + (3*at)));
                                BlkValueWrite(rel, tmp, 0);
                                BlkValueWrite(rel, (tmp + 1), 0);
                                BlkValueWrite(rel, (tmp + 2), 0);
                            }
                            BlkValueWrite(rel, RRV_USED, 0);
                            BlkValueWrite(rel, RRV_FILLED, 0);
                            rtrue;
                        }
                        rfalse;
                    } else {
                        if ((task == RELS_LOOKUP_ANY)) {
                            for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                                (tmp = (RRV_DATA_BASE + (3*at)));
                                if (((BlkValueRead(rel, tmp))&(RRF_USED))) {
                                    if ((Y == RLANY_GET_X or RLANY_CAN_GET_X)) {
                                        (v = BlkValueRead(rel, (tmp + 2)));
                                        if (KOVIsBlockValue(ky)) {
                                            if ((BlkValueCompare(v, X) ~= 0)) {
                                                continue;
                                            }
                                        } else {
                                            if ((v ~= X)) {
                                                continue;
                                            }
                                        }
                                        if ((Y == RLANY_CAN_GET_X)) {
                                            rtrue;
                                        }
                                        return BlkValueRead(rel, (tmp + 1));
                                    } else {
                                        (v = BlkValueRead(rel, (tmp + 1)));
                                        if (KOVIsBlockValue(kx)) {
                                            if ((BlkValueCompare(v, X) ~= 0)) {
                                                continue;
                                            }
                                        } else {
                                            if ((v ~= X)) {
                                                continue;
                                            }
                                        }
                                        if ((Y == RLANY_CAN_GET_Y)) {
                                            rtrue;
                                        }
                                        return BlkValueRead(rel, (tmp + 2));
                                    }
                                }
                            }
                            if ((Y == RLANY_GET_X or RLANY_GET_Y)) {
                                print "*** Lookup failed: value not found ***^";
                            }
                            rfalse;
                        } else {
                            if ((task == RELS_LOOKUP_ALL_X)) {
                                if ((BlkValueWeakKind(Y) ~= LIST_OF_TY)) {
                                    rfalse;
                                }
                                LIST_OF_TY_SetLength(Y, 0);
                                for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                                    (tmp = (RRV_DATA_BASE + (3*at)));
                                    if (((BlkValueRead(rel, tmp))&(RRF_USED))) {
                                        (v = BlkValueRead(rel, (tmp + 2)));
                                        if (KOVIsBlockValue(ky)) {
                                            if ((BlkValueCompare(v, X) ~= 0)) {
                                                continue;
                                            }
                                        } else {
                                            if ((v ~= X)) {
                                                continue;
                                            }
                                        }
                                        LIST_OF_TY_InsertItem(Y, BlkValueRead(rel, (tmp + 1)));
                                    }
                                }
                                return Y;
                            } else {
                                if ((task == RELS_LOOKUP_ALL_Y)) {
                                    if ((BlkValueWeakKind(Y) ~= LIST_OF_TY)) {
                                        rfalse;
                                    }
                                    LIST_OF_TY_SetLength(Y, 0);
                                    for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                                        (tmp = (RRV_DATA_BASE + (3*at)));
                                        if (((BlkValueRead(rel, tmp))&(RRF_USED))) {
                                            (v = BlkValueRead(rel, (tmp + 1)));
                                            if (KOVIsBlockValue(kx)) {
                                                if ((BlkValueCompare(v, X) ~= 0)) {
                                                    continue;
                                                }
                                            } else {
                                                if ((v ~= X)) {
                                                    continue;
                                                }
                                            }
                                            LIST_OF_TY_InsertItem(Y, BlkValueRead(rel, (tmp + 2)));
                                        }
                                    }
                                    return Y;
                                } else {
                                    if ((task == RELS_LIST)) {
                                        if ((((X == 0)) || ((BlkValueWeakKind(X) ~= LIST_OF_TY)))) {
                                            rfalse;
                                        }
                                        LIST_OF_TY_SetLength(X, 0);
                                        switch (Y) {
                                            RLIST_ALL_X, RLIST_ALL_Y:
                                                for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                                                    (tmp = (RRV_DATA_BASE + (3*at)));
                                                    if (((BlkValueRead(rel, tmp))&(RRF_USED))) {
                                                        (tmp)++;
                                                        if ((Y == RLIST_ALL_Y)) {
                                                            (tmp)++;
                                                        }
                                                        (v = BlkValueRead(rel, tmp));
                                                        LIST_OF_TY_InsertItem(X, v, 0, 0, 1);
                                                    }
                                                }
                                                return X;
                                                ;
                                            RLIST_ALL_PAIRS:
                                                (Y = BlkValueCreate(kov));
                                                for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                                                    (tmp = (RRV_DATA_BASE + (3*at)));
                                                    if (((BlkValueRead(rel, tmp))&(RRF_USED))) {
                                                        (v = BlkValueRead(rel, (tmp + 1)));
                                                        BlkValueWrite(Y, COMBINATION_ITEM_BASE, v);
                                                        (v = BlkValueRead(rel, (tmp + 2)));
                                                        BlkValueWrite(Y, (COMBINATION_ITEM_BASE + 1), v);
                                                        LIST_OF_TY_InsertItem(X, Y);
                                                    }
                                                }
                                                BlkValueWrite(Y, COMBINATION_ITEM_BASE, 0);
                                                BlkValueWrite(Y, (COMBINATION_ITEM_BASE + 1), 0);
                                                BlkValueFree(Y);
                                                return X;
                                                ;
                                        }
                                        rfalse;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    (at = DoubleHashSetLookUp(rel, kx, ky, X, Y));
    switch (task) {
        RELS_TEST:
            if ((at >= 0)) {
                rtrue;
            }
            rfalse;
            ;
        RELS_ASSERT_TRUE:
            if ((at >= 0)) {
                rtrue;
            }
            (at = (~(at)));
            BlkValueWrite(rel, RRV_USED, (BlkValueRead(rel, RRV_USED) + 1));
            if ((BlkValueRead(rel, (RRV_DATA_BASE + (3*at))) == 0)) {
                BlkValueWrite(rel, RRV_FILLED, (BlkValueRead(rel, RRV_FILLED) + 1));
            }
            BlkValueWrite(rel, (RRV_DATA_BASE + (3*at)), (RRF_USED + RRF_SINGLE));
            if (KOVIsBlockValue(kx)) {
                (X = BlkValueCopy(BlkValueCreate(kx), X));
            }
            if (KOVIsBlockValue(ky)) {
                (Y = BlkValueCopy(BlkValueCreate(ky), Y));
            }
            BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 1), X);
            BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 2), Y);
            DoubleHashSetCheckResize(rel);
            rtrue;
            ;
        RELS_ASSERT_FALSE:
            if ((at < 0)) {
                rtrue;
            }
            BlkValueWrite(rel, RRV_USED, (BlkValueRead(rel, RRV_USED) - 1));
            if (KOVIsBlockValue(kx)) {
                BlkValueFree(BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 1)));
            }
            if (KOVIsBlockValue(ky)) {
                BlkValueFree(BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 2)));
            }
            BlkValueWrite(rel, (RRV_DATA_BASE + (3*at)), RRF_DELETED);
            BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 1), 0);
            BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 2), 0);
            rtrue;
            ;
    }
];
[ DoubleHashSetLookUp rel kx ky X Y hashv i free mask perturb flags;
    (hashv = (GetHashValue(kx, X) + GetHashValue(ky, Y)));
    (mask = BlkValueRead(rel, RRV_STORAGE));
    (i = ((hashv)&(mask)));
    (flags = BlkValueRead(rel, (RRV_DATA_BASE + (3*i))));
    if ((flags == 0)) {
        return (~(i));
    }
    if (DoubleHashSetEntryMatches(rel, i, kx, ky, X, Y)) {
        return i;
    }
    (free = -1);
    if (((flags)&(RRF_DELETED))) {
        (free = i);
    }
    (perturb = hashv);
    (hashv = i);
    for (:1:) {
        (hashv = (((hashv*5) + perturb) + 1));
        (i = ((hashv)&(mask)));
        (flags = BlkValueRead(rel, (RRV_DATA_BASE + (3*i))));
        if ((flags == 0)) {
            if ((free >= 0)) {
                return (~(free));
            }
            return (~(i));
        }
        if (DoubleHashSetEntryMatches(rel, i, kx, ky, X, Y)) {
            return i;
        }
        if ((((free < 0)) && (((flags)&(RRF_DELETED))))) {
            (free = i);
        }
        @ushiftr perturb RRP_PERTURB_SHIFT perturb;
    }
];
[ DoubleHashSetCheckResize rel filled ext newext temp i at kov kx ky F X Y;
    (filled = BlkValueRead(rel, RRV_FILLED));
    (ext = (BlkValueRead(rel, RRV_STORAGE) + 1));
    if ((filled >= ((ext - filled)*RRP_CROWDED_IS))) {
        (temp = FlexAllocate((ext*(3*WORDSIZE)), TEXT_TY, (BLK_FLAG_WORD + BLK_FLAG_MULTIPLE)));
        for ((i = 0):(i < (ext*3)):(i)++) {
            BlkValueWrite(temp, i, BlkValueRead(rel, (RRV_DATA_BASE + i)), 1);
        }
        if ((ext >= RRP_LARGE_IS)) {
            (newext = (ext*RRP_RESIZE_LARGE));
        } else {
            (newext = (ext*RRP_RESIZE_SMALL));
        }
        BlkValueSetLBCapacity(rel, (RRV_DATA_BASE + (newext*3)));
        BlkValueWrite(rel, RRV_STORAGE, (newext - 1));
        BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_USED));
        for ((i = 0):(i < (newext*3)):(i)++) {
            BlkValueWrite(rel, (RRV_DATA_BASE + i), 0);
        }
        (kov = BlkValueRead(rel, RRV_KIND));
        (kx = KindBaseTerm(kov, 0));
        (ky = KindBaseTerm(kov, 1));
        for ((i = 0):(i < ext):(i)++) {
            (F = BlkValueRead(temp, (3*i), 1));
            if ((((F == 0)) || (((F)&(RRF_DELETED))))) {
                continue;
            }
            (X = BlkValueRead(temp, ((3*i) + 1), 1));
            (Y = BlkValueRead(temp, ((3*i) + 2), 1));
            (at = DoubleHashSetLookUp(rel, kx, ky, X, Y));
            if ((at >= 0)) {
                print "*** Duplicate entry while resizing ***^";
                rfalse;
            }
            (at = (~(at)));
            BlkValueWrite(rel, (RRV_DATA_BASE + (3*at)), F);
            BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 1), X);
            BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 2), Y);
        }
        FlexFree(temp);
    }
];
[ DoubleHashSetEntryMatches rel at kx ky X Y cx cy;
    (cx = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 1)));
    if (KOVIsBlockValue(kx)) {
        if ((BlkValueCompare(cx, X) ~= 0)) {
            rfalse;
        }
    } else {
        if ((cx ~= X)) {
            rfalse;
        }
    }
    (cy = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 2)));
    if (KOVIsBlockValue(ky)) {
        if ((BlkValueCompare(cy, Y) ~= 0)) {
            rfalse;
        }
    } else {
        if ((cy ~= Y)) {
            rfalse;
        }
    }
    rtrue;
];
[ HashListRelationHandler rel task X Y sym kov kx ky;
    (kov = BlkValueRead(rel, RRV_KIND));
    (kx = KindBaseTerm(kov, 0));
    (ky = KindBaseTerm(kov, 1));
    return HashCoreRelationHandler(rel, task, kx, ky, X, Y, 1);
];
[ HashTableRelationHandler rel task X Y kov kx ky;
    (kov = BlkValueRead(rel, RRV_KIND));
    (kx = KindBaseTerm(kov, 0));
    (ky = KindBaseTerm(kov, 1));
    return HashCoreRelationHandler(rel, task, kx, ky, X, Y, 0);
];
[ ReversedHashTableRelationHandler rel task X Y kov kx ky swap;
    (kov = BlkValueRead(rel, RRV_KIND));
    (kx = KindBaseTerm(kov, 0));
    (ky = KindBaseTerm(kov, 1));
    switch (task) {
        RELS_SET_VALENCY:
            return RELATION_TY_SetValency(rel, X);
            ;
        RELS_TEST, RELS_ASSERT_TRUE, RELS_ASSERT_FALSE:
            return HashCoreRelationHandler(rel, task, ky, kx, Y, X, 0);
            ;
        RELS_LOOKUP_ANY:
            switch (Y) {
                RLANY_GET_X:
                    (Y = RLANY_GET_Y);
                    ;
                RLANY_GET_Y:
                    (Y = RLANY_GET_X);
                    ;
                RLANY_CAN_GET_X:
                    (Y = RLANY_CAN_GET_Y);
                    ;
                RLANY_CAN_GET_Y:
                    (Y = RLANY_CAN_GET_X);
                    ;
            }
            ;
        RELS_LOOKUP_ALL_X:
            (task = RELS_LOOKUP_ALL_Y);
            ;
        RELS_LOOKUP_ALL_Y:
            (task = RELS_LOOKUP_ALL_X);
            ;
        RELS_SHOW:
            (swap = X);
            (X = Y);
            (Y = swap);
            (swap = kx);
            (kx = ky);
            (ky = swap);
            ;
        RELS_LIST:
            switch (Y) {
                RLIST_ALL_X:
                    (Y = RLIST_ALL_Y);
                    ;
                RLIST_ALL_Y:
                    (Y = RLIST_ALL_X);
                    ;
            }
            ;
    }
    return HashCoreRelationHandler(rel, task, kx, ky, X, Y, 0);
];
[ SymDoubleHashSetRelationHandler rel task X Y;
    if ((task == RELS_ASSERT_TRUE or RELS_ASSERT_FALSE)) {
        DoubleHashSetRelationHandler(rel, task, Y, X);
    }
    return DoubleHashSetRelationHandler(rel, task, X, Y, 1);
];
[ SymHashListRelationHandler rel task X Y;
    if ((task == RELS_ASSERT_TRUE or RELS_ASSERT_FALSE)) {
        HashListRelationHandler(rel, task, Y, X);
    }
    return HashListRelationHandler(rel, task, X, Y);
];
[ Sym2in1HashTableRelationHandler rel task X Y;
    if ((task == RELS_ASSERT_TRUE or RELS_ASSERT_FALSE)) {
        TwoInOneHashTableRelationHandler(rel, task, Y, X);
    }
    return TwoInOneHashTableRelationHandler(rel, task, X, Y, 1);
];
[ HashCoreRelationHandler rel task kx ky X Y mult sym rev at tmp fl;
    if ((task == RELS_SET_VALENCY)) {
        return RELATION_TY_SetValency(rel, X);
    } else {
        if ((task == RELS_DESTROY)) {
            (kx = KOVIsBlockValue(kx));
            (ky = KOVIsBlockValue(ky));
            if ((~~(((kx) || (ky))))) {
                rtrue;
            }
            (at = BlkValueRead(rel, RRV_STORAGE));
            while ((at >= 0)) {
                (fl = BlkValueRead(rel, (RRV_DATA_BASE + (3*at))));
                if (((fl)&(RRF_USED))) {
                    if (kx) {
                        BlkValueFree(BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 1)));
                    }
                    if (((ky) || ((~~(((fl)&(RRF_SINGLE))))))) {
                        BlkValueFree(BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 2)));
                    }
                }
                (at)--;
            }
            rtrue;
        } else {
            if ((task == RELS_COPY)) {
                (X = KOVIsBlockValue(kx));
                (Y = KOVIsBlockValue(ky));
                if ((~~(((X) || (Y))))) {
                    rtrue;
                }
                (at = BlkValueRead(rel, RRV_STORAGE));
                while ((at >= 0)) {
                    (fl = BlkValueRead(rel, (RRV_DATA_BASE + (3*at))));
                    if (((fl)&(RRF_USED))) {
                        if (X) {
                            (tmp = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 1)));
                            (tmp = BlkValueCopy(BlkValueCreate(kx), tmp));
                            BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 1), tmp);
                        }
                        if (((Y) || ((~~(((fl)&(RRF_SINGLE))))))) {
                            (tmp = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 2)));
                            (tmp = BlkValueCopy(BlkValueCreate(BlkValueWeakKind(tmp)), tmp));
                            BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 2), tmp);
                        }
                    }
                    (at)--;
                }
                rtrue;
            } else {
                if ((task == RELS_SHOW)) {
                    print (string) BlkValueRead(rel, RRV_DESCRIPTION);
                    print ":^";
                    switch (RELATION_TY_GetValency(rel)) {
                        RRVAL_SYM_V_TO_V:
                            (sym = 1);
                            (tmp = KOVComparisonFunction(kx));
                            if ((~~(tmp))) {
                                (tmp = UnsignedCompare);
                            }
                            ;
                        RRVAL_O_TO_V:
                            (rev = 1);
                            ;
                    }
                    for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                        (fl = BlkValueRead(rel, (RRV_DATA_BASE + (3*at))));
                        if (((fl)&(RRF_USED))) {
                            (X = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 1)));
                            (Y = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 2)));
                            if (((fl)&(RRF_SINGLE))) {
                                if (((sym) && (((tmp)(X,Y) > 0)))) {
                                    continue;
                                }
                                print "  ";
                                if (rev) {
                                    PrintKindValuePair(ky, Y);
                                } else {
                                    PrintKindValuePair(kx, X);
                                }
                                if (sym) {
                                    print " <=> ";
                                } else {
                                    print " >=> ";
                                }
                                if (rev) {
                                    PrintKindValuePair(kx, X);
                                } else {
                                    PrintKindValuePair(ky, Y);
                                }
                                print "^";
                            } else {
                                for ((mult = 1):(mult <= LIST_OF_TY_GetLength(Y)):(mult)++) {
                                    (fl = LIST_OF_TY_GetItem(Y, mult));
                                    if (((sym) && (((tmp)(X,fl) > 0)))) {
                                        continue;
                                    }
                                    print "  ";
                                    if (rev) {
                                        PrintKindValuePair(ky, fl);
                                    } else {
                                        PrintKindValuePair(kx, X);
                                    }
                                    if (sym) {
                                        print " <=> ";
                                    } else {
                                        print " >=> ";
                                    }
                                    if (rev) {
                                        PrintKindValuePair(kx, X);
                                    } else {
                                        PrintKindValuePair(ky, fl);
                                    }
                                    print "^";
                                }
                            }
                        }
                    }
                    rtrue;
                } else {
                    if ((task == RELS_EMPTY)) {
                        if ((BlkValueRead(rel, RRV_USED) == 0)) {
                            rtrue;
                        }
                        if ((X == 1)) {
                            HashCoreRelationHandler(rel, RELS_DESTROY);
                            for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                                (tmp = (RRV_DATA_BASE + (3*at)));
                                BlkValueWrite(rel, tmp, 0);
                                BlkValueWrite(rel, (tmp + 1), 0);
                                BlkValueWrite(rel, (tmp + 2), 0);
                            }
                            BlkValueWrite(rel, RRV_USED, 0);
                            BlkValueWrite(rel, RRV_FILLED, 0);
                            rtrue;
                        }
                        rfalse;
                    } else {
                        if ((task == RELS_LOOKUP_ANY)) {
                            if ((Y == RLANY_GET_Y or RLANY_CAN_GET_Y)) {
                                (at = HashCoreLookUp(rel, kx, X));
                                if ((at >= 0)) {
                                    if ((Y == RLANY_CAN_GET_Y)) {
                                        rtrue;
                                    }
                                    (tmp = (RRV_DATA_BASE + (3*at)));
                                    (fl = BlkValueRead(rel, tmp));
                                    (tmp = BlkValueRead(rel, (tmp + 2)));
                                    if (((fl)&(RRF_SINGLE))) {
                                        return tmp;
                                    }
                                    return LIST_OF_TY_GetItem(tmp, 1);
                                }
                            } else {
                                for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                                    (tmp = (RRV_DATA_BASE + (3*at)));
                                    (fl = BlkValueRead(rel, tmp));
                                    if (((fl)&(RRF_USED))) {
                                        (sym = BlkValueRead(rel, (tmp + 2)));
                                        if (((fl)&(RRF_SINGLE))) {
                                            if (KOVIsBlockValue(ky)) {
                                                if ((BlkValueCompare(X, sym) ~= 0)) {
                                                    continue;
                                                }
                                            } else {
                                                if ((X ~= sym)) {
                                                    continue;
                                                }
                                            }
                                        } else {
                                            if ((LIST_OF_TY_FindItem(sym, X) == 0)) {
                                                continue;
                                            }
                                        }
                                        if ((Y == RLANY_CAN_GET_X)) {
                                            rtrue;
                                        }
                                        return BlkValueRead(rel, (tmp + 1));
                                    }
                                }
                            }
                            if ((Y == RLANY_GET_X or RLANY_GET_Y)) {
                                print "*** Lookup failed: value not found ***^";
                            }
                            rfalse;
                        } else {
                            if ((task == RELS_LOOKUP_ALL_X)) {
                                if ((BlkValueWeakKind(Y) ~= LIST_OF_TY)) {
                                    rfalse;
                                }
                                LIST_OF_TY_SetLength(Y, 0);
                                for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                                    (tmp = (RRV_DATA_BASE + (3*at)));
                                    (fl = BlkValueRead(rel, tmp));
                                    if (((fl)&(RRF_USED))) {
                                        (sym = BlkValueRead(rel, (tmp + 2)));
                                        if (((fl)&(RRF_SINGLE))) {
                                            if (KOVIsBlockValue(kx)) {
                                                if ((BlkValueCompare(X, sym) ~= 0)) {
                                                    continue;
                                                }
                                            } else {
                                                if ((X ~= sym)) {
                                                    continue;
                                                }
                                            }
                                        } else {
                                            if ((LIST_OF_TY_FindItem(sym, X) == 0)) {
                                                continue;
                                            }
                                        }
                                        LIST_OF_TY_InsertItem(Y, BlkValueRead(rel, (tmp + 1)));
                                    }
                                }
                                return Y;
                            } else {
                                if ((task == RELS_LOOKUP_ALL_Y)) {
                                    if ((BlkValueWeakKind(Y) ~= LIST_OF_TY)) {
                                        rfalse;
                                    }
                                    LIST_OF_TY_SetLength(Y, 0);
                                    (at = HashCoreLookUp(rel, kx, X));
                                    if ((at >= 0)) {
                                        (tmp = (RRV_DATA_BASE + (3*at)));
                                        (fl = BlkValueRead(rel, tmp));
                                        (tmp = BlkValueRead(rel, (tmp + 2)));
                                        if (((fl)&(RRF_SINGLE))) {
                                            LIST_OF_TY_InsertItem(Y, tmp);
                                        } else {
                                            LIST_OF_TY_AppendList(Y, tmp);
                                        }
                                    }
                                    return Y;
                                } else {
                                    if ((task == RELS_LIST)) {
                                        if ((BlkValueWeakKind(X) ~= LIST_OF_TY)) {
                                            rfalse;
                                        }
                                        LIST_OF_TY_SetLength(X, 0);
                                        switch (Y) {
                                            RLIST_ALL_X:
                                                for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                                                    (tmp = (RRV_DATA_BASE + (3*at)));
                                                    (fl = BlkValueRead(rel, tmp));
                                                    if (((fl)&(RRF_USED))) {
                                                        LIST_OF_TY_InsertItem(X, BlkValueRead(rel, (tmp + 1)));
                                                    }
                                                }
                                                return X;
                                                ;
                                            RLIST_ALL_Y:
                                                for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                                                    (tmp = (RRV_DATA_BASE + (3*at)));
                                                    (fl = BlkValueRead(rel, tmp));
                                                    if (((fl)&(RRF_USED))) {
                                                        (tmp = BlkValueRead(rel, (tmp + 2)));
                                                        if (((fl)&(RRF_SINGLE))) {
                                                            LIST_OF_TY_InsertItem(X, tmp, 0, 0, 1);
                                                        } else {
                                                            LIST_OF_TY_AppendList(X, tmp, 0, 0, 1);
                                                        }
                                                    }
                                                }
                                                return X;
                                                ;
                                            RLIST_ALL_PAIRS:
                                                if ((RELATION_TY_GetValency(rel) == RRVAL_O_TO_V)) {
                                                    (rev = 1);
                                                }
                                                (Y = BlkValueCreate(COMBINATION_TY, tmp));
                                                for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                                                    (tmp = (RRV_DATA_BASE + (3*at)));
                                                    (fl = BlkValueRead(rel, tmp));
                                                    if (((fl)&(RRF_USED))) {
                                                        BlkValueWrite(Y, (COMBINATION_ITEM_BASE + rev), BlkValueRead(rel, (tmp + 1)));
                                                        (tmp = BlkValueRead(rel, (tmp + 2)));
                                                        if (((fl)&(RRF_SINGLE))) {
                                                            BlkValueWrite(Y, ((COMBINATION_ITEM_BASE + 1) - rev), tmp);
                                                            LIST_OF_TY_InsertItem(X, Y);
                                                        } else {
                                                            for ((mult = LIST_OF_TY_GetLength(tmp)):(mult > 0):(mult)--) {
                                                                BlkValueWrite(Y, ((COMBINATION_ITEM_BASE + 1) - rev), LIST_OF_TY_GetItem(tmp, mult));
                                                                LIST_OF_TY_InsertItem(X, Y);
                                                            }
                                                        }
                                                    }
                                                }
                                                BlkValueWrite(Y, COMBINATION_ITEM_BASE, 0);
                                                BlkValueWrite(Y, (COMBINATION_ITEM_BASE + 1), 0);
                                                BlkValueFree(Y);
                                                return X;
                                                ;
                                        }
                                        rfalse;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    (at = HashCoreLookUp(rel, kx, X));
    switch (task) {
        RELS_TEST:
            if ((at < 0)) {
                rfalse;
            }
            (fl = BlkValueRead(rel, (RRV_DATA_BASE + (3*at))));
            (tmp = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 2)));
            if (((fl)&(RRF_SINGLE))) {
                if (KOVIsBlockValue(ky)) {
                    if ((BlkValueCompare(tmp, Y) == 0)) {
                        rtrue;
                    }
                } else {
                    if ((tmp == Y)) {
                        rtrue;
                    }
                }
                rfalse;
            } else {
                return LIST_OF_TY_FindItem(tmp, Y);
            }
            ;
        RELS_ASSERT_TRUE:
            if ((at < 0)) {
                (at = (~(at)));
                BlkValueWrite(rel, RRV_USED, (BlkValueRead(rel, RRV_USED) + 1));
                if ((BlkValueRead(rel, (RRV_DATA_BASE + (3*at))) == 0)) {
                    BlkValueWrite(rel, RRV_FILLED, (BlkValueRead(rel, RRV_FILLED) + 1));
                }
                BlkValueWrite(rel, (RRV_DATA_BASE + (3*at)), (RRF_USED + RRF_SINGLE));
                if (KOVIsBlockValue(kx)) {
                    (X = BlkValueCopy(BlkValueCreate(kx), X));
                }
                if (KOVIsBlockValue(ky)) {
                    (Y = BlkValueCopy(BlkValueCreate(ky), Y));
                }
                BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 1), X);
                BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 2), Y);
                HashCoreCheckResize(rel);
                break;
            }
            (fl = BlkValueRead(rel, (RRV_DATA_BASE + (3*at))));
            (tmp = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 2)));
            if (((fl)&(RRF_SINGLE))) {
                if (KOVIsBlockValue(ky)) {
                    if ((BlkValueCompare(tmp, Y) == 0)) {
                        rtrue;
                    }
                } else {
                    if ((tmp == Y)) {
                        rtrue;
                    }
                }
                if (mult) {
                    (fl = BlkValueCreate(LIST_OF_TY));
                    BlkValueWrite(fl, LIST_ITEM_KOV_F, ky);
                    LIST_OF_TY_SetLength(fl, 2);
                    BlkValueWrite(fl, LIST_ITEM_BASE, tmp);
                    LIST_OF_TY_PutItem(fl, 2, Y);
                    BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 2), fl);
                    BlkValueWrite(rel, (RRV_DATA_BASE + (3*at)), RRF_USED);
                } else {
                    if (KOVIsBlockValue(ky)) {
                        BlkValueFree(tmp);
                        (Y = BlkValueCopy(BlkValueCreate(ky), Y));
                    }
                    BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 2), Y);
                }
            } else {
                LIST_OF_TY_InsertItem(tmp, Y, 0, 0, 1);
            }
            rtrue;
            ;
        RELS_ASSERT_FALSE:
            if ((at < 0)) {
                rtrue;
            }
            (fl = BlkValueRead(rel, (RRV_DATA_BASE + (3*at))));
            (tmp = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 2)));
            if (((fl)&(RRF_SINGLE))) {
                if (KOVIsBlockValue(ky)) {
                    if ((BlkValueCompare(tmp, Y) ~= 0)) {
                        rtrue;
                    }
                } else {
                    if ((tmp ~= Y)) {
                        rtrue;
                    }
                }
                if (KOVIsBlockValue(ky)) {
                    BlkValueFree(BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 2)));
                }
                .DeleteEntryIgnoringY;
                BlkValueWrite(rel, RRV_USED, (BlkValueRead(rel, RRV_USED) - 1));
                if (KOVIsBlockValue(kx)) {
                    BlkValueFree(BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 1)));
                }
                BlkValueWrite(rel, (RRV_DATA_BASE + (3*at)), RRF_DELETED);
                BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 1), 0);
                BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 2), 0);
            } else {
                LIST_OF_TY_RemoveValue(tmp, Y, 1);
                if ((LIST_OF_TY_GetLength(tmp) == 0)) {
                    BlkValueFree(tmp);
                    jump DeleteEntryIgnoringY;
                }
            }
            rtrue;
            ;
    }
    rtrue;
];
[ HashCoreLookUp rel kx X hashv i free mask perturb flags;
    (hashv = GetHashValue(kx, X));
    (mask = BlkValueRead(rel, RRV_STORAGE));
    (i = ((hashv)&(mask)));
    (flags = BlkValueRead(rel, (RRV_DATA_BASE + (3*i))));
    if ((flags == 0)) {
        return (~(i));
    }
    if (HashCoreEntryMatches(rel, i, kx, X)) {
        return i;
    }
    (free = -1);
    if (((flags)&(RRF_DELETED))) {
        (free = i);
    }
    (perturb = hashv);
    (hashv = i);
    for (:1:) {
        (hashv = (((hashv*5) + perturb) + 1));
        (i = ((hashv)&(mask)));
        (flags = BlkValueRead(rel, (RRV_DATA_BASE + (3*i))));
        if ((flags == 0)) {
            if ((free >= 0)) {
                return (~(free));
            }
            return (~(i));
        }
        if (HashCoreEntryMatches(rel, i, kx, X)) {
            return i;
        }
        if ((((free < 0)) && (((flags)&(RRF_DELETED))))) {
            (free = i);
        }
        @ushiftr perturb RRP_PERTURB_SHIFT perturb;
    }
];
[ HashCoreCheckResize rel filled ext newext temp i at kov kx F X Y;
    (filled = BlkValueRead(rel, RRV_FILLED));
    (ext = (BlkValueRead(rel, RRV_STORAGE) + 1));
    if ((filled >= ((ext - filled)*RRP_CROWDED_IS))) {
        (temp = FlexAllocate((ext*(3*WORDSIZE)), TEXT_TY, (BLK_FLAG_WORD + BLK_FLAG_MULTIPLE)));
        for ((i = 0):(i < (ext*3)):(i)++) {
            BlkValueWrite(temp, i, BlkValueRead(rel, (RRV_DATA_BASE + i)), 1);
        }
        if ((ext >= RRP_LARGE_IS)) {
            (newext = (ext*RRP_RESIZE_LARGE));
        } else {
            (newext = (ext*RRP_RESIZE_SMALL));
        }
        BlkValueSetLBCapacity(rel, (RRV_DATA_BASE + (newext*3)));
        BlkValueWrite(rel, RRV_STORAGE, (newext - 1));
        BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_USED));
        for ((i = 0):(i < (newext*3)):(i)++) {
            BlkValueWrite(rel, (RRV_DATA_BASE + i), 0);
        }
        (kov = BlkValueRead(rel, RRV_KIND));
        (kx = KindBaseTerm(kov, 1));
        for ((i = 0):(i < ext):(i)++) {
            (F = BlkValueRead(temp, (3*i), 1));
            if ((((F == 0)) || (((F)&(RRF_DELETED))))) {
                continue;
            }
            (X = BlkValueRead(temp, ((3*i) + 1), 1));
            (Y = BlkValueRead(temp, ((3*i) + 2), 1));
            (at = HashCoreLookUp(rel, kx, X));
            if ((at >= 0)) {
                print "*** Duplicate entry while resizing ***^";
                rfalse;
            }
            (at = (~(at)));
            BlkValueWrite(rel, (RRV_DATA_BASE + (3*at)), F);
            BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 1), X);
            BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 2), Y);
        }
        FlexFree(temp);
    }
];
[ HashCoreEntryMatches rel at kx X cx cy;
    (cx = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 1)));
    if (KOVIsBlockValue(kx)) {
        if ((BlkValueCompare(cx, X) ~= 0)) {
            rfalse;
        }
    } else {
        if ((cx ~= X)) {
            rfalse;
        }
    }
    rtrue;
];
[ EquivHashTableRelationHandler rel task X Y kx at at2 tmp fl i ext;
    (kx = KindBaseTerm(BlkValueRead(rel, RRV_KIND), 0));
    if ((task == RELS_SET_VALENCY)) {
        return RELATION_TY_SetValency(rel, X);
    } else {
        if ((task == RELS_DESTROY)) {
            if (KOVIsBlockValue(kx)) {
                (at = BlkValueRead(rel, RRV_STORAGE));
                while ((at >= 0)) {
                    (fl = BlkValueRead(rel, (RRV_DATA_BASE + (3*at))));
                    if (((fl)&(RRF_USED))) {
                        BlkValueFree(BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 1)));
                    }
                    (at)--;
                }
            }
            rtrue;
        } else {
            if ((task == RELS_COPY)) {
                if (KOVIsBlockValue(kx)) {
                    (at = BlkValueRead(rel, RRV_STORAGE));
                    while ((at >= 0)) {
                        (fl = BlkValueRead(rel, (RRV_DATA_BASE + (3*at))));
                        if (((fl)&(RRF_USED))) {
                            (tmp = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 1)));
                            (tmp = BlkValueCopy(BlkValueCreate(kx), tmp));
                            BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 1));
                        }
                        (at)--;
                    }
                }
                rtrue;
            } else {
                if ((task == RELS_SHOW)) {
                    print (string) BlkValueRead(rel, RRV_DESCRIPTION);
                    print ":^";
                    (ext = BlkValueRead(rel, RRV_STORAGE));
                    for (((at = 0),(X = RRV_DATA_BASE)):(at <= ext):((at)++,(X = (X + 3)))) {
                        if (((BlkValueRead(rel, X))&(RRF_USED))) {
                            BlkValueWrite(rel, (X + 2), (-(BlkValueRead(rel, (X + 2)))));
                        }
                    }
                    for (((at = 0),((X = RRV_DATA_BASE),(fl = 0))):(at <= ext):((at)++,((X = (X + 3)),(fl = 0)))) {
                        if (((BlkValueRead(rel, X))&(RRF_USED))) {
                            (fl = BlkValueRead(rel, (X + 2)));
                            if ((fl > 0)) {
                                continue;
                            }
                            BlkValueWrite(rel, (X + 2), (-(fl)));
                            (tmp = BlkValueRead(rel, (X + 1)));
                            (i = 0);
                            for (((at2 = (at + 1)),(Y = (RRV_DATA_BASE + (3*at2)))):(at2 <= ext):((at2)++,(Y = (Y + 3)))) {
                                if (((BlkValueRead(rel, Y))&(RRF_USED))) {
                                    if ((BlkValueRead(rel, (Y + 2)) ~= fl)) {
                                        continue;
                                    }
                                    BlkValueWrite(rel, (Y + 2), (-(fl)));
                                    if ((~~(i))) {
                                        print "  { ";
                                        PrintKindValuePair(kx, tmp);
                                        (i = 1);
                                    }
                                    print ", ";
                                    PrintKindValuePair(kx, BlkValueRead(rel, (Y + 1)));
                                }
                            }
                            if (i) {
                                print " }^";
                            }
                        }
                    }
                    rtrue;
                } else {
                    if ((task == RELS_EMPTY)) {
                        rfalse;
                    } else {
                        if ((task == RELS_LOOKUP_ANY)) {
                            if ((Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y)) {
                                rtrue;
                            }
                            return X;
                        } else {
                            if ((task == RELS_LOOKUP_ALL_X or RELS_LOOKUP_ALL_Y)) {
                                if ((BlkValueWeakKind(Y) ~= LIST_OF_TY)) {
                                    rfalse;
                                }
                                LIST_OF_TY_SetLength(Y, 0);
                                BlkValueWrite(Y, LIST_ITEM_KOV_F, kx);
                                (at = HashCoreLookUp(rel, kx, X));
                                if ((at < 0)) {
                                    LIST_OF_TY_InsertItem(Y, X);
                                } else {
                                    (X = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 2)));
                                    for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                                        (tmp = (RRV_DATA_BASE + (3*at)));
                                        (fl = BlkValueRead(rel, tmp));
                                        if (((fl)&(RRF_USED))) {
                                            if ((BlkValueRead(rel, (tmp + 2)) ~= X)) {
                                                continue;
                                            }
                                            LIST_OF_TY_InsertItem(Y, BlkValueRead(rel, (tmp + 1)));
                                        }
                                    }
                                }
                                return Y;
                            } else {
                                if ((task == RELS_LIST)) {
                                    print "*** Domains of equivalence relations cannot be listed ***^";
                                    return X;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    (at = HashCoreLookUp(rel, kx, X));
    (at2 = HashCoreLookUp(rel, kx, Y));
    switch (task) {
        RELS_TEST:
            if ((at < 0)) {
                if (KOVIsBlockValue(kx)) {
                    if ((BlkValueCompare(X, Y) == 0)) {
                        rtrue;
                    }
                } else {
                    if ((X == Y)) {
                        rtrue;
                    }
                }
                rfalse;
            }
            if ((at2 < 0)) {
                rfalse;
            }
            if ((at == at2)) {
                rtrue;
            }
            (tmp = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 2)));
            if ((BlkValueRead(rel, ((RRV_DATA_BASE + (3*at2)) + 2)) == tmp)) {
                rtrue;
            }
            rfalse;
            ;
        RELS_ASSERT_TRUE:
            if (KOVIsBlockValue(kx)) {
                if ((BlkValueCompare(X, Y) == 0)) {
                    rtrue;
                }
            } else {
                if ((X == Y)) {
                    rtrue;
                }
            }
            if ((at < 0)) {
                if ((at2 < 0)) {
                    (tmp = 0);
                    (ext = BlkValueRead(rel, RRV_STORAGE));
                    for ((i = 0):(i <= ext):(i)++) {
                        (fl = BlkValueRead(rel, (RRV_DATA_BASE + (3*i))));
                        if (((fl)&(RRF_USED))) {
                            (fl = BlkValueRead(rel, ((RRV_DATA_BASE + (3*i)) + 2)));
                            if ((fl > tmp)) {
                                (tmp = fl);
                            }
                        }
                    }
                    (tmp)++;
                    BlkValueWrite(rel, RRV_USED, (BlkValueRead(rel, RRV_USED) + 2));
                    (at = (~(at)));
                    if (KOVIsBlockValue(kx)) {
                        (X = BlkValueCopy(BlkValueCreate(kx), X));
                    }
                    (fl = BlkValueRead(rel, (RRV_DATA_BASE + (3*at))));
                    if ((fl == 0)) {
                        BlkValueWrite(rel, RRV_FILLED, (BlkValueRead(rel, RRV_FILLED) + 1));
                    }
                    BlkValueWrite(rel, (RRV_DATA_BASE + (3*at)), (RRF_USED + RRF_SINGLE));
                    BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 1), X);
                    BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 2), tmp);
                    (at2 = (~(HashCoreLookUp(rel, kx, Y))));
                    if (KOVIsBlockValue(kx)) {
                        (Y = BlkValueCopy(BlkValueCreate(kx), Y));
                    }
                    (fl = BlkValueRead(rel, (RRV_DATA_BASE + (3*at2))));
                    if ((fl == 0)) {
                        BlkValueWrite(rel, RRV_FILLED, (BlkValueRead(rel, RRV_FILLED) + 1));
                    }
                    BlkValueWrite(rel, (RRV_DATA_BASE + (3*at2)), (RRF_USED + RRF_SINGLE));
                    BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at2)) + 1), Y);
                    BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at2)) + 2), tmp);
                    jump CheckResize;
                }
                (at = (~(at)));
                if (KOVIsBlockValue(kx)) {
                    (X = BlkValueCopy(BlkValueCreate(kx), X));
                }
                BlkValueWrite(rel, RRV_USED, (BlkValueRead(rel, RRV_USED) + 1));
                (fl = BlkValueRead(rel, (RRV_DATA_BASE + (3*at))));
                if ((fl == 0)) {
                    BlkValueWrite(rel, RRV_FILLED, (BlkValueRead(rel, RRV_FILLED) + 1));
                }
                BlkValueWrite(rel, (RRV_DATA_BASE + (3*at)), (RRF_USED + RRF_SINGLE));
                BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 1), X);
                (tmp = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at2)) + 2)));
                BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 2), tmp);
                jump CheckResize;
            }
            if ((at2 < 0)) {
                (at2 = (~(at2)));
                if (KOVIsBlockValue(kx)) {
                    (Y = BlkValueCopy(BlkValueCreate(kx), Y));
                }
                BlkValueWrite(rel, RRV_USED, (BlkValueRead(rel, RRV_USED) + 1));
                (fl = BlkValueRead(rel, (RRV_DATA_BASE + (3*at2))));
                if ((fl == 0)) {
                    BlkValueWrite(rel, RRV_FILLED, (BlkValueRead(rel, RRV_FILLED) + 1));
                }
                BlkValueWrite(rel, (RRV_DATA_BASE + (3*at2)), (RRF_USED + RRF_SINGLE));
                BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at2)) + 1), Y);
                (tmp = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 2)));
                BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at2)) + 2), tmp);
                jump CheckResize;
            }
            (tmp = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 2)));
            (fl = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at2)) + 2)));
            if ((tmp < fl)) {
                (i = tmp);
                (tmp = fl);
                (fl = i);
            }
            (ext = BlkValueRead(rel, RRV_STORAGE));
            for ((at = 0):(at <= ext):(at)++) {
                (i = ((RRV_DATA_BASE + (3*at)) + 2));
                if ((BlkValueRead(rel, i) == tmp)) {
                    BlkValueWrite(rel, i, fl);
                }
            }
            .CheckResize;
            HashCoreCheckResize(rel);
            rtrue;
            ;
        RELS_ASSERT_FALSE:
            if ((((at < 0)) || ((at2 < 0)))) {
                rtrue;
            }
            (tmp = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 2)));
            if ((BlkValueRead(rel, ((RRV_DATA_BASE + (3*at2)) + 2)) ~= tmp)) {
                rtrue;
            }
            BlkValueWrite(rel, RRV_USED, (BlkValueRead(rel, RRV_USED) - 1));
            if (KOVIsBlockValue(kx)) {
                BlkValueFree(BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 1)));
            }
            BlkValueWrite(rel, (RRV_DATA_BASE + (3*at)), RRF_DELETED);
            BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 1), 0);
            BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 2), 0);
            rtrue;
            ;
    }
];
[ TwoInOneHashTableRelationHandler rel task X Y sym kov kx ky at at2 tmp fl;
    (kov = BlkValueRead(rel, RRV_KIND));
    (kx = KindBaseTerm(kov, 0));
    (ky = KindBaseTerm(kov, 1));
    if ((task == RELS_SET_VALENCY)) {
        return RELATION_TY_SetValency(rel, X);
    } else {
        if ((task == RELS_DESTROY)) {
            (kx = KOVIsBlockValue(kx));
            (ky = KOVIsBlockValue(ky));
            if ((~~(((kx) || (ky))))) {
                rtrue;
            }
            (at = BlkValueRead(rel, RRV_STORAGE));
            while ((at >= 0)) {
                (fl = BlkValueRead(rel, (RRV_DATA_BASE + (4*at))));
                if (((fl)&(RRF_USED))) {
                    if (((((kx) && (((fl)&(RRF_ENTKEYX))))) || (((ky) && (((fl)&(RRF_ENTKEYY))))))) {
                        BlkValueFree(BlkValueRead(rel, ((RRV_DATA_BASE + (4*at)) + 1)));
                    }
                }
                (at)--;
            }
            rtrue;
        } else {
            if ((task == RELS_COPY)) {
                (X = KOVIsBlockValue(kx));
                (Y = KOVIsBlockValue(ky));
                if ((~~(((X) || (Y))))) {
                    rtrue;
                }
                (at = BlkValueRead(rel, RRV_STORAGE));
                while ((at >= 0)) {
                    (fl = BlkValueRead(rel, (RRV_DATA_BASE + (4*at))));
                    if (((fl)&(RRF_USED))) {
                        if (((((X) && (((fl)&(RRF_ENTKEYX))))) || (((Y) && (((fl)&(RRF_ENTKEYY))))))) {
                            (tmp = BlkValueRead(rel, ((RRV_DATA_BASE + (4*at)) + 1)));
                            if (((fl)&(RRF_ENTKEYX))) {
                                (tmp = BlkValueCopy(BlkValueCreate(kx), tmp));
                            } else {
                                (tmp = BlkValueCopy(BlkValueCreate(ky), tmp));
                            }
                            BlkValueWrite(rel, ((RRV_DATA_BASE + (4*at)) + 1), tmp);
                            if (((fl)&(RRF_HASX))) {
                                (at2 = TwoInOneLookUp(rel, kx, BlkValueRead(rel, ((RRV_DATA_BASE + (4*at)) + 2)), RRF_ENTKEYX));
                                if ((at2 >= 0)) {
                                    BlkValueWrite(rel, ((RRV_DATA_BASE + (4*at2)) + 3), tmp);
                                }
                            }
                            if (((fl)&(RRF_HASY))) {
                                (at2 = TwoInOneLookUp(rel, ky, BlkValueRead(rel, ((RRV_DATA_BASE + (4*at)) + 3)), RRF_ENTKEYY));
                                if ((at2 >= 0)) {
                                    BlkValueWrite(rel, ((RRV_DATA_BASE + (4*at2)) + 2), tmp);
                                }
                            }
                        }
                    }
                    (at)--;
                }
                rtrue;
            } else {
                if ((task == RELS_SHOW)) {
                    print (string) BlkValueRead(rel, RRV_DESCRIPTION);
                    print ":^";
                    if (sym) {
                        (kov = KOVComparisonFunction(kx));
                        if ((~~(kov))) {
                            (kov = UnsignedCompare);
                        }
                    }
                    for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                        (fl = BlkValueRead(rel, (RRV_DATA_BASE + (4*at))));
                        if ((((fl)&(((RRF_USED + RRF_ENTKEYX) + RRF_HASY))) == ((RRF_USED + RRF_ENTKEYX) + RRF_HASY))) {
                            (X = BlkValueRead(rel, ((RRV_DATA_BASE + (4*at)) + 1)));
                            (Y = BlkValueRead(rel, ((RRV_DATA_BASE + (4*at)) + 3)));
                            if (((sym) && (((kov)(X,Y) > 0)))) {
                                continue;
                            }
                            print "  ";
                            PrintKindValuePair(kx, X);
                            if (sym) {
                                print " <=> ";
                            } else {
                                print " >=> ";
                            }
                            PrintKindValuePair(ky, Y);
                            print "^";
                        }
                    }
                    rtrue;
                } else {
                    if ((task == RELS_EMPTY)) {
                        if ((BlkValueRead(rel, RRV_USED) == 0)) {
                            rtrue;
                        }
                        if ((X == 1)) {
                            TwoInOneHashTableRelationHandler(rel, RELS_DESTROY);
                            for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                                (tmp = (RRV_DATA_BASE + (4*at)));
                                BlkValueWrite(rel, tmp, 0);
                                BlkValueWrite(rel, (tmp + 1), 0);
                                BlkValueWrite(rel, (tmp + 2), 0);
                                BlkValueWrite(rel, (tmp + 3), 0);
                            }
                            BlkValueWrite(rel, RRV_USED, 0);
                            BlkValueWrite(rel, RRV_FILLED, 0);
                            rtrue;
                        }
                        rfalse;
                    } else {
                        if ((task == RELS_LOOKUP_ANY)) {
                            switch (Y) {
                                RLANY_GET_X, RLANY_CAN_GET_X:
                                    (at = TwoInOneLookUp(rel, ky, X, RRF_ENTKEYY));
                                    if ((at >= 0)) {
                                        (tmp = (RRV_DATA_BASE + (4*at)));
                                        if (((BlkValueRead(rel, tmp))&(RRF_HASX))) {
                                            if ((Y == RLANY_CAN_GET_X)) {
                                                rtrue;
                                            }
                                            return BlkValueRead(rel, (tmp + 2));
                                        }
                                    }
                                    ;
                                RLANY_GET_Y, RLANY_CAN_GET_Y:
                                    (at = TwoInOneLookUp(rel, kx, X, RRF_ENTKEYX));
                                    if ((at >= 0)) {
                                        (tmp = (RRV_DATA_BASE + (4*at)));
                                        if (((BlkValueRead(rel, tmp))&(RRF_HASY))) {
                                            if ((Y == RLANY_CAN_GET_Y)) {
                                                rtrue;
                                            }
                                            return BlkValueRead(rel, (tmp + 3));
                                        }
                                    }
                                    ;
                            }
                            if ((Y == RLANY_GET_X or RLANY_GET_Y)) {
                                print "*** Lookup failed: value not found ***^";
                            }
                            rfalse;
                        } else {
                            if ((task == RELS_LOOKUP_ALL_X)) {
                                (at = TwoInOneLookUp(rel, ky, X, RRF_ENTKEYY));
                                if ((at >= 0)) {
                                    (tmp = (RRV_DATA_BASE + (4*at)));
                                    if (((BlkValueRead(rel, tmp))&(RRF_HASX))) {
                                        LIST_OF_TY_InsertItem(Y, BlkValueRead(rel, (tmp + 2)));
                                    }
                                }
                                return Y;
                            } else {
                                if ((task == RELS_LOOKUP_ALL_Y)) {
                                    (at = TwoInOneLookUp(rel, kx, X, RRF_ENTKEYX));
                                    if ((at >= 0)) {
                                        (tmp = (RRV_DATA_BASE + (4*at)));
                                        if (((BlkValueRead(rel, tmp))&(RRF_HASY))) {
                                            LIST_OF_TY_InsertItem(Y, BlkValueRead(rel, (tmp + 3)));
                                        }
                                    }
                                    return Y;
                                } else {
                                    if ((task == RELS_LIST)) {
                                        switch (Y) {
                                            RLIST_ALL_X:
                                                (fl = ((RRF_USED + RRF_ENTKEYX) + RRF_HASY));
                                                jump ListEntryKeys;
                                                ;
                                            RLIST_ALL_Y:
                                                (fl = ((RRF_USED + RRF_ENTKEYY) + RRF_HASX));
                                                .ListEntryKeys;
                                                for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                                                    (tmp = (RRV_DATA_BASE + (4*at)));
                                                    if ((((BlkValueRead(rel, tmp))&(fl)) == fl)) {
                                                        LIST_OF_TY_InsertItem(X, BlkValueRead(rel, (tmp + 1)), 0, 0, 1);
                                                    }
                                                }
                                                ;
                                            RLIST_ALL_PAIRS:
                                                (tmp = BlkValueRead(X, LIST_ITEM_KOV_F));
                                                if ((KindAtomic(tmp) ~= COMBINATION_TY)) {
                                                    rfalse;
                                                }
                                                (Y = BlkValueCreate(tmp));
                                                for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                                                    (tmp = (RRV_DATA_BASE + (4*at)));
                                                    (fl = BlkValueRead(rel, tmp));
                                                    if ((((fl)&(((RRF_USED + RRF_ENTKEYX) + RRF_HASY))) == ((RRF_USED + RRF_ENTKEYX) + RRF_HASY))) {
                                                        BlkValueWrite(Y, COMBINATION_ITEM_BASE, BlkValueRead(rel, (tmp + 1)));
                                                        BlkValueWrite(Y, (COMBINATION_ITEM_BASE + 1), BlkValueRead(rel, (tmp + 3)));
                                                        LIST_OF_TY_InsertItem(X, Y);
                                                    }
                                                }
                                                BlkValueWrite(Y, COMBINATION_ITEM_BASE, 0);
                                                BlkValueWrite(Y, (COMBINATION_ITEM_BASE + 1), 0);
                                                BlkValueFree(Y);
                                                return X;
                                                ;
                                        }
                                        return X;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    (at = TwoInOneLookUp(rel, kx, X, RRF_ENTKEYX));
    switch (task) {
        RELS_TEST:
            if ((at < 0)) {
                rfalse;
            }
            (fl = BlkValueRead(rel, (RRV_DATA_BASE + (4*at))));
            if ((~~(((fl)&(RRF_HASY))))) {
                rfalse;
            }
            (tmp = BlkValueRead(rel, ((RRV_DATA_BASE + (4*at)) + 3)));
            if (KOVIsBlockValue(ky)) {
                if ((BlkValueCompare(tmp, Y) == 0)) {
                    rtrue;
                }
            } else {
                if ((tmp == Y)) {
                    rtrue;
                }
            }
            rfalse;
            ;
        RELS_ASSERT_TRUE:
            if ((at < 0)) {
                (at = (~(at)));
                BlkValueWrite(rel, RRV_USED, (BlkValueRead(rel, RRV_USED) + 1));
                (fl = BlkValueRead(rel, (RRV_DATA_BASE + (4*at))));
                if ((fl == 0)) {
                    BlkValueWrite(rel, RRV_FILLED, (BlkValueRead(rel, RRV_FILLED) + 1));
                }
                (fl = ((RRF_USED + RRF_HASY) + RRF_ENTKEYX));
                if ((((kx == ky)) || ((~~(((KOVIsBlockValue(kx)) || (KOVIsBlockValue(ky)))))))) {
                    (fl = (fl + RRF_ENTKEYY));
                }
                BlkValueWrite(rel, (RRV_DATA_BASE + (4*at)), fl);
                if (KOVIsBlockValue(kx)) {
                    (X = BlkValueCopy(BlkValueCreate(kx), X));
                }
                BlkValueWrite(rel, ((RRV_DATA_BASE + (4*at)) + 1), X);
                BlkValueWrite(rel, ((RRV_DATA_BASE + (4*at)) + 2), 0);
            } else {
                (fl = BlkValueRead(rel, (RRV_DATA_BASE + (4*at))));
                if (((fl)&(RRF_HASY))) {
                    (tmp = BlkValueRead(rel, ((RRV_DATA_BASE + (4*at)) + 3)));
                    if (KOVIsBlockValue(ky)) {
                        if ((BlkValueCompare(tmp, Y) == 0)) {
                            rtrue;
                        }
                    } else {
                        if ((tmp == Y)) {
                            rtrue;
                        }
                    }
                    (at2 = TwoInOneLookUp(rel, ky, tmp, RRF_ENTKEYY));
                    if ((at2 >= 0)) {
                        TwoInOneDelete(rel, at2, kx, ky, RRF_ENTKEYY);
                    }
                } else {
                    BlkValueWrite(rel, (RRV_DATA_BASE + (4*at)), (fl + RRF_HASY));
                }
                (X = BlkValueRead(rel, ((RRV_DATA_BASE + (4*at)) + 1)));
            }
            (at2 = TwoInOneLookUp(rel, ky, Y, RRF_ENTKEYY));
            if (KOVIsBlockValue(ky)) {
                if ((at2 >= 0)) {
                    (Y = BlkValueRead(rel, ((RRV_DATA_BASE + (4*at2)) + 1)));
                } else {
                    (Y = BlkValueCopy(BlkValueCreate(ky), Y));
                }
            }
            BlkValueWrite(rel, ((RRV_DATA_BASE + (4*at)) + 3), Y);
            if ((at2 >= 0)) {
                TwoInOneDelete(rel, at2, kx, ky, RRF_ENTKEYY, 1);
            } else {
                (at2 = (~(at2)));
            }
            BlkValueWrite(rel, RRV_USED, (BlkValueRead(rel, RRV_USED) + 1));
            (fl = BlkValueRead(rel, (RRV_DATA_BASE + (4*at2))));
            if ((fl == 0)) {
                BlkValueWrite(rel, RRV_FILLED, (BlkValueRead(rel, RRV_FILLED) + 1));
            }
            (fl = ((fl)|(((RRF_USED + RRF_HASX) + RRF_ENTKEYY))));
            if ((((kx == ky)) || ((~~(((KOVIsBlockValue(kx)) || (KOVIsBlockValue(ky)))))))) {
                (fl = ((fl)|(RRF_ENTKEYX)));
            }
            BlkValueWrite(rel, (RRV_DATA_BASE + (4*at2)), fl);
            BlkValueWrite(rel, ((RRV_DATA_BASE + (4*at2)) + 1), Y);
            BlkValueWrite(rel, ((RRV_DATA_BASE + (4*at2)) + 2), X);
            TwoInOneCheckResize(rel);
            rtrue;
            ;
        RELS_ASSERT_FALSE:
            if ((at < 0)) {
                rtrue;
            }
            (fl = BlkValueRead(rel, (RRV_DATA_BASE + (4*at))));
            if ((((fl)&(RRF_HASY)) == 0)) {
                rtrue;
            }
            (tmp = BlkValueRead(rel, ((RRV_DATA_BASE + (4*at)) + 3)));
            if (KOVIsBlockValue(ky)) {
                if ((BlkValueCompare(tmp, Y) ~= 0)) {
                    rtrue;
                }
            } else {
                if ((tmp ~= Y)) {
                    rtrue;
                }
            }
            TwoInOneDelete(rel, at, kx, ky, RRF_ENTKEYX, 1);
            rtrue;
            ;
    }
];
[ TwoInOneDelete rel at kx ky ekflag both fl at2 E i;
    (fl = BlkValueRead(rel, (RRV_DATA_BASE + (4*at))));
    if ((ekflag == RRF_ENTKEYX)) {
        if (((fl)&(RRF_HASY))) {
            (i = ((RRV_DATA_BASE + (4*at)) + 3));
            if (both) {
                (E = BlkValueRead(rel, i));
            }
            BlkValueWrite(rel, i, 0);
            if (both) {
                (at2 = TwoInOneLookUp(rel, ky, E, RRF_ENTKEYY));
                if ((at2 >= 0)) {
                    TwoInOneDelete(rel, at2, kx, ky, RRF_ENTKEYY);
                }
                if ((at2 == at)) {
                    (fl = BlkValueRead(rel, (RRV_DATA_BASE + (4*at))));
                }
            }
            (fl = ((fl)&((~(RRF_HASY)))));
        }
    } else {
        if (((fl)&(RRF_HASX))) {
            (i = ((RRV_DATA_BASE + (4*at)) + 2));
            if (both) {
                (E = BlkValueRead(rel, i));
            }
            BlkValueWrite(rel, i, 0);
            if (both) {
                (at2 = TwoInOneLookUp(rel, kx, E, RRF_ENTKEYX));
                if ((at2 >= 0)) {
                    TwoInOneDelete(rel, at2, kx, ky, RRF_ENTKEYX);
                    if ((at2 == at)) {
                        (fl = BlkValueRead(rel, (RRV_DATA_BASE + (4*at))));
                    }
                }
            }
            (fl = ((fl)&((~(RRF_HASX)))));
        }
    }
    if ((((fl)&((RRF_HASX + RRF_HASY))) == 0)) {
        if (((((((fl)&(RRF_ENTKEYX))) && (KOVIsBlockValue(kx)))) || ((((((ky ~= kx)) && (((fl)&(RRF_ENTKEYY))))) && (KOVIsBlockValue(ky)))))) {
            BlkValueFree(BlkValueRead(rel, ((RRV_DATA_BASE + (4*at)) + 1)));
        }
        BlkValueWrite(rel, (RRV_DATA_BASE + (4*at)), RRF_DELETED);
        BlkValueWrite(rel, ((RRV_DATA_BASE + (4*at)) + 1), 0);
        BlkValueWrite(rel, ((RRV_DATA_BASE + (4*at)) + 2), 0);
        BlkValueWrite(rel, ((RRV_DATA_BASE + (4*at)) + 3), 0);
        BlkValueWrite(rel, RRV_USED, (BlkValueRead(rel, RRV_USED) - 1));
    } else {
        BlkValueWrite(rel, (RRV_DATA_BASE + (4*at)), fl);
    }
];
[ TwoInOneLookUp rel ke E ekflag hashv i free mask perturb flags;
    (hashv = GetHashValue(ke, E));
    (mask = BlkValueRead(rel, RRV_STORAGE));
    (i = ((hashv)&(mask)));
    (flags = BlkValueRead(rel, (RRV_DATA_BASE + (4*i))));
    if ((flags == 0)) {
        return (~(i));
    }
    if (((((flags)&(ekflag))) && (TwoInOneEntryMatches(rel, i, ke, E)))) {
        return i;
    }
    (free = -1);
    if (((flags)&(RRF_DELETED))) {
        (free = i);
    }
    (perturb = hashv);
    (hashv = i);
    for (:1:) {
        (hashv = (((hashv*5) + perturb) + 1));
        (i = ((hashv)&(mask)));
        (flags = BlkValueRead(rel, (RRV_DATA_BASE + (4*i))));
        if ((flags == 0)) {
            if ((free >= 0)) {
                return (~(free));
            }
            return (~(i));
        }
        if (((((flags)&(ekflag))) && (TwoInOneEntryMatches(rel, i, ke, E)))) {
            return i;
        }
        if ((((free < 0)) && (((flags)&(RRF_DELETED))))) {
            (free = i);
        }
        @ushiftr perturb RRP_PERTURB_SHIFT perturb;
    }
];
[ TwoInOneCheckResize rel filled ext newext temp i at kov kx ky F E X Y;
    (filled = BlkValueRead(rel, RRV_FILLED));
    (ext = (BlkValueRead(rel, RRV_STORAGE) + 1));
    if ((filled >= ((ext - filled)*RRP_CROWDED_IS))) {
        (temp = FlexAllocate((ext*(4*WORDSIZE)), TEXT_TY, (BLK_FLAG_WORD + BLK_FLAG_MULTIPLE)));
        for ((i = 0):(i < (ext*4)):(i)++) {
            BlkValueWrite(temp, i, BlkValueRead(rel, (RRV_DATA_BASE + i)), 1);
        }
        if ((ext >= RRP_LARGE_IS)) {
            (newext = (ext*RRP_RESIZE_LARGE));
        } else {
            (newext = (ext*RRP_RESIZE_SMALL));
        }
        BlkValueSetLBCapacity(rel, (RRV_DATA_BASE + (newext*4)));
        BlkValueWrite(rel, RRV_STORAGE, (newext - 1));
        BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_USED));
        for ((i = 0):(i < (newext*4)):(i)++) {
            BlkValueWrite(rel, (RRV_DATA_BASE + i), 0);
        }
        (kov = BlkValueRead(rel, RRV_KIND));
        (kx = KindBaseTerm(kov, 0));
        (ky = KindBaseTerm(kov, 1));
        for ((i = 0):(i < ext):(i)++) {
            (F = BlkValueRead(temp, (4*i), 1));
            if ((((F == 0)) || (((F)&(RRF_DELETED))))) {
                continue;
            }
            (E = BlkValueRead(temp, ((4*i) + 1), 1));
            (X = BlkValueRead(temp, ((4*i) + 2), 1));
            (Y = BlkValueRead(temp, ((4*i) + 3), 1));
            if (((F)&(RRF_ENTKEYX))) {
                (at = TwoInOneLookUp(rel, kx, E, RRF_ENTKEYX));
            } else {
                (at = TwoInOneLookUp(rel, ky, E, RRF_ENTKEYY));
            }
            if ((at >= 0)) {
                print "*** Duplicate entry while resizing ***^";
                rfalse;
            }
            (at = (~(at)));
            BlkValueWrite(rel, (RRV_DATA_BASE + (4*at)), F);
            BlkValueWrite(rel, ((RRV_DATA_BASE + (4*at)) + 1), E);
            BlkValueWrite(rel, ((RRV_DATA_BASE + (4*at)) + 2), X);
            BlkValueWrite(rel, ((RRV_DATA_BASE + (4*at)) + 3), Y);
        }
        FlexFree(temp);
    }
];
[ TwoInOneEntryMatches rel at ke E ce;
    (ce = BlkValueRead(rel, ((RRV_DATA_BASE + (4*at)) + 1)));
    if (KOVIsBlockValue(ke)) {
        if ((BlkValueCompare(ce, E) ~= 0)) {
            rfalse;
        }
    } else {
        if ((ce ~= E)) {
            rfalse;
        }
    }
    rtrue;
];
[ RELATION_TY_Empty rel set handler;
    (handler = RlnGetF(rel, RR_HANDLER));
    return (handler)(rel,RELS_EMPTY,set);
];
[ RELATION_TY_EquivalenceAdjective rel set perms state handler;
    (perms = RlnGetF(rel, RR_PERMISSIONS));
    if (((perms)&(RELS_EQUIVALENCE))) {
        (state = 1);
    }
    if ((set < 0)) {
        return state;
    }
    if (((set) && ((state == 0)))) {
        (perms = (perms + RELS_EQUIVALENCE));
        if ((((perms)&(RELS_SYMMETRIC)) == 0)) {
            (perms = (perms + RELS_SYMMETRIC));
        }
    }
    if ((((set == 0)) && (state))) {
        (perms = (perms - RELS_EQUIVALENCE));
        if (((perms)&(RELS_SYMMETRIC))) {
            (perms = (perms - RELS_SYMMETRIC));
        }
    }
    RlnSetF(rel, RR_PERMISSIONS, perms);
    (handler = RlnGetF(rel, RR_HANDLER));
    if (((handler)(rel,RELS_SET_VALENCY,((perms)&(VALENCY_MASK))) == 0)) {
        print "*** Can't change this to an equivalence relation ***";
        new_line;
        rtrue;
    }
];
[ RELATION_TY_SymmetricAdjective rel set perms state handler;
    (perms = RlnGetF(rel, RR_PERMISSIONS));
    if (((perms)&(RELS_SYMMETRIC))) {
        (state = 1);
    }
    if ((set < 0)) {
        return state;
    }
    if (((set) && ((state == 0)))) {
        (perms = (perms + RELS_SYMMETRIC));
    }
    if ((((set == 0)) && (state))) {
        (perms = (perms - RELS_SYMMETRIC));
    }
    RlnSetF(rel, RR_PERMISSIONS, perms);
    (handler = RlnGetF(rel, RR_HANDLER));
    if (((handler)(rel,RELS_SET_VALENCY,((perms)&(VALENCY_MASK))) == 0)) {
        print "*** Can't change this to a symmetric relation ***";
        new_line;
        rtrue;
    }
];
[ RELATION_TY_OToOAdjective rel set perms state handler i;
    (perms = RlnGetF(rel, RR_PERMISSIONS));
    if ((((perms)&((RELS_X_UNIQUE + RELS_Y_UNIQUE))) == (RELS_X_UNIQUE + RELS_Y_UNIQUE))) {
        (state = 1);
    }
    if ((set < 0)) {
        return state;
    }
    if (((set) && ((state == 0)))) {
        if ((((perms)&(RELS_X_UNIQUE)) == 0)) {
            (perms = (perms + RELS_X_UNIQUE));
        }
        if ((((perms)&(RELS_Y_UNIQUE)) == 0)) {
            (perms = (perms + RELS_Y_UNIQUE));
        }
        if (((perms)&(RELS_EQUIVALENCE))) {
            (perms = (perms - RELS_EQUIVALENCE));
        }
    }
    if ((((set == 0)) && (state))) {
        if (((perms)&(RELS_X_UNIQUE))) {
            (perms = (perms - RELS_X_UNIQUE));
        }
        if (((perms)&(RELS_Y_UNIQUE))) {
            (perms = (perms - RELS_Y_UNIQUE));
        }
    }
    RlnSetF(rel, RR_PERMISSIONS, perms);
    (handler = RlnGetF(rel, RR_HANDLER));
    if (((handler)(rel,RELS_SET_VALENCY,((perms)&(VALENCY_MASK))) == 0)) {
        print "*** Can't change this to a one-to-one relation ***";
        new_line;
        rtrue;
    }
];
[ RELATION_TY_OToVAdjective rel set perms state handler;
    (perms = RlnGetF(rel, RR_PERMISSIONS));
    if ((((perms)&((RELS_X_UNIQUE + RELS_Y_UNIQUE))) == RELS_X_UNIQUE)) {
        (state = 1);
    }
    if ((set < 0)) {
        return state;
    }
    if (((set) && ((state == 0)))) {
        if ((((perms)&(RELS_X_UNIQUE)) == 0)) {
            (perms = (perms + RELS_X_UNIQUE));
        }
        if (((perms)&(RELS_Y_UNIQUE))) {
            (perms = (perms - RELS_Y_UNIQUE));
        }
        if (((perms)&(RELS_SYMMETRIC))) {
            (perms = (perms - RELS_SYMMETRIC));
        }
        if (((perms)&(RELS_EQUIVALENCE))) {
            (perms = (perms - RELS_EQUIVALENCE));
        }
    }
    if ((((set == 0)) && (state))) {
        if (((perms)&(RELS_X_UNIQUE))) {
            (perms = (perms - RELS_X_UNIQUE));
        }
        if (((perms)&(RELS_Y_UNIQUE))) {
            (perms = (perms - RELS_Y_UNIQUE));
        }
    }
    RlnSetF(rel, RR_PERMISSIONS, perms);
    (handler = RlnGetF(rel, RR_HANDLER));
    if (((handler)(rel,RELS_SET_VALENCY,((perms)&(VALENCY_MASK))) == 0)) {
        print "*** Can't change this to a one-to-various relation ***";
        new_line;
        rtrue;
    }
];
[ RELATION_TY_VToOAdjective rel set perms state handler;
    (perms = RlnGetF(rel, RR_PERMISSIONS));
    if ((((perms)&((RELS_X_UNIQUE + RELS_Y_UNIQUE))) == RELS_Y_UNIQUE)) {
        (state = 1);
    }
    if ((set < 0)) {
        return state;
    }
    if (((set) && ((state == 0)))) {
        if (((perms)&(RELS_X_UNIQUE))) {
            (perms = (perms - RELS_X_UNIQUE));
        }
        if ((((perms)&(RELS_Y_UNIQUE)) == 0)) {
            (perms = (perms + RELS_Y_UNIQUE));
        }
        if (((perms)&(RELS_SYMMETRIC))) {
            (perms = (perms - RELS_SYMMETRIC));
        }
        if (((perms)&(RELS_EQUIVALENCE))) {
            (perms = (perms - RELS_EQUIVALENCE));
        }
    }
    if ((((set == 0)) && (state))) {
        if (((perms)&(RELS_X_UNIQUE))) {
            (perms = (perms - RELS_X_UNIQUE));
        }
        if (((perms)&(RELS_Y_UNIQUE))) {
            (perms = (perms - RELS_Y_UNIQUE));
        }
    }
    RlnSetF(rel, RR_PERMISSIONS, perms);
    (handler = RlnGetF(rel, RR_HANDLER));
    if (((handler)(rel,RELS_SET_VALENCY,((perms)&(VALENCY_MASK))) == 0)) {
        print "*** Can't change this to a various-to-one relation ***";
        new_line;
        rtrue;
    }
];
[ RELATION_TY_VToVAdjective rel set perms state handler;
    (perms = RlnGetF(rel, RR_PERMISSIONS));
    if ((((perms)&((RELS_X_UNIQUE + RELS_Y_UNIQUE))) == 0)) {
        (state = 1);
    }
    if ((set < 0)) {
        return state;
    }
    if (((set) && ((state == 0)))) {
        if (((perms)&(RELS_X_UNIQUE))) {
            (perms = (perms - RELS_X_UNIQUE));
        }
        if (((perms)&(RELS_Y_UNIQUE))) {
            (perms = (perms - RELS_Y_UNIQUE));
        }
    }
    if ((((set == 0)) && (state))) {
        if ((((perms)&(RELS_X_UNIQUE)) == 0)) {
            (perms = (perms + RELS_X_UNIQUE));
        }
        if ((((perms)&(RELS_Y_UNIQUE)) == 0)) {
            (perms = (perms + RELS_Y_UNIQUE));
        }
    }
    RlnSetF(rel, RR_PERMISSIONS, perms);
    (handler = RlnGetF(rel, RR_HANDLER));
    if (((handler)(rel,RELS_SET_VALENCY,((perms)&(VALENCY_MASK))) == 0)) {
        print "*** Can't change this to a various-to-various relation ***";
        new_line;
        rtrue;
    }
];
[ Relation_Now1to1 obj1 relation_property obj2 ol;
    if (obj2) {
        objectloop (ol ofclass Object && (_final_propertyexists(OBJECT_TY, ol, relation_property))) {
            if ((_final_propertyvalue(OBJECT_TY, ol, relation_property) == obj2)) {
                (_final_store_property(OBJECT_TY,ol,relation_property, 0));
            }
        }
    }
    if (obj1) {
        (_final_store_property(OBJECT_TY,obj1,relation_property, obj2));
    }
];
[ Relation_NowN1toV obj1 relation_property obj2;
    if (((obj1) && ((_final_propertyvalue(OBJECT_TY, obj1, relation_property) == obj2)))) {
        (_final_store_property(OBJECT_TY,obj1,relation_property, 0));
    }
];
[ Relation_Now1to1V obj1 obj2 KOV relation_property ol N;
    if (obj2) {
        (N = KOVDomainSize(KOV));
        for ((ol = 1):(ol <= N):(ol)++) {
            if ((GProperty(KOV, ol, relation_property) == obj2)) {
                WriteGProperty(KOV, ol, relation_property, 0);
            }
        }
    }
    if (obj1) {
        WriteGProperty(KOV, obj1, relation_property, obj2);
    }
];
[ Relation_NowN1toVV obj1 obj2 KOV relation_property;
    if (((obj1) && ((GProperty(KOV, obj1, relation_property) == obj2)))) {
        WriteGProperty(KOV, obj1, relation_property, 0);
    }
];
[ Relation_NowS1to1 obj1 relation_property obj2;
    if ((((((((obj1 ofclass Object)) && ((_final_propertyexists(OBJECT_TY, obj1, relation_property))))) && ((obj2 ofclass Object)))) && ((_final_propertyexists(OBJECT_TY, obj2, relation_property))))) {
        if (_final_propertyvalue(OBJECT_TY, obj1, relation_property)) {
            (_final_store_property(OBJECT_TY,_final_propertyvalue(OBJECT_TY, obj1, relation_property),relation_property, 0));
        }
        if (_final_propertyvalue(OBJECT_TY, obj2, relation_property)) {
            (_final_store_property(OBJECT_TY,_final_propertyvalue(OBJECT_TY, obj2, relation_property),relation_property, 0));
        }
        (_final_store_property(OBJECT_TY,obj1,relation_property, obj2));
        (_final_store_property(OBJECT_TY,obj2,relation_property, obj1));
    }
];
[ Relation_NowSN1to1 obj1 relation_property obj2;
    if ((((((((((obj1 ofclass Object)) && ((_final_propertyexists(OBJECT_TY, obj1, relation_property))))) && ((obj2 ofclass Object)))) && ((_final_propertyexists(OBJECT_TY, obj2, relation_property))))) && ((_final_propertyvalue(OBJECT_TY, obj1, relation_property) == obj2)))) {
        (_final_store_property(OBJECT_TY,obj1,relation_property, 0));
        (_final_store_property(OBJECT_TY,obj2,relation_property, 0));
    }
];
[ Relation_NowS1to1V obj1 obj2 KOV relation_property;
    if (GProperty(KOV, obj1, relation_property)) {
        WriteGProperty(KOV, GProperty(KOV, obj1, relation_property), relation_property, 0);
    }
    if (GProperty(KOV, obj2, relation_property)) {
        WriteGProperty(KOV, GProperty(KOV, obj2, relation_property), relation_property, 0);
    }
    WriteGProperty(KOV, obj1, relation_property, obj2);
    WriteGProperty(KOV, obj2, relation_property, obj1);
];
[ Relation_NowSN1to1V obj1 obj2 KOV relation_property;
    if ((GProperty(KOV, obj1, relation_property) == obj2)) {
        WriteGProperty(KOV, obj1, relation_property, 0);
        WriteGProperty(KOV, obj2, relation_property, 0);
    }
];
[ Relation_NowVtoV obj1 relation obj2 sym pr pr2 i1 i2 vtov_structure;
    if (((sym) && ((obj2 ~= obj1)))) {
        Relation_NowVtoV(obj2, relation, obj1, 0);
    }
    (vtov_structure = RlnGetF(relation, RR_STORAGE));
    (pr = (vtov_structure-->(VTOVS_LEFT_INDEX_PROP)));
    (pr2 = (vtov_structure-->(VTOVS_RIGHT_INDEX_PROP)));
    ((vtov_structure-->(VTOVS_CACHE_BROKEN)) = 1);
    if (pr) {
        if ((((obj1 ofclass Object)) && ((_final_propertyexists(OBJECT_TY, obj1, pr))))) {
            (i1 = _final_propertyvalue(OBJECT_TY, obj1, pr));
        } else {
            return RunTimeProblem(RTP_IMPREL, obj1, relation);
        }
    } else {
        (i1 = (obj1 - 1));
    }
    if (pr2) {
        if ((((obj2 ofclass Object)) && ((_final_propertyexists(OBJECT_TY, obj2, pr2))))) {
            (i2 = _final_propertyvalue(OBJECT_TY, obj2, pr2));
        } else {
            return RunTimeProblem(RTP_IMPREL, obj2, relation);
        }
    } else {
        (i2 = (obj2 - 1));
    }
    (pr = ((i1*(vtov_structure-->(VTOVS_RIGHT_DOMAIN_SIZE))) + i2));
    (i1 = (IncreasingPowersOfTwo_TB-->((pr%16))));
    (pr = ((pr/16) + 8));
    ((vtov_structure-->(pr)) = (((vtov_structure-->(pr)))|(i1)));
];
[ Relation_NowNVtoV obj1 relation obj2 sym pr pr2 i1 i2 vtov_structure;
    if (((sym) && ((obj2 ~= obj1)))) {
        Relation_NowNVtoV(obj2, relation, obj1, 0);
    }
    (vtov_structure = RlnGetF(relation, RR_STORAGE));
    (pr = (vtov_structure-->(VTOVS_LEFT_INDEX_PROP)));
    (pr2 = (vtov_structure-->(VTOVS_RIGHT_INDEX_PROP)));
    ((vtov_structure-->(VTOVS_CACHE_BROKEN)) = 1);
    if (pr) {
        if ((((obj1 ofclass Object)) && ((_final_propertyexists(OBJECT_TY, obj1, pr))))) {
            (i1 = _final_propertyvalue(OBJECT_TY, obj1, pr));
        } else {
            return RunTimeProblem(RTP_IMPREL, obj1, relation);
        }
    } else {
        (i1 = (obj1 - 1));
    }
    if (pr2) {
        if ((((obj2 ofclass Object)) && ((_final_propertyexists(OBJECT_TY, obj2, pr2))))) {
            (i2 = _final_propertyvalue(OBJECT_TY, obj2, pr2));
        } else {
            return RunTimeProblem(RTP_IMPREL, obj2, relation);
        }
    } else {
        (i2 = (obj2 - 1));
    }
    (pr = ((i1*(vtov_structure-->(VTOVS_RIGHT_DOMAIN_SIZE))) + i2));
    (i1 = (IncreasingPowersOfTwo_TB-->((pr%16))));
    (pr = ((pr/16) + 8));
    if ((((vtov_structure-->(pr)))&(i1))) {
        ((vtov_structure-->(pr)) = ((vtov_structure-->(pr)) - i1));
    }
];
[ Relation_TestVtoV obj1 relation obj2 sym pr pr2 i1 i2 vtov_structure;
    (vtov_structure = RlnGetF(relation, RR_STORAGE));
    (pr = (vtov_structure-->(VTOVS_LEFT_INDEX_PROP)));
    (pr2 = (vtov_structure-->(VTOVS_RIGHT_INDEX_PROP)));
    if (((sym) && ((obj2 > obj1)))) {
        (sym = obj1);
        (obj1 = obj2);
        (obj2 = sym);
    }
    if (pr) {
        if ((((obj1 ofclass Object)) && ((_final_propertyexists(OBJECT_TY, obj1, pr))))) {
            (i1 = _final_propertyvalue(OBJECT_TY, obj1, pr));
        } else {
            RunTimeProblem(RTP_IMPREL, obj1, relation);
            rfalse;
        }
    } else {
        (i1 = (obj1 - 1));
    }
    if (pr2) {
        if ((((obj2 ofclass Object)) && ((_final_propertyexists(OBJECT_TY, obj2, pr2))))) {
            (i2 = _final_propertyvalue(OBJECT_TY, obj2, pr2));
        } else {
            RunTimeProblem(RTP_IMPREL, obj2, relation);
            rfalse;
        }
    } else {
        (i2 = (obj2 - 1));
    }
    (pr = ((i1*(vtov_structure-->(VTOVS_RIGHT_DOMAIN_SIZE))) + i2));
    (i1 = (IncreasingPowersOfTwo_TB-->((pr%16))));
    (pr = ((pr/16) + 8));
    if ((((vtov_structure-->(pr)))&(i1))) {
        rtrue;
    }
    rfalse;
];
[ Relation_NowEquiv obj1 relation_property obj2 big little;
    (big = _final_propertyvalue(OBJECT_TY, obj1, relation_property));
    (little = _final_propertyvalue(OBJECT_TY, obj2, relation_property));
    if ((big == little)) {
        rtrue;
    }
    if ((big < little)) {
        (little = _final_propertyvalue(OBJECT_TY, obj1, relation_property));
        (big = _final_propertyvalue(OBJECT_TY, obj2, relation_property));
    }
    objectloop (obj1 ofclass Object && (_final_propertyexists(OBJECT_TY, obj1, relation_property))) {
        if ((_final_propertyvalue(OBJECT_TY, obj1, relation_property) == big)) {
            (_final_store_property(OBJECT_TY,obj1,relation_property, little));
        }
    }
];
[ Relation_NowNEquiv obj1 relation_property obj2 old new;
    (old = _final_propertyvalue(OBJECT_TY, obj1, relation_property));
    (new = _final_propertyvalue(OBJECT_TY, obj2, relation_property));
    if ((old ~= new)) {
        rtrue;
    }
    (new = 0);
    objectloop (obj2 ofclass Object && (_final_propertyexists(OBJECT_TY, obj2, relation_property))) {
        if ((_final_propertyvalue(OBJECT_TY, obj2, relation_property) > new)) {
            (new = _final_propertyvalue(OBJECT_TY, obj2, relation_property));
        }
    }
    (new)++;
    (_final_store_property(OBJECT_TY,obj1,relation_property, new));
];
[ Relation_NowEquivV obj1 obj2 KOV relation_property n big little i;
    (big = GProperty(KOV, obj1, relation_property));
    (little = GProperty(KOV, obj2, relation_property));
    if ((big == little)) {
        rtrue;
    }
    if ((big < little)) {
        (little = GProperty(KOV, obj1, relation_property));
        (big = GProperty(KOV, obj2, relation_property));
    }
    (n = KOVDomainSize(KOV));
    for ((i = 1):(i <= n):(i)++) {
        if ((GProperty(KOV, i, relation_property) == big)) {
            WriteGProperty(KOV, i, relation_property, little);
        }
    }
];
[ Relation_NowNEquivV obj1 obj2 KOV relation_property n old new i;
    (old = GProperty(KOV, obj1, relation_property));
    (new = GProperty(KOV, obj2, relation_property));
    if ((old ~= new)) {
        rtrue;
    }
    (new = 0);
    (n = KOVDomainSize(KOV));
    for ((i = 1):(i <= n):(i)++) {
        if ((GProperty(KOV, i, relation_property) > new)) {
            (new = GProperty(KOV, i, relation_property));
        }
    }
    (new)++;
    WriteGProperty(KOV, obj1, relation_property, new);
];
[ Relation_ShowVtoV relation sym x obj1 obj2 pr pr2 proutine1 proutine2 vtov_structure;
    (vtov_structure = RlnGetF(relation, RR_STORAGE));
    (pr = (vtov_structure-->(VTOVS_LEFT_INDEX_PROP)));
    (pr2 = (vtov_structure-->(VTOVS_RIGHT_INDEX_PROP)));
    (proutine1 = (vtov_structure-->(VTOVS_LEFT_PRINTING_ROUTINE)));
    (proutine2 = (vtov_structure-->(VTOVS_RIGHT_PRINTING_ROUTINE)));
    if (((pr) && (pr2))) {
        objectloop (obj1 ofclass Object && (_final_propertyexists(OBJECT_TY, obj1, pr))) {
            objectloop (obj2 ofclass Object && (_final_propertyexists(OBJECT_TY, obj2, pr2))) {
                if (((sym) && ((obj2 > obj1)))) {
                    continue;
                }
                if (Relation_TestVtoV(obj1, relation, obj2)) {
                    if ((x == 0)) {
                        print (string) RlnGetF(relation, RR_DESCRIPTION);
                        print ":^";
                        (x = 1);
                    }
                    print "  ";
                    CDefArt(obj1);
                    if (sym) {
                        print "  <=>  ";
                    } else {
                        print "  >=>  ";
                    }
                    DefArt(obj2);
                    print "^";
                }
            }
        }
        rtrue;
    }
    if (((pr) && ((pr2 == 0)))) {
        objectloop (obj1 ofclass Object && (_final_propertyexists(OBJECT_TY, obj1, pr))) {
            for ((obj2 = 1):(obj2 <= (vtov_structure-->(VTOVS_RIGHT_DOMAIN_SIZE))):(obj2)++) {
                if (Relation_TestVtoV(obj1, relation, obj2)) {
                    if ((x == 0)) {
                        print (string) RlnGetF(relation, RR_DESCRIPTION);
                        print ":^";
                        (x = 1);
                    }
                    print "  ";
                    CDefArt(obj1);
                    print "  >=>  ";
                    (proutine2)(obj2);
                    print "^";
                }
            }
        }
        rtrue;
    }
    if ((((pr == 0)) && (pr2))) {
        for ((obj1 = 1):(obj1 <= (vtov_structure-->(2))):(obj1)++) {
            objectloop (obj2 ofclass Object && (_final_propertyexists(OBJECT_TY, obj2, pr2))) {
                if (Relation_TestVtoV(obj1, relation, obj2)) {
                    if ((x == 0)) {
                        print (string) RlnGetF(relation, RR_DESCRIPTION);
                        print ":^";
                        (x = 1);
                    }
                    print "  ";
                    (proutine1)(obj1);
                    print "  >=>  ";
                    DefArt(obj2);
                    print "^";
                }
            }
        }
        rtrue;
    }
    for ((obj1 = 1):(obj1 <= (vtov_structure-->(2))):(obj1)++) {
        for ((obj2 = 1):(obj2 <= (vtov_structure-->(VTOVS_RIGHT_DOMAIN_SIZE))):(obj2)++) {
            if (Relation_TestVtoV(obj1, relation, obj2)) {
                if ((x == 0)) {
                    print (string) RlnGetF(relation, RR_DESCRIPTION);
                    print ":^";
                    (x = 1);
                }
                print "  ";
                (proutine1)(obj1);
                print "  >=>  ";
                (proutine2)(obj2);
                print "^";
            }
        }
    }
];
[ Relation_ShowOtoO relation sym x relation_property t tr N obj1 obj2;
    (relation_property = RlnGetF(relation, RR_STORAGE));
    (t = KindBaseTerm(RlnGetF(relation, RR_KIND), 0));
    (tr = KindBaseTerm(RlnGetF(relation, RR_KIND), 1));
    if ((t == OBJECT_TY)) {
        objectloop (obj1 ofclass Object && (_final_propertyexists(OBJECT_TY, obj1, relation_property))) {
            (obj2 = _final_propertyvalue(OBJECT_TY, obj1, relation_property));
            if (((sym) && ((obj2 < obj1)))) {
                continue;
            }
            if ((obj2 == 0)) {
                continue;
            }
            if ((x == 0)) {
                print (string) RlnGetF(relation, RR_DESCRIPTION);
                print ":^";
                (x = 1);
            }
            print "  ";
            CDefArt(obj1);
            if (sym) {
                print "  ==  ";
            } else {
                print "  >=>  ";
            }
            PrintKindValuePair(tr, obj2);
            print "^";
        }
    } else {
        (N = KOVDomainSize(t));
        for ((obj1 = 1):(obj1 <= N):(obj1)++) {
            (obj2 = GProperty(t, obj1, relation_property));
            if (((sym) && ((obj2 < obj1)))) {
                continue;
            }
            if ((obj2 == 0)) {
                continue;
            }
            if ((x == 0)) {
                print (string) RlnGetF(relation, RR_DESCRIPTION);
                print ":^";
                (x = 1);
            }
            print "  ";
            PrintKindValuePair(t, obj1);
            if (sym) {
                print "  ==  ";
            } else {
                print "  >=>  ";
            }
            PrintKindValuePair(tr, obj2);
            print "^";
        }
    }
];
[ Relation_RShowOtoO relation sym x relation_property obj1 obj2 t1 t2 N1 N2;
    (relation_property = RlnGetF(relation, RR_STORAGE));
    (t1 = KindBaseTerm(RlnGetF(relation, RR_KIND), 0));
    (t2 = KindBaseTerm(RlnGetF(relation, RR_KIND), 1));
    if ((t2 == OBJECT_TY)) {
        if ((t1 == OBJECT_TY)) {
            objectloop (obj1 ofclass Object && obj1) {
                objectloop (obj2 ofclass Object && (_final_propertyexists(OBJECT_TY, obj2, relation_property))) {
                    if ((_final_propertyvalue(OBJECT_TY, obj2, relation_property) ~= obj1)) {
                        continue;
                    }
                    if ((x == 0)) {
                        print (string) RlnGetF(relation, RR_DESCRIPTION);
                        print ":^";
                        (x = 1);
                    }
                    print "  ";
                    CDefArt(obj1);
                    print "  >=>  ";
                    DefArt(obj2);
                    print "^";
                }
            }
        } else {
            (N1 = KOVDomainSize(t1));
            for ((obj1 = 1):(obj1 <= N1):(obj1)++) {
                objectloop (obj2 ofclass Object && (_final_propertyexists(OBJECT_TY, obj2, relation_property))) {
                    if ((_final_propertyvalue(OBJECT_TY, obj2, relation_property) ~= obj1)) {
                        continue;
                    }
                    if ((x == 0)) {
                        print (string) RlnGetF(relation, RR_DESCRIPTION);
                        print ":^";
                        (x = 1);
                    }
                    print "  ";
                    PrintKindValuePair(t1, obj1);
                    print "  >=>  ";
                    DefArt(obj2);
                    print "^";
                }
            }
        }
    } else {
        (N2 = KOVDomainSize(t2));
        if ((t1 == OBJECT_TY)) {
            objectloop (obj1 ofclass Object && obj1) {
                for ((obj2 = 1):(obj2 <= N2):(obj2)++) {
                    if ((GProperty(t2, obj2, relation_property) ~= obj1)) {
                        continue;
                    }
                    if ((x == 0)) {
                        print (string) RlnGetF(relation, RR_DESCRIPTION);
                        print ":^";
                        (x = 1);
                    }
                    print "  ";
                    CDefArt(obj1);
                    print "  >=>  ";
                    PrintKindValuePair(t2, obj2);
                    print "^";
                }
            }
        } else {
            (N1 = KOVDomainSize(t1));
            for ((obj1 = 1):(obj1 <= N1):(obj1)++) {
                for ((obj2 = 1):(obj2 <= N2):(obj2)++) {
                    if ((GProperty(t2, obj2, relation_property) ~= obj1)) {
                        continue;
                    }
                    if ((x == 0)) {
                        print (string) RlnGetF(relation, RR_DESCRIPTION);
                        print ":^";
                        (x = 1);
                    }
                    print "  ";
                    PrintKindValuePair(t1, obj1);
                    print "  >=>  ";
                    PrintKindValuePair(t2, obj2);
                    print "^";
                }
            }
        }
    }
];
[ RSE_Flip KOV v relation_property x;
    (x = GProperty(KOV, v, relation_property));
    (x = (-(x)));
    WriteGProperty(KOV, v, relation_property, x);
];
[ RSE_Set KOV v relation_property;
    if ((GProperty(KOV, v, relation_property) < 0)) {
        rtrue;
    }
    rfalse;
];
[ Relation_ShowEquiv relation relation_property obj1 obj2 v c d somegroups t N x;
    print (string) RlnGetF(relation, RR_DESCRIPTION);
    print ":^";
    (relation_property = RlnGetF(relation, RR_STORAGE));
    (t = KindBaseTerm(RlnGetF(relation, RR_KIND), 0));
    (N = KOVDomainSize(t));
    if ((t == OBJECT_TY)) {
        objectloop (obj1 ofclass Object && (_final_propertyexists(OBJECT_TY, obj1, relation_property))) {
            (_final_store_property(OBJECT_TY,obj1,relation_property, (-(_final_propertyvalue(OBJECT_TY, obj1, relation_property)))));
        }
        objectloop (obj1 ofclass Object && (_final_propertyexists(OBJECT_TY, obj1, relation_property))) {
            if ((_final_propertyvalue(OBJECT_TY, obj1, relation_property) < 0)) {
                (v = _final_propertyvalue(OBJECT_TY, obj1, relation_property));
                (c = 0);
                objectloop (obj2 ofclass Object && (obj2 has workflag2)) {
                    give obj2 ~workflag2;
                }
                objectloop (obj2 ofclass Object && (_final_propertyexists(OBJECT_TY, obj2, relation_property))) {
                    if ((_final_propertyvalue(OBJECT_TY, obj2, relation_property) == v)) {
                        give obj2 workflag2;
                        (_final_store_property(OBJECT_TY,obj2,relation_property, (-(v))));
                        (c)++;
                    }
                }
                if ((c > 1)) {
                    (somegroups = 1);
                    print "  { ";
                    WriteListOfMarkedObjects(ENGLISH_BIT);
                    print " }^";
                } else {
                    (_final_store_property(OBJECT_TY,obj1,relation_property, v));
                }
            }
        }
        objectloop (obj2 ofclass Object && (obj2 has workflag2)) {
            give obj2 ~workflag2;
        }
        (c = 0);
        objectloop (obj1 ofclass Object && (_final_propertyexists(OBJECT_TY, obj1, relation_property))) {
            if ((_final_propertyvalue(OBJECT_TY, obj1, relation_property) < 0)) {
                (c)++;
                give obj1 workflag2;
            }
        }
        if ((c == 0)) {
            rtrue;
        }
        if (somegroups) {
            print "  and ";
        } else {
            print "  ";
        }
        if ((c < 4)) {
            WriteListOfMarkedObjects(ENGLISH_BIT);
            print " in";
        } else {
            print c;
        }
        if ((c == 1)) {
            print " a";
        }
        print " single-member group";
        if ((c > 1)) {
            print "s";
        }
        print "^";
        objectloop (obj1 ofclass Object && (_final_propertyexists(OBJECT_TY, obj1, relation_property))) {
            if ((_final_propertyvalue(OBJECT_TY, obj1, relation_property) < 0)) {
                (_final_store_property(OBJECT_TY,obj1,relation_property, (-(_final_propertyvalue(OBJECT_TY, obj1, relation_property)))));
            }
        }
    } else {
        for ((obj1 = 1):(obj1 <= N):(obj1)++) {
            RSE_Flip(t, obj1, relation_property);
        }
        for ((obj1 = 1):(obj1 <= N):(obj1)++) {
            if (RSE_Set(t, obj1, relation_property)) {
                (v = GProperty(t, obj1, relation_property));
                (c = 0);
                for ((obj2 = 1):(obj2 <= N):(obj2)++) {
                    if ((GProperty(t, obj2, relation_property) == v)) {
                        (c)++;
                    }
                }
                if ((c > 1)) {
                    (somegroups = 1);
                    print "  {";
                    (d = 0);
                    for ((obj2 = 1):(obj2 <= N):(obj2)++) {
                        if ((GProperty(t, obj2, relation_property) == v)) {
                            print " ";
                            PrintKindValuePair(t, obj2);
                            if ((d < (c - 1))) {
                                print ",";
                            }
                            print " ";
                            RSE_Flip(t, obj2, relation_property);
                            (d)++;
                        }
                    }
                    print "}^";
                } else {
                    WriteGProperty(t, obj1, relation_property, v);
                }
            }
        }
        objectloop (obj2 ofclass Object && (obj2 has workflag2)) {
            give obj2 ~workflag2;
        }
        (c = 0);
        for ((obj1 = 1):(obj1 <= N):(obj1)++) {
            if (RSE_Set(t, obj1, relation_property)) {
                (c)++;
            }
        }
        if ((c == 0)) {
            rtrue;
        }
        if (somegroups) {
            print "  and ";
        } else {
            print "  ";
        }
        if ((c == 1)) {
            print "a";
        } else {
            print c;
        }
        print " single-member group";
        if ((c > 1)) {
            print "s";
        }
        print "^";
        for ((obj1 = 1):(obj1 <= N):(obj1)++) {
            if (RSE_Set(t, obj1, relation_property)) {
                RSE_Flip(t, obj1, relation_property);
            }
        }
    }
];
[ Relation_EmptyOtoO relation sym clear relation_property obj1 obj2 t1 t2 N1 N2;
    (relation_property = RlnGetF(relation, RR_STORAGE));
    (t1 = KindBaseTerm(RlnGetF(relation, RR_KIND), 0));
    (t2 = KindBaseTerm(RlnGetF(relation, RR_KIND), 1));
    if ((t2 == OBJECT_TY)) {
        objectloop (obj2 ofclass Object && (_final_propertyexists(OBJECT_TY, obj2, relation_property))) {
            (obj1 = _final_propertyvalue(OBJECT_TY, obj2, relation_property));
            if (obj1) {
                if (clear) {
                    (_final_store_property(OBJECT_TY,obj2,relation_property, 0));
                } else {
                    rfalse;
                }
            }
        }
    } else {
        for ((obj2 = 1):(obj2 <= N2):(obj2)++) {
            (obj1 = GProperty(t2, obj2, relation_property));
            if (obj1) {
                if (clear) {
                    WriteGProperty(t2, obj2, relation_property, 0);
                } else {
                    rfalse;
                }
            }
        }
    }
    if ((t1 ~= t2)) {
        if ((t1 == OBJECT_TY)) {
            objectloop (obj1 ofclass Object && (_final_propertyexists(OBJECT_TY, obj1, relation_property))) {
                (obj2 = _final_propertyvalue(OBJECT_TY, obj1, relation_property));
                if (obj2) {
                    if (clear) {
                        (_final_store_property(OBJECT_TY,obj1,relation_property, 0));
                    } else {
                        rfalse;
                    }
                }
            }
        } else {
            for ((obj1 = 1):(obj1 <= N2):(obj1)++) {
                (obj2 = GProperty(t1, obj1, relation_property));
                if (obj2) {
                    if (clear) {
                        WriteGProperty(t1, obj1, relation_property, 0);
                    } else {
                        rfalse;
                    }
                }
            }
        }
    }
    rtrue;
];
[ Relation_EmptyEquiv relation sym clear relation_property obj1 obj2 t N v;
    (relation_property = RlnGetF(relation, RR_STORAGE));
    (t = KindBaseTerm(RlnGetF(relation, RR_KIND), 0));
    (N = KOVDomainSize(t));
    if (clear) {
        (v = 1);
        if ((t == OBJECT_TY)) {
            objectloop (obj1 ofclass Object && (_final_propertyexists(OBJECT_TY, obj1, relation_property))) {
                (_final_store_property(OBJECT_TY,obj1,relation_property, (v)++));
            }
        } else {
            for ((obj1 = 1):(obj1 <= N):(obj1)++) {
                WriteGProperty(t, obj1, relation_property, (v)++);
            }
        }
        rtrue;
    }
    if ((t == OBJECT_TY)) {
        objectloop (obj1 ofclass Object && (_final_propertyexists(OBJECT_TY, obj1, relation_property))) {
            objectloop (obj2 ofclass Object && (_final_propertyexists(OBJECT_TY, obj2, relation_property))) {
                if ((((obj1 < obj2)) && ((_final_propertyvalue(OBJECT_TY, obj1, relation_property) == _final_propertyvalue(OBJECT_TY, obj2, relation_property))))) {
                    rfalse;
                }
            }
        }
    } else {
        for ((obj1 = 1):(obj1 <= N):(obj1)++) {
            for ((obj2 = (obj1 + 1)):(obj1 <= N):(obj1)++) {
                if ((GProperty(t, obj1, relation_property) == GProperty(t, obj2, relation_property))) {
                    rfalse;
                }
            }
        }
    }
    rtrue;
];
[ Relation_EmptyVtoV relation sym clear vtov_structure obj1 obj2 pr pr2 proutine1 proutine2;
    (vtov_structure = RlnGetF(relation, RR_STORAGE));
    (pr = (vtov_structure-->(VTOVS_LEFT_INDEX_PROP)));
    (pr2 = (vtov_structure-->(VTOVS_RIGHT_INDEX_PROP)));
    (proutine1 = (vtov_structure-->(VTOVS_LEFT_PRINTING_ROUTINE)));
    (proutine2 = (vtov_structure-->(VTOVS_RIGHT_PRINTING_ROUTINE)));
    if (((pr) && (pr2))) {
        objectloop (obj1 ofclass Object && (_final_propertyexists(OBJECT_TY, obj1, pr))) {
            objectloop (obj2 ofclass Object && (_final_propertyexists(OBJECT_TY, obj2, pr2))) {
                if (((sym) && ((obj2 > obj1)))) {
                    continue;
                }
                if (Relation_TestVtoV(obj1, relation, obj2)) {
                    if (clear) {
                        Relation_NowNVtoV(obj1, relation, obj2, sym);
                    } else {
                        rfalse;
                    }
                }
            }
        }
        rtrue;
    }
    if (((pr) && ((pr2 == 0)))) {
        objectloop (obj1 ofclass Object && (_final_propertyexists(OBJECT_TY, obj1, pr))) {
            for ((obj2 = 1):(obj2 <= (vtov_structure-->(VTOVS_RIGHT_DOMAIN_SIZE))):(obj2)++) {
                if (Relation_TestVtoV(obj1, relation, obj2)) {
                    if (clear) {
                        Relation_NowNVtoV(obj1, relation, obj2, sym);
                    } else {
                        rfalse;
                    }
                }
            }
        }
        rtrue;
    }
    if ((((pr == 0)) && (pr2))) {
        for ((obj1 = 1):(obj1 <= (vtov_structure-->(2))):(obj1)++) {
            objectloop (obj2 ofclass Object && (_final_propertyexists(OBJECT_TY, obj2, pr2))) {
                if (Relation_TestVtoV(obj1, relation, obj2)) {
                    if (clear) {
                        Relation_NowNVtoV(obj1, relation, obj2, sym);
                    } else {
                        rfalse;
                    }
                }
            }
        }
        rtrue;
    }
    for ((obj1 = 1):(obj1 <= (vtov_structure-->(2))):(obj1)++) {
        for ((obj2 = 1):(obj2 <= (vtov_structure-->(VTOVS_RIGHT_DOMAIN_SIZE))):(obj2)++) {
            if (Relation_TestVtoV(obj1, relation, obj2)) {
                if (Relation_TestVtoV(obj1, relation, obj2)) {
                    if (clear) {
                        Relation_NowNVtoV(obj1, relation, obj2, sym);
                    } else {
                        rfalse;
                    }
                }
            }
        }
    }
    rtrue;
];
[ RelationRouteTo relation from to count handler;
    if (count) {
        if ((from == 0)) {
            return (-(1));
        }
        if ((to == 0)) {
            return (-(1));
        }
        if ((relation == 0)) {
            return (-(1));
        }
    } else {
        if ((from == 0)) {
            rfalse;
        }
        if ((to == 0)) {
            rfalse;
        }
        if ((relation == 0)) {
            rfalse;
        }
    }
    if ((from == to)) {
        rfalse;
    }
    if ((((RlnGetF(relation, RR_PERMISSIONS))&(RELS_ROUTE_FIND)) == 0)) {
        RunTimeProblem(RTP_ROUTELESS);
        rfalse;
    }
    if ((RlnGetF(relation, RR_STORAGE) == 0)) {
        rfalse;
    }
    (handler = RlnGetF(relation, RR_HANDLER));
    if (count) {
        return (handler)(relation,RELS_ROUTE_FIND_COUNT,from,to);
    }
    return (handler)(relation,RELS_ROUTE_FIND,from,to);
];
[ RelFollowVector rv from to obj i;
    if ((rv == 0)) {
        return (-(1));
    }
    (i = 0);
    (obj = from);
    while ((((obj ~= to)) && ((i <= MAX_ROUTE_LENGTH)))) {
        (i)++;
        (obj = (obj.vector));
    }
    return i;
];
[ OtoVRelRouteTo relation_property from to previous;
    while (((((to) && ((_final_propertyexists(OBJECT_TY, to, relation_property))))) && (_final_propertyvalue(OBJECT_TY, to, relation_property)))) {
        (previous = _final_propertyvalue(OBJECT_TY, to, relation_property));
        ((previous.vector) = to);
        if ((previous == from)) {
            return to;
        }
        (to = previous);
    }
    rfalse;
];
[ VtoORelRouteTo relation_property from to next start;
    (start = from);
    while (((((from) && ((_final_propertyexists(OBJECT_TY, from, relation_property))))) && (_final_propertyvalue(OBJECT_TY, from, relation_property)))) {
        (next = _final_propertyvalue(OBJECT_TY, from, relation_property));
        ((from.vector) = next);
        if ((next == to)) {
            return (start.vector);
        }
        (from = next);
    }
    rfalse;
];
[ VtoVRelRouteTo relation from to count obj obj2 related progressed left_ix pr2 i vtov_structure;
    (vtov_structure = RlnGetF(relation, RR_STORAGE));
    if ((vtov_structure-->(VTOVS_CACHE))) {
        return FastVtoVRelRouteTo(relation, from, to, count);
    }
    (left_ix = (vtov_structure-->(VTOVS_LEFT_INDEX_PROP)));
    (pr2 = (vtov_structure-->(VTOVS_RIGHT_INDEX_PROP)));
    objectloop (obj ofclass Object && (((obj ofclass Object)) && ((_final_propertyexists(OBJECT_TY, obj, A_vector))))) {
        ((obj.vector) = 0);
    }
    ((to.vector) = 1);
    while (1) {
        (progressed = 0);
        objectloop (obj ofclass Object && (((obj ofclass Object)) && ((_final_propertyexists(OBJECT_TY, obj, left_ix))))) {
            if (((obj.vector) == 0)) {
                objectloop (obj2 ofclass Object && (((((obj2 ofclass Object)) && ((_final_propertyexists(OBJECT_TY, obj2, pr2))))) && (((obj2.vector) > 0)))) {
                    if (Relation_TestVtoV(obj, relation, obj2)) {
                        ((obj.vector) = ((obj2)|(WORD_HIGHBIT)));
                        (progressed = 1);
                        continue;
                    }
                }
            }
        }
        objectloop (obj ofclass Object && (((obj ofclass Object)) && ((_final_propertyexists(OBJECT_TY, obj, left_ix))))) {
            ((obj.vector) = (((obj.vector))&((~(WORD_HIGHBIT)))));
        }
        if ((from.vector)) {
            break;
        }
        if ((progressed == 0)) {
            break;
        }
    }
    if (count) {
        if (((from.vector) == 0)) {
            return (-(1));
        }
        (i = 0);
        (obj = from);
        while ((((obj ~= to)) && ((i <= MAX_ROUTE_LENGTH)))) {
            (i)++;
            (obj = (obj.vector));
        }
        return i;
    }
    return (from.vector);
];
[ FastVtoVRelRouteTo relation from to count domainsize cache cache2 left_ix ox oy oj offset axy axj ayj;
    (domainsize = (RlnGetF(relation, RR_STORAGE)-->(2)));
    (left_ix = (RlnGetF(relation, RR_STORAGE)-->(VTOVS_LEFT_INDEX_PROP)));
    if ((((_final_propertyexists(OBJECT_TY, from, left_ix))) && ((_final_propertyexists(OBJECT_TY, to, left_ix))))) {
        if ((domainsize < 256)) {
            (cache = (RlnGetF(relation, RR_STORAGE)-->(VTOVS_CACHE)));
            (cache2 = (cache + (domainsize*domainsize)));
            if (((RlnGetF(relation, RR_STORAGE)-->(VTOVS_CACHE_BROKEN)) == 1)) {
                ((RlnGetF(relation, RR_STORAGE)-->(VTOVS_CACHE_BROKEN)) = 0);
                objectloop (oy ofclass Object && (_final_propertyexists(OBJECT_TY, oy, left_ix))) {
                    objectloop (ox ofclass Object && (_final_propertyexists(OBJECT_TY, ox, left_ix))) {
                        if (Relation_TestVtoV(oy, relation, ox)) {
                            (offset = ((_final_propertyvalue(OBJECT_TY, oy, left_ix)*domainsize) + _final_propertyvalue(OBJECT_TY, ox, left_ix)));
                            ((cache->(offset)) = 1);
                            ((cache2->(offset)) = _final_propertyvalue(OBJECT_TY, ox, left_ix));
                        } else {
                            (offset = ((_final_propertyvalue(OBJECT_TY, oy, left_ix)*domainsize) + _final_propertyvalue(OBJECT_TY, ox, left_ix)));
                            ((cache->(offset)) = 0);
                            ((cache2->(offset)) = 255);
                        }
                    }
                }
                for ((oy = 0):(oy < domainsize):(oy)++) {
                    for ((ox = 0):(ox < domainsize):(ox)++) {
                        (axy = (cache->(((ox*domainsize) + oy))));
                        if ((axy > 0)) {
                            for ((oj = 0):(oj < domainsize):(oj)++) {
                                (ayj = (cache->(((oy*domainsize) + oj))));
                                if ((ayj > 0)) {
                                    (offset = ((ox*domainsize) + oj));
                                    (axj = (cache->(offset)));
                                    if ((((axj == 0)) || (((axy + ayj) < axj)))) {
                                        ((cache->(offset)) = (axy + ayj));
                                        ((cache2->(offset)) = (cache2->(((ox*domainsize) + oy))));
                                    }
                                }
                            }
                        }
                    }
                }
            }
            if (count) {
                (count = (cache->(((_final_propertyvalue(OBJECT_TY, from, left_ix)*domainsize) + _final_propertyvalue(OBJECT_TY, to, left_ix)))));
                if ((count == 0)) {
                    return (-(1));
                }
                return count;
            }
            (oy = (cache2->(((_final_propertyvalue(OBJECT_TY, from, left_ix)*domainsize) + _final_propertyvalue(OBJECT_TY, to, left_ix)))));
            if ((oy < 255)) {
                objectloop (ox ofclass Object && (_final_propertyexists(OBJECT_TY, ox, left_ix))) {
                    if ((_final_propertyvalue(OBJECT_TY, ox, left_ix) == oy)) {
                        return ox;
                    }
                }
            }
            rfalse;
        } else {
            (cache = (RlnGetF(relation, RR_STORAGE)-->(VTOVS_CACHE)));
            (cache2 = (cache + ((WORDSIZE*domainsize)*domainsize)));
            if (((RlnGetF(relation, RR_STORAGE)-->(VTOVS_CACHE_BROKEN)) == 1)) {
                ((RlnGetF(relation, RR_STORAGE)-->(VTOVS_CACHE_BROKEN)) = 0);
                objectloop (oy ofclass Object && (_final_propertyexists(OBJECT_TY, oy, left_ix))) {
                    objectloop (ox ofclass Object && (_final_propertyexists(OBJECT_TY, ox, left_ix))) {
                        if (Relation_TestVtoV(oy, relation, ox)) {
                            (offset = ((_final_propertyvalue(OBJECT_TY, oy, left_ix)*domainsize) + _final_propertyvalue(OBJECT_TY, ox, left_ix)));
                            ((cache-->(offset)) = 1);
                            ((cache2-->(offset)) = ox);
                        } else {
                            (offset = ((_final_propertyvalue(OBJECT_TY, oy, left_ix)*domainsize) + _final_propertyvalue(OBJECT_TY, ox, left_ix)));
                            ((cache-->(offset)) = 0);
                            ((cache2-->(offset)) = 0);
                        }
                    }
                }
                for ((oy = 0):(oy < domainsize):(oy)++) {
                    for ((ox = 0):(ox < domainsize):(ox)++) {
                        (axy = (cache-->(((ox*domainsize) + oy))));
                        if ((axy > 0)) {
                            for ((oj = 0):(oj < domainsize):(oj)++) {
                                (ayj = (cache-->(((oy*domainsize) + oj))));
                                if ((ayj > 0)) {
                                    (offset = ((ox*domainsize) + oj));
                                    (axj = (cache-->(offset)));
                                    if ((((axj == 0)) || (((axy + ayj) < axj)))) {
                                        ((cache-->(offset)) = (axy + ayj));
                                        ((cache2-->(offset)) = (cache2-->(((ox*domainsize) + oy))));
                                    }
                                }
                            }
                        }
                    }
                }
            }
            if (count) {
                (count = (cache-->(((_final_propertyvalue(OBJECT_TY, from, left_ix)*domainsize) + _final_propertyvalue(OBJECT_TY, to, left_ix)))));
                if ((count == 0)) {
                    return (-(1));
                }
                return count;
            }
            return (cache2-->(((_final_propertyvalue(OBJECT_TY, from, left_ix)*domainsize) + _final_propertyvalue(OBJECT_TY, to, left_ix))));
        }
    }
    if (count) {
        return (-(1));
    }
    rfalse;
];
[ RunTimeProblem n par1 par2 par3 ln file;
    if (((RTP_Buffer-->(0)) == -1)) {
        ((RTP_Buffer-->(0)) = n);
        ((RTP_Buffer-->(1)) = par1);
        ((RTP_Buffer-->(2)) = par2);
        ((RTP_Buffer-->(3)) = par3);
        ((RTP_Buffer-->(4)) = ln);
        ((RTP_Buffer-->(5)) = file);
    }
    RunTimeProblemShow();
];
[ ClearRTP;
    ((RTP_Buffer-->(0)) = -1);
    ((RTP_Buffer-->(6)) = 0);
];
[ SuspendRTP;
    ((RTP_Buffer-->(6)) = 1);
];
[ ResumeRTP;
    ((RTP_Buffer-->(6)) = 0);
];
[ RunTimeProblemShow n par1 par2 par3 ln file i c;
    if (((RTP_Buffer-->(0)) == -1 or -2)) {
        rtrue;
    }
    if ((RTP_Buffer-->(6))) {
        rtrue;
    }
    (n = (RTP_Buffer-->(0)));
    (par1 = (RTP_Buffer-->(1)));
    (par2 = (RTP_Buffer-->(2)));
    (par3 = (RTP_Buffer-->(3)));
    (ln = (RTP_Buffer-->(4)));
    (file = (RTP_Buffer-->(5)));
    ((RTP_Buffer-->(0)) = -2);
    print "^";
    print "*** Run-time problem P";
    print n;
    if (ln) {
        print " (at paragraph ";
        print ln;
        print " in ";
        if ((file == 0)) {
            print "the source text";
        } else {
            ShowOneExtension(file);
        }
        print ")";
    }
    print ": ";
    switch (n) {
        RTP_IMPREL:
            print "Tried to access an inappropriate relation for ";
            DefArt(par1);
            print ", violating '";
            print (string) RlnGetF(par2, RR_DESCRIPTION);
            print "'.^";
            ;
        RTP_TOOMANYRULEBOOKS:
            print "Too many rulebooks in simultaneous use.^";
            ;
        RTP_BADPROPERTY:
            print "Tried to access non-existent property for ";
            DefArt(par1);
            print ".^";
            ;
        RTP_UNPROVIDED:
            print "Since ";
            DefArt(par1);
            print " is not allowed the property ~";
            PrintPropertyName(par2);
            print "~, it is against the rules to try to use it.^";
            ;
        RTP_UNSET:
            print "Although ";
            DefArt(par1);
            print " is allowed to have the property ~";
            PrintPropertyName(par2);
            print "~, no value was ever given, so it can't now be used.^";
            ;
        RTP_TOOMANYACTS:
            print "Too many activities are going on at once.^";
            ;
        RTP_CANTABANDON:
            print "Tried to abandon an activity which wasn't going on.^";
            ;
        RTP_CANTEND:
            print "Tried to end an activity which wasn't going on.^";
            ;
        RTP_DIVZERO:
            print "You can't divide by zero.^";
            ;
        RTP_BADVALUEPROPERTY:
            print "Tried to access property for a value which didn't fit: ";
            print "if this were a number it would be ";
            print par1;
            print ".^";
            ;
        RTP_TABLE_NOCOL:
            print "Attempt to look up a non-existent column in the table '";
            PrintTableName(par1);
            print "'.^";
            ;
        RTP_TABLE_NOCORR:
            print "Attempt to look up a non-existent correspondence in the table '";
            PrintTableName(par1);
            print "'.^";
            ;
        RTP_TABLE_NOROW:
            print "Attempt to look up a non-existent row in the table '";
            PrintTableName(par1);
            print "'.^";
            ;
        RTP_TABLE_NOENTRY:
            print "Attempt to look up a non-existent entry at column ";
            print par2;
            print ", row ";
            print par3;
            print " of the table '";
            PrintTableName(par1);
            print "'.^";
            ;
        RTP_TABLE_NOTABLE:
            print "Attempt to blank out a row from a non-existent table (value ";
            print par1;
            print ").^";
            ;
        RTP_TABLE_NOTABLE2:
            print "Attempt to access an entry from a non-existent table.^";
            ;
        RTP_TABLE_NOMOREBLANKS:
            print "Attempt to choose a blank row in a table with none left: table '";
            PrintTableName(par1);
            print "'.^";
            ;
        RTP_TABLE_NOROWS:
            print "Attempt to choose a random row in an entirely blank table: table '";
            PrintTableName(par1);
            print "'.^";
            ;
        RTP_TABLE_CANTRUNTHROUGH:
            print "Attempt to repeat through a table in a tricky column order: table '";
            PrintTableName(par1);
            print "'.^";
            ;
        RTP_TABLE_CANTSORT:
            print "Attempt to sort a table whose ordering must remain fixed: table '";
            PrintTableName(par1);
            print "'.^";
            ;
        RTP_TABLE_CANTSAVE:
            print "Attempt to save a table to a file whose data is unstable: table '";
            PrintTableName(par1);
            print "'.^";
            ;
        RTP_TABLE_WONTFIT:
            print "File being read has too many rows or columns to fit into table: table '";
            PrintTableName(par1);
            print "'.^";
            ;
        RTP_TABLE_BADFILE:
            print "File being read is not a previously saved table: table '";
            PrintTableName(par1);
            print "'.^";
            ;
        RTP_ROUTELESS:
            print "Attempt to find route or count steps through an implicit relation.^";
            ;
        RTP_PROPOFNOTHING:
            print "Attempt to use a property of the 'nothing' non-object: property ";
            PrintPropertyName(par2);
            print "^";
            ;
        RTP_DECIDEONWRONGKIND:
            print "Attempt to 'decide on V' where V is the wrong kind of object.^";
            ;
        RTP_DECIDEONNOTHING:
            print "Attempt to 'decide on nothing'.^";
            ;
        RTP_LOWLEVELERROR:
            print "Low level error.^";
            ;
        RTP_LISTWRITERMEMORY:
            print "The list-writer has run out of memory.^";
            ;
        RTP_MSTACKMEMORY:
            print "The memory stack is exhausted.^";
            ;
        RTP_TYPECHECK:
            print "Phrase applied to an incompatible kind of value.^";
            ;
        RTP_FILEIOERROR:
            print "Error handling external file.^";
            ;
        RTP_HEAPERROR:
            print "Memory allocation proved impossible.^";
            ;
        RTP_LISTRANGEERROR:
            print "Attempt to use list item which does not exist.^";
            ;
        RTP_LISTSIZENEGATIVE:
            print "Attempt to resize list to ";
            print par1;
            print " entries - there must ";
            print "always be 0 or more.^";
            ;
        RTP_REGEXPSYNTAXERROR:
            print "Syntax error in regular expression.^";
            ;
        RTP_NOGLULXUNICODE:
            print "This interpreter does not support Unicode.^";
            ;
        RTP_NEGATIVEROOT:
            print "You can't take the square root of a negative number.^";
            ;
        RTP_CANTITERATE:
            print "You can't implicitly repeat through the values of this kind: ";
            print "a problem arising from a description which started out here - ~";
            print (string) par1;
            print "~.^";
            ;
        RTP_WRONGASSIGNEDKIND:
            print "Attempt to set a variable to the wrong kind of object: ";
            print "you wrote '";
            print (string) par2;
            print "', which sets the value to ";
            DefArt(par1);
            print " - but that doesn't have the kind '";
            print (string) par3;
            print "'.^";
            ;
        RTP_RELKINDVIOLATION:
            print "Tried to change a relation for objects with the wrong kinds: ";
            print (string) RlnGetF(par3, RR_DESCRIPTION);
            print ", but you tried to ";
            print "relate (or unrelate) ";
            DefArt(par1);
            print " to ";
            DefArt(par2);
            print ".^";
            ;
        RTP_TEXTTOKENTOOHARD:
            print "This use of '[text]' is too complicated.^";
            ;
        RTP_RELATIONCHANGEIMPOSSIBLE:
            print "This change of the relation's nature is impossible in play.^";
            ;
        RTP_RELMINIMAL:
            print "This operation can't be done with the relation '";
            print (string) RlnGetF(par3, RR_DESCRIPTION);
            print "'.^";
            ;
    }
    RunTimeProblemShowWM(n, par1, par2, par3);
    print "^";
];
[ RunTimeError n p1 p2;
    print "** Library error ";
    print n;
    print " (";
    print p1;
    print ",";
    print p2;
    print ") **^** ";
    switch (n) {
        1:
            print "preposition not found (this should not occur)";
            ;
        2:
            print "Property value not routine or string: ~";
            DebugProperty(p2);
            print "~ of ~";
            PrintShortName(p1);
            print "~ (";
            print p1;
            print ")";
            ;
        3:
            print "Entry in property list not routine or string: ~";
            DebugProperty(p2);
            print "~ list of ~";
            PrintShortName(p1);
            print "~ (";
            print p1;
            print ")";
            ;
        4:
            print "Too many timers/daemons are active simultaneously. The limit is the library constant MAX_TIMERS (currently ";
            print MAX_TIMERS;
            print ") and should be increased";
            ;
        5:
            print "Object ~";
            PrintShortName(p1);
            print "~ has no ~time_left~ property";
            ;
        7:
            print "The object ~";
            PrintShortName(p1);
            print "~ can only be used as a player object if it has the ~number~ property";
            ;
        8:
            print "Attempt to take random entry from an empty table array";
            ;
        9:
            print p1;
            print " is not a valid direction property number";
            ;
        10:
            print "The player-object is outside the object tree";
            ;
        11:
            print "The room ~";
            PrintShortName(p1);
            print "~ has no ~description~ property";
            ;
        12:
            print "Tried to set a non-existent pronoun using SetPronoun";
            ;
        13:
            print "A 'topic' token can only be followed by a preposition";
            ;
        default:
            print "(unexplained)";
            ;
    }
    print " **^";
    RunTimeProblem(RTP_LOWLEVELERROR);
];
[ ArgumentTypeFailed line file;
    RunTimeProblem(RTP_TYPECHECK, 0, 0, 0, line, file);
];
[ CheckKindReturned V K;
    if ((V ofclass K)) {
        return V;
    }
    if ((V == 0)) {
        RunTimeProblem(RTP_DECIDEONNOTHING);
    } else {
        RunTimeProblem(RTP_DECIDEONWRONGKIND);
    }
    return V;
];
[ ProvidesProperty K obj q issue_rtp a l holder;
    if ((K == OBJECT_TY)) {
        if (ScanPropertyMetadata(obj, q, 4)) {
            jump PermissionFound;
        }
        if ((_final_propertyexists(OBJECT_TY, obj, A_KD_Count))) {
            (l = (obj.KD_Count));
            while ((l > 0)) {
                (a = (l*2));
                if (ScanPropertyMetadata((KindHierarchy-->(a)), q, 4)) {
                    jump PermissionFound;
                }
                (l = (KindHierarchy-->((a + 1))));
            }
        }
        if (ScanPropertyMetadata(K0_kind, q, 4)) {
            jump PermissionFound;
        }
        if (issue_rtp) {
            RunTimeProblem(RTP_UNPROVIDED, obj, q);
        }
        rfalse;
    }
    .PermissionFound;
    if ((_final_propertyexists(K, obj, q))) {
        rtrue;
    }
    if (issue_rtp) {
        RunTimeProblem(RTP_UNSET, obj, q);
    }
    rfalse;
];
[ PrintPropertyName p textual;
    if ((p < 0)) {
        (p = (~(p)));
    }
    (textual = (p-->(3)));
    print (string) textual;
];
[ ScanPropertyMetadata obj property_metadata off i;
    for ((i = off):((property_metadata-->(i)) >= 0):(i)++) {
        if ((obj == (property_metadata-->(i)))) {
            rtrue;
        }
    }
    rfalse;
];
[ GProperty K V pr err holder val;
    if (ProvidesProperty(K, V, pr, (1 - err))) {
        return _final_propertyvalue(K, V, pr);
    }
    rfalse;
];
[ WriteGProperty K V pr val holder;
    if (ProvidesProperty(K, V, pr, 1)) {
        (_final_store_property(K,V,pr, val));
    }
];
[ PROPERTY_TY_Say v;
    print "property ";
    print v;
];
[ LanguageTimeOfDay hours mins i;
    (i = (hours%12));
    if ((i == 0)) {
        (i = 12);
    }
    if ((i < 10)) {
        print " ";
    }
    print i;
    print ":";
    print (mins/10);
    print (mins%10);
    if (((hours/12) > 0)) {
        print " pm";
    } else {
        print " am";
    }
];
[ LanguageDirection d;
    PrintShortName(d);
];
[ LanguageToInformese;
];
[ LanguageContraction text;
    if (((text->(0)) == 97 or 101 or 105 or 111 or 117 or 65 or 69 or 73 or 79 or 85)) {
        rtrue;
    }
    rfalse;
];
[ LanguageVerb i;
    switch (i) {
        'i//', 'inv', 'inventory':
            print "take inventory";
            ;
        'l//':
            print "look";
            ;
        'x//':
            print "examine";
            ;
        'z//':
            print "wait";
            ;
        default:
            rfalse;
            ;
    }
    rtrue;
];
[ LanguageVerbLikesAdverb w;
    if ((w == 'look' or 'go' or 'push' or 'walk')) {
        rtrue;
    }
    rfalse;
];
[ LanguageVerbMayBeName w;
    if ((w == 'long' or 'short' or 'normal' or 'brief' or 'full' or 'verbose')) {
        rtrue;
    }
    rfalse;
];
[ LanguageIsVerb buffer parse verb_wordnum;
    rfalse;
];
[ DefaultTopic;
    rfalse;
];
[ PrintSnippet x;
];
[ LIST_WRITER_INTERNAL_RM x;
    print " and ";
];
[ RunTimeProblemShowWM n x y z;
];
[ OwnerOf o;
    rfalse;
];
[ MoveObject from to;
];
[ WriteListOfMarkedObjects in_style obj c;
    objectloop (obj ofclass Object && (((obj ofclass Object)) && ((obj has workflag2)))) {
        (c)++;
    }
    objectloop (obj ofclass Object && (((obj ofclass Object)) && ((obj has workflag2)))) {
        PrintShortName(obj);
        (c)--;
        if ((c > 0)) {
            print ", ";
        }
    }
];
[ Main;
    #ifdef TARGET_ZCODE; max_z_object = #largest_object - 255; #endif;
    (self = COL_HSIZE);
    VM_Initialise();
    INITIALISE_MEMORY_R();
    SEED_RANDOM_NUMBER_GENERATOR_R();
    Submain();
];
[ INITIALISE_MEMORY_R;
    VM_PreInitialise();
    HeapInitialise();
    StackFramingInitialise();
    CreateDynamicRelations();
    rfalse;
];
[ DrawStatusLine width posb;
];
[ CPrintOrRun obj prop v length i;
    if ((((obj ofclass String or Routine)) || ((prop == 0)))) {
        VM_PrintToBuffer(StorageForShortName, 160, obj);
    } else {
        if ((_final_propertyvalue(OBJECT_TY, obj, prop) == NULL)) {
            rfalse;
        }
        if ((metaclass(_final_propertyvalue(OBJECT_TY, obj, prop)) == Routine or String)) {
            VM_PrintToBuffer(StorageForShortName, 160, obj, prop);
        } else {
            return RunTimeError(2, obj, prop);
        }
    }
    (length = (StorageForShortName-->(0)));
    ((StorageForShortName->(WORDSIZE)) = VM_LowerToUpperCase((StorageForShortName->(WORDSIZE))));
    for ((i = WORDSIZE):(i < (length + WORDSIZE)):(i)++) {
        print (char) (StorageForShortName->(i));
    }
    if ((i > WORDSIZE)) {
        (say__p = 1);
    }
    rtrue;
];
[ Cap str nocaps;
    if (nocaps) {
        print (string) str;
    } else {
        CPrintOrRun(str, 0);
    }
];
[ PSN__ o;
    if ((o == 0)) {
        LIST_WRITER_INTERNAL_RM(89);
        rtrue;
    }
    switch (metaclass(o)) {
        Routine:
            print "<routine ";
            print o;
            print ">";
            rtrue;
            ;
        String:
            print "<string ~";
            print (string) o;
            print "~>";
            rtrue;
            ;
        0:
            print "<illegal object number ";
            print o;
            print ">";
            rtrue;
            ;
    }
    RegardingSingleObject(o);
    CarryOutActivity(PRINTING_THE_NAME_ACT, o);
];
[ PrintShortName obj i;
    (i = indef_mode);
    (indef_mode = NULL);
    PSN__(obj);
    (indef_mode = i);
];
[ STANDARD_NAME_PRINTING_R obj;
    (obj = parameter_value);
    if ((obj == 0)) {
        LIST_WRITER_INTERNAL_RM(89);
        rtrue;
    }
    switch (metaclass(obj)) {
        Routine:
            print "<routine ";
            print obj;
            print ">";
            rtrue;
            ;
        String:
            print "<string ~";
            print (string) obj;
            print "~>";
            rtrue;
            ;
        0:
            print "<illegal object number ";
            print obj;
            print ">";
            rtrue;
            ;
    }
    if (((((indef_mode) && ((_final_propertyexists(OBJECT_TY, obj, A_short_name_indef))))) && ((PrintOrRun(obj, A_short_name_indef, 1) ~= 0)))) {
        rtrue;
    }
    if (((((caps_mode) && ((_final_propertyexists(OBJECT_TY, obj, cap_short_name))))) && ((PrintOrRun(obj, cap_short_name, 1) ~= 0)))) {
        (caps_mode = 0);
        rtrue;
    }
    if ((((_final_propertyexists(OBJECT_TY, obj, A_short_name))) && ((PrintOrRun(obj, A_short_name, 1) ~= 0)))) {
        rtrue;
    }
    print (object) obj;
];
[ STANDARD_PLURAL_NAME_PRINTING_R obj;
    (obj = parameter_value);
    PrintOrRun(obj, A_plural, 1);
];
[ PrefaceByArticle obj acode pluralise capitalise i artform findout artval;
    if ((_final_propertyexists(OBJECT_TY, obj, A_articles))) {
        (artval = ((_final_propertyarray(OBJECT_TY, obj, A_articles))-->((acode + (short_name_case*LanguageCases)))));
        if (capitalise) {
            Cap(artval);
        } else {
            print (string) artval;
        }
        if (pluralise) {
            rtrue;
        }
        PSN__(obj);
        rtrue;
    }
    (i = GetGNAOfObject(obj));
    if (pluralise) {
        if ((((i < 3)) || ((((i >= 6)) && ((i < 9)))))) {
            (i = (i + 3));
        }
    }
    (i = (LanguageGNAsToArticles-->(i)));
    (artform = (LanguageArticles + (((3*WORDSIZE)*LanguageContractionForms)*(short_name_case + (i*LanguageCases)))));
    switch (LanguageContractionForms) {
        2:
            if (((artform-->(acode)) ~= (artform-->((acode + 3))))) {
                (findout = 1);
            }
            ;
        3:
            if (((artform-->(acode)) ~= (artform-->((acode + 3))))) {
                (findout = 1);
            }
            if (((artform-->((acode + 3))) ~= (artform-->((acode + 6))))) {
                (findout = 1);
            }
            ;
        4:
            if (((artform-->(acode)) ~= (artform-->((acode + 3))))) {
                (findout = 1);
            }
            if (((artform-->((acode + 3))) ~= (artform-->((acode + 6))))) {
                (findout = 1);
            }
            if (((artform-->((acode + 6))) ~= (artform-->((acode + 9))))) {
                (findout = 1);
            }
            ;
        default:
            (findout = 1);
            ;
    }
    if (findout) {
        if (pluralise) {
            Glulx_PrintAnyToArray(StorageForShortName, 160, EnglishNumber, pluralise);
        } else {
            Glulx_PrintAnyToArray(StorageForShortName, 160, PSN__, obj);
        }
        (acode = (acode + (3*LanguageContraction(StorageForShortName))));
    }
    Cap((artform-->(acode)), (~~(capitalise)));
    if (pluralise) {
        rtrue;
    }
    PSN__(obj);
];
[ IndefArt obj i s;
    if ((obj == 0)) {
        LIST_WRITER_INTERNAL_RM(89);
        rtrue;
    }
    (i = indef_mode);
    (indef_mode = 1);
    (s = self);
    (self = obj);
    if ((obj has proper)) {
        (indef_mode = NULL);
        PSN__(obj);
        (indef_mode = i);
        (self = s);
        rtrue;
    }
    if ((((_final_propertyexists(OBJECT_TY, obj, A_article))) && ((TEXT_TY_Compare((obj.article), EMPTY_TEXT_VALUE) ~= 0)))) {
        PrintOrRun(obj, A_article, 1);
        print " ";
        PSN__(obj);
        (indef_mode = i);
        (self = s);
        rtrue;
    }
    PrefaceByArticle(obj, 2);
    (indef_mode = i);
    (self = s);
];
[ CIndefArt obj i s;
    if ((obj == 0)) {
        LIST_WRITER_INTERNAL_RM(88);
        rtrue;
    }
    (i = indef_mode);
    (indef_mode = 1);
    (s = self);
    (self = obj);
    if ((obj has proper)) {
        (indef_mode = NULL);
        (caps_mode = 1);
        PSN__(obj);
        (indef_mode = i);
        (caps_mode = 0);
        (self = s);
        rtrue;
    }
    if ((((_final_propertyexists(OBJECT_TY, obj, A_article))) && ((TEXT_TY_Compare((obj.article), EMPTY_TEXT_VALUE) ~= 0)))) {
        TEXT_TY_Say_Capitalised((obj.article));
        print " ";
        PSN__(obj);
        (indef_mode = i);
        (self = s);
        rtrue;
    }
    PrefaceByArticle(obj, 2, 0, 1);
    (indef_mode = i);
    (self = s);
];
[ DefArt obj i s;
    (i = indef_mode);
    (indef_mode = 0);
    (s = self);
    (self = obj);
    if ((((~~((obj ofclass Object)))) || ((obj has proper)))) {
        (indef_mode = NULL);
        PSN__(obj);
        (indef_mode = i);
        (self = s);
        rtrue;
    }
    PrefaceByArticle(obj, 1);
    (indef_mode = i);
    (self = s);
];
[ CDefArt obj i s;
    (i = indef_mode);
    (indef_mode = 0);
    (s = self);
    (self = obj);
    if ((((obj ofclass Object)) && ((obj has proper)))) {
        (indef_mode = NULL);
        (caps_mode = 1);
        PSN__(obj);
        (indef_mode = i);
        (caps_mode = 0);
        (self = s);
        rtrue;
    }
    if ((((~~((obj ofclass Object)))) || ((obj has proper)))) {
        (indef_mode = NULL);
        PSN__(obj);
        (indef_mode = i);
        (self = s);
        rtrue;
    }
    PrefaceByArticle(obj, 0);
    (indef_mode = i);
    (self = s);
];
[ GetGNAOfObject obj case gender;
    if ((gender == 0)) {
        if ((case == 0)) {
            (gender = LanguageAnimateGender);
        } else {
            (gender = LanguageInanimateGender);
        }
    }
    if ((obj has pluralname)) {
        (case = (case + 3));
    }
    return case;
];
[ PNToVP gna;
    if (prior_named_noun) {
        (gna = GetGNAOfObject(prior_named_noun));
    }
    if ((((((gna%6)/3) == 1)) || ((prior_named_list >= 2)))) {
        return 6;
    }
    return 3;
];
[ FixInhibitFlag n act inhibit_rule_debugging;
    for ((n = 0):(n < activities_sp):(n)++) {
        (act = (activities_stack-->(n)));
        if ((act == PRINTING_THE_NAME_ACT or PRINTING_THE_PLURAL_NAME_ACT or PRINTING_ROOM_DESC_DETAILS_ACT or PRINTING_INVENTORY_DETAILS_ACT or LISTING_CONTENTS_ACT or GROUPING_TOGETHER_ACT or PRINTING_RESPONSE_ACT)) {
            (inhibit_rule_debugging = 1);
        }
    }
    if ((((inhibit_flag == 0)) && (inhibit_rule_debugging))) {
        (saved_debug_rules = debug_rules);
        (debug_rules = 0);
    }
    if (((inhibit_flag) && ((inhibit_rule_debugging == 0)))) {
        (debug_rules = saved_debug_rules);
    }
    (inhibit_flag = inhibit_rule_debugging);
];
[ TestActivity A desc val i;
    for ((i = 0):(i < activities_sp):(i)++) {
        if (((activities_stack-->(i)) == A)) {
            if (desc) {
                if ((desc)((activity_parameters_stack-->(i)))) {
                    rtrue;
                }
            } else {
                if (val) {
                    if ((val == (activity_parameters_stack-->(i)))) {
                        rtrue;
                    }
                } else {
                    rtrue;
                }
            }
        }
    }
    rfalse;
];
[ ActivityEmpty A x;
    (x = (Activity_before_rulebooks-->(A)));
    if (((rulebooks_array-->(x)) ~= EMPTY_RULEBOOK)) {
        rfalse;
    }
    (x = (Activity_for_rulebooks-->(A)));
    if (((rulebooks_array-->(x)) ~= EMPTY_RULEBOOK)) {
        rfalse;
    }
    (x = (Activity_after_rulebooks-->(A)));
    if (((rulebooks_array-->(x)) ~= EMPTY_RULEBOOK)) {
        rfalse;
    }
    rtrue;
];
[ RulebookEmpty rb;
    if (((rulebooks_array-->(rb)) ~= EMPTY_RULEBOOK)) {
        rfalse;
    }
    rtrue;
];
[ ProcessActivityRulebook rulebook parameter rv;
    @push self;
    if (parameter) {
        (self = parameter);
    }
    (rv = FollowRulebook(rulebook, parameter, 1));
    @pull self;
    if (rv) {
        rtrue;
    }
    rfalse;
];
[ CarryOutActivity A o rv;
    BeginActivity(A, o);
    (rv = ForActivity(A, o));
    EndActivity(A, o);
    return rv;
];
[ BeginActivity A o x;
    if ((activities_sp == MAX_NESTED_ACTIVITIES)) {
        return RunTimeProblem(RTP_TOOMANYACTS);
    }
    ((activity_parameters_stack-->(activities_sp)) = o);
    ((activities_stack-->((activities_sp)++)) = A);
    FixInhibitFlag();
    MStack_CreateAVVars(A);
    return ProcessActivityRulebook((Activity_before_rulebooks-->(A)), o);
];
[ ForActivity A o x;
    return ProcessActivityRulebook((Activity_for_rulebooks-->(A)), o);
];
[ EndActivity A o rv x;
    if ((((activities_sp > 0)) && (((activities_stack-->((activities_sp - 1))) == A)))) {
        (rv = ProcessActivityRulebook((Activity_after_rulebooks-->(A)), o));
        (activities_sp)--;
        FixInhibitFlag();
        MStack_DestroyAVVars(A);
        return rv;
    }
    return RunTimeProblem(RTP_CANTEND);
];
[ AbandonActivity A o;
    if ((((activities_sp > 0)) && (((activities_stack-->((activities_sp - 1))) == A)))) {
        (activities_sp)--;
        FixInhibitFlag();
        MStack_DestroyAVVars(A);
        rtrue;
    }
    return RunTimeProblem(RTP_CANTABANDON);
];
#ifdef BASICINFORMKIT;
[ _final_propertyvalue K o p t;
    if (K == OBJECT_TY) {
        if (metaclass(o) == Object) {
            t = p-->0; p = p-->1;
            if (t == 2) { if (o has p) rtrue; rfalse; }
            if (o provides p) return o.p;
        }
        rfalse;
    } else {
        t = value_property_holders-->K;
        return (t.(p-->1))-->(o+COL_HSIZE);
    }
];
#endif;
#ifdef BASICINFORMKIT;
[ _final_propertyexists K o p holder;
if (K == OBJECT_TY) {
    if ((o) && (metaclass(o) == Object)) {
        if ((p-->0 == 2) || (o provides p-->1)) {
            rtrue;
        } else {
            rfalse;
        }
    } else {
        rfalse;
    }
} else {
    if ((o >= 1) && (o <= value_ranges-->K)) {
        holder = value_property_holders-->K;
        if ((holder) && (holder provides p-->1)) {
            rtrue;
        } else {
            rfalse;
        }
    } else {
        rfalse;
    }
}
rfalse; ];
#endif;
#ifdef BASICINFORMKIT;
[ _final_propertyarray K o p v t;
    if (K ~= OBJECT_TY) return 0;
    t = p-->0; p = p-->1;
    if (t == 2) return 0;
    return o.&p;
];
#endif;
#ifdef BASICINFORMKIT;
[ _final_propertylength K o p v t;
    if (K ~= OBJECT_TY) return 0;
    t = p-->0; p = p-->1;
    if (t == 2) return 0;
    return o.#p;
];
#endif;
#ifdef BASICINFORMKIT;
[ _final_store_property K o p v t;
    if (K == OBJECT_TY) {
        if (metaclass(o) == Object) {
            t = p-->0; p = p-->1;
            if (t == 2) {
                if (v) give o p; else give o ~p;
            } else if (o provides p) {
                o.p = v;
            }
        }
    } else {
        ((value_property_holders-->K).(p-->1))-->(o+COL_HSIZE) = v;
    }
];
[ _final_preinc_property K o p t;
    if (K == OBJECT_TY) {
        if (metaclass(o) == Object) {
            t = p-->0; p = p-->1;
            if (t == 2) {
                if (o has p) { give o ~p; rfalse; } give o p; rtrue;
            } else if (o provides p) {
                return ++(o.p);
            }
        }
    } else {
       return ++(((value_property_holders-->K).(p-->1))-->(o+COL_HSIZE));
    }
    return 0;
];
[ _final_predec_property K o p t;
    if (K == OBJECT_TY) {
        if (metaclass(o) == Object) {
            t = p-->0; p = p-->1;
            if (t == 2) {
                if (o has p) { give o ~p; rfalse; } give o p; rtrue;
            } else if (o provides p) {
                return --(o.p);
            }
        }
    } else {
       return --(((value_property_holders-->K).(p-->1))-->(o+COL_HSIZE));
    }
    return 0;
];
[ _final_postinc_property K o p t;
    if (K == OBJECT_TY) {
        if (metaclass(o) == Object) {
            t = p-->0; p = p-->1;
            if (t == 2) {
                if (o has p) { give o ~p; rtrue; } give o p; rfalse;
            } else if (o provides p) {
                return (o.p)++;
            }
        }
    } else {
       return (((value_property_holders-->K).(p-->1))-->(o+COL_HSIZE))++;
    }
    return 0;
];
[ _final_postdec_property K o p t;
    if (K == OBJECT_TY) {
        if (metaclass(o) == Object) {
            t = p-->0; p = p-->1;
            if (t == 2) {
                if (o has p) { give o ~p; rtrue; } give o p; rfalse;
            } else if (o provides p) {
                return (o.p)--;
            }
        }
    } else {
       return (((value_property_holders-->K).(p-->1))-->(o+COL_HSIZE))--;
    }
    return 0;
];
[ _final_setbit_property K o p v t;
    if (K == OBJECT_TY) {
        if (metaclass(o) == Object) {
            t = p-->0; p = p-->1;
            if (t == 2) {
                if (v & 1) give o p;
            } else if (o provides p) {
                o.p = o.p | v;
            }
        }
    } else {
        ((value_property_holders-->K).(p-->1))-->(o+COL_HSIZE) =
            ((value_property_holders-->K).(p-->1))-->(o+COL_HSIZE) | v;
    }
];
[ _final_clearbit_property K o p v t;
    if (K == OBJECT_TY) {
        if (metaclass(o) == Object) {
            t = p-->0; p = p-->1;
            if (t == 2) {
                if (v & 1) give o ~p;
            } else if (o provides p) {
                o.p = o.p & ~v;
            }
        }
    } else {
        ((value_property_holders-->K).(p-->1))-->(o+COL_HSIZE) =
            ((value_property_holders-->K).(p-->1))-->(o+COL_HSIZE) & ~v;
    }
];
#endif;
#ifdef BASICINFORMKIT;
[ _final_message0 o p q x a rv;
    if (p-->0 == 2) return 0;
    q = p-->1; return o.q();
];
[ _final_message1 o p v1 q x a rv;
    if (p-->0 == 2) return 0;
    q = p-->1; return o.q(v1);
];
[ _final_message2 o p v1 v2 q x a rv;
    if (p-->0 == 2) return 0;
    q = p-->1; return o.q(v1, v2);
];
[ _final_message3 o p v1 v2 v3 q x a rv;
    if (p-->0 == 2) return 0;
    q = p-->1; return o.q(v1, v2, v3);
];
#endif;
